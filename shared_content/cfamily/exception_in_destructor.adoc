Throwing an exception from a destructor may result in a call to `std::terminate` and can introduce undefined behavior, meaning that your program could be terminated abruptly without being allowed to perform a clean shutdown.

== Why is this an issue?

Destructors are usually (implicitly) declared as `noexcept` by default such that `std::terminate` is called when they throw an exception.
Destructors may still propagate an exception if they are explicitly declared as `noexcept(false)`.
However, even a destructor declared as `noexcept(false)` will call `std::terminate` if it throws during stack unwinding.

A commonly used example that highlights the severity of the underlying problem is presented in what follows:

The destructor of a container needs to call the destructors for all managed objects.
Suppose a call to an object's destructor throws an exception.
In that case, there are only two _conceptual_ ways to proceed:

1. Abort destruction. This will result in a partially destroyed object and possibly many more objects whose destructor has not been called.
2. Ignore the exception and proceed with destroying the remaining objects. However, this potentially results in more partially destroyed objects if further destructors throw an exception.

Both options are undesired; hence, whenever an object managed by a C++ standard container throws an exception, the behavior is undefined.

Thus, destructors should never `throw` exceptions.
Instead, they should catch and handle those thrown by the functions they call and be `noexcept`.