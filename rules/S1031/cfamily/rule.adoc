It is undefined behaviour if, for a set of template-arguments, an implicit instantiation is generated by the compiler, and a partial or explicit specialization is declared or defined elsewhere in the program that would match the set of template-arguments.


== Noncompliant Code Example

----
// tmpl.h
template <typename T> void bad_tmpl () {}

// tmpl.cc
#include "tmpl.h"
template <> void bad_tmpl<int32_t> () {} // Noncompliant, should be moved to tmpl.h

// f.cc
#include <tmpl.h>
void f ()
{
  bad_tmpl<int32_t> (); // implicit instantiation of primary. explicit instantiation in tmpl.cc would have been used if it were visible.
}
----


== Compliant Solution

----
// tmpl.h
template <typename T> void good_tmpl () {}
template <> void bad_tmpl<int32_t> () {} // Compliant 

// f.cc
#include <tmpl.h>
void f ()
{
  good_tmpl<int32_t> (); // specialization of good_tmpl<int32_t> is used
}
----


== See

* MISRA {cpp}:2008, 14-7-3


ifdef::env-github,rspecator-view[]

'''
== Implementation Specification
(visible only on this page)

include::message.adoc[]

endif::env-github,rspecator-view[]
