<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In some cases, we might end up with some code that assigns an object to itself. Therefore, when writing an <code>operator=</code>, we must ensure that this use case works correctly, which may require special care. One technique to achieve this is to explicitly check at the start of <code>operator=</code> if we are assigning to ourselves, and in that case, just do nothing.</p>
</div>
<div class="paragraph">
<p>It is usually a bad idea to perform this check for optimization purposes only, because it optimizes for a very rare case while adding an extra check for the more common case. But when it is necessary for correctness, it should be added.</p>
</div>
<div class="paragraph">
<p>This rule raises an issue when an <code>operator=</code> does not check for assignment to self before proceeding with the assignment.</p>
</div>
<div class="sect2">
<h3 id="_noncompliant_code_example">Noncompliant code example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">class MyClass
{
  private:
  int someVal;
  char* pData;

  MyClass&amp; operator=(const MyClass&amp; rhs)
  {
    this-&gt;someVal = rhs.someVal;              // useless operation in self-assignment, but very fast
    delete [] pData;                          // data is lost in self-assignment
    pData = new char[strlen(rhs.pData) +1];   // null pointer dereference or use after free in self-assignment
    strcpy(pData, rhs.pData);

    return (*this);
  }
};</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_compliant_solution">Compliant solution</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">class MyClass
{
  private:
  int someVal;
  char* pData;

  MyClass&amp; operator=(const MyClass&amp; rhs)
  {
    if (this != &amp;rhs)
    {
      this-&gt;someVal = rhs.someVal;
      delete [] pData;
      pData = new char[strlen(rhs.pData) +1];
      strcpy(pData, rhs.pData);
    }
    return (*this);
  }
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or much better:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">class MyClass
{
  private:
  int someVal;
  std::string data; // No need for manual operator=
};</code></pre>
</div>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_implementation_specification">Implementation Specification</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_message">Message</h3>
<div class="paragraph">
<p>Check "XXX" for equality to "this" before proceeding with the assignment.</p>
</div>
</div>
</div>
</div>