<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Passing parameters by reference instead of by value avoids the overhead of making a copy. Passing arguments via copy should only be done when it is technically mandated, as it is for example with RFC function modules.</p>
</div>
<div class="sect2">
<h3 id="_noncompliant_code_example">Noncompliant code example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-abap" data-lang="abap">PERFORM subr USING a1 a2 a3 a4 a5.</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_compliant_solution">Compliant solution</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-abap" data-lang="abap">PERFORM subr CHANGING a1 a2 a3 a4 a5.</code></pre>
</div>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_implementation_specification">Implementation Specification</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_message">Message</h3>
<div class="paragraph">
<p>Pass [large|polymorphic|large polymorphic] object "XXX" by reference to const</p>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_comments_and_links">Comments And Links</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_on_15_feb_2019_200432_loïc_joly_wrote">on 15 Feb 2019, 20:04:32 Loïc Joly wrote:</h3>
<div class="paragraph">
<p>Some history on the implementation of this rule for C&#43;&#43; that may be interesting for my future self (or maybe to write a blog article):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>First implementation, strictly follow C&#43;&#43; core guidelines (threshold for size &gt; 2*sizeof(void*), larger types are forced by const&amp;, smaller types are forced to value), and in addition force passing by const&amp; types without trivially copyable types (goal: Avoid slicing and avoid passing a string by value)</p>
</li>
<li>
<p>Too many issues. We decided to use a higher threshold and never ask to pass by value something that is passed by const &amp;, even if small:</p>
<div class="ulist">
<ul>
<li>
<p>The user of a type does not always have to know that it is small</p>
</li>
<li>
<p>The expected performance gain is much smaller than the one in the other direction</p>
</li>
<li>
<p>It&#8217;s not possible to ignore an issue for a whole type, we have to ignore it function per function, which does not seem reasonable</p>
</li>
<li>
<p>We can create another rule, in the other direction, with lower priority and out or SonarWay for people who want to hunt for the extra speed gain</p>
</li>
</ul>
</div>
</li>
<li>
<p>Too many issues, we decide to focus on function definitions (declarations may come from 3rd party libraries)</p>
</li>
<li>
<p>Too many issues, we decided to remove the requirement for no user-defined copy contructor to allow pass by value</p>
<div class="ulist">
<ul>
<li>
<p>Sometimes, the price of the user-defined copy constructor is not that high (QString that relies on COW or std::shared_ptr comes to mind), even if avoiding extra copies is still interesting.</p>
</li>
<li>
<p>In some cases, it&#8217;s even faster to pass by copy, even for large types &#8658; if we modify the copy inside the function, without altering the original (computing the median of a vector, passing a shared_ptr by copy, then move from it to store it in a contained)</p>
</li>
<li>
<p>Detecting those cases means detecting that something is modified, which is probably impossible to do perfectly, and more importantly which is difficult to do with a good enough approximation (but we should do this approximation, it&#8217;s useful for this rule and several others, we just did not have time for that)</p>
</li>
<li>
<p>We believe that even in the current state, the rule will provide some value and not too many false positives on classical projects</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>