This is an issue when an Angular component or directive implements both `DoCheck` and `OnChanges` lifecycle interfaces, or defines both `ngDoCheck()` and `ngOnChanges()` methods.

== Why is this an issue?

Angular provides different lifecycle hooks for change detection, each serving specific purposes. The `OnChanges` interface is designed to detect changes in input properties, while `DoCheck` allows for custom change detection logic that runs during every change detection cycle.

Implementing both interfaces creates conflicting change detection strategies. This can lead to:

* Performance degradation due to redundant change detection logic
* Unpredictable behavior when both hooks try to handle the same changes
* Code complexity that makes the component harder to understand and maintain
* Potential infinite loops if the hooks trigger each other

The Angular framework expects developers to choose the most appropriate lifecycle hook for their specific use case, not to use multiple conflicting ones simultaneously.

=== What is the potential impact?

Using conflicting lifecycle interfaces can cause performance issues due to redundant change detection cycles, unpredictable component behavior, and increased code complexity that makes the application harder to maintain and debug.

=== How to fix in Angular?

Choose either `DoCheck` or `OnChanges` based on your needs. Use `OnChanges` when you need to react to input property changes, or `DoCheck` when you need custom change detection logic.

==== Non-compliant code example

[source,typescript,diff-id=1,diff-type=noncompliant]
----
class MyComponent implements DoCheck, OnChanges { // Noncompliant
  ngDoCheck() {
    // Custom change detection logic
  }
  
  ngOnChanges(changes: SimpleChanges) {
    // Handle input changes
  }
}
----

==== Compliant code example

[source,typescript,diff-id=1,diff-type=compliant]
----
// Option 1: Use OnChanges for input property changes
class MyComponent implements OnChanges {
  ngOnChanges(changes: SimpleChanges) {
    // Handle input changes
  }
}

// Option 2: Use DoCheck for custom change detection
class MyComponent implements DoCheck {
  ngDoCheck() {
    // Custom change detection logic
  }
}
----

Remove conflicting lifecycle methods when they serve the same purpose. Keep only the method that best fits your component's requirements.

==== Non-compliant code example

[source,typescript,diff-id=2,diff-type=noncompliant]
----
class MyComponent {
  ngDoCheck() { // Noncompliant
    // Custom change detection
  }
  
  ngOnChanges(changes: SimpleChanges) { // Noncompliant
    // Handle input changes
  }
}
----

==== Compliant code example

[source,typescript,diff-id=2,diff-type=compliant]
----
class MyComponent {
  ngOnChanges(changes: SimpleChanges) {
    // Handle input changes - most common use case
  }
}
----

=== Documentation

 * Angular Lifecycle Hooks Guide - https://angular.io/guide/lifecycle-hooks[Official Angular documentation explaining all lifecycle hooks and their proper usage]
 * OnChanges Interface - https://angular.io/api/core/OnChanges[Angular API documentation for the OnChanges lifecycle interface]
 * DoCheck Interface - https://angular.io/api/core/DoCheck[Angular API documentation for the DoCheck lifecycle interface]

