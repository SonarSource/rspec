This rule raises an issue if initializer of the global variable,
refers to  other global variable that may not yet be initialized.

== Why is this an issue?

{cpp} allows global variables, to have arbitrally complex initializers.

Such variables are zero-initialized at the start of the program,
and further initialization is performed at runtime,
in the process reffered as dynamic initialization.

The dynamic such variables is performed in the order of they defintions in the source file.
However, the order of initialization of variables defined in different source files is not specified.
In case when the global variable refers to variable defined in different source file,
the behavior of the program is not guaranteed:

[source,cpp]
----
extern int global1;
// Defined in different source file as:
// int global1 = 20;

int const global2 = global1 + 10; // Noncomplaint
----

Depending on the ordering of the initialization of `global1` and `global2` variables,
the `global2` may be set to:

* `30` if `global1` is initialized before `global2`
* `10` if `global2` is initialized before `global1`, as `global1` will have value `0`.

This rule raises issue if the initializer of the global variable,
directly refers to the other global variable, that may not yet be initialized.
In other words, refering to other variable is not required to be initialized before given variable.

This is subset of issues related to initialization of global variables,
commonly reffered as static initialization order fiasco.

=== What is the potential impact?

The bahavior of any program that is prone to static initialization order fiasco issue,
is very fragile.
The order of initialization may change with modification of source files,
that does not contain impacted variable, or even differ between the builds of same source.
As such any such issues are hard to reproduce and debug.

Furthermore, the impact of this issues are vast and varied.
It is not only limited to observing different values of variables betwen builds,
as presented in example of `global1` and `global2`.

For the class types, invoking any member functions of object that was zero-initialized,
but for which constructor was not run, may cause undefined behavior and crash the program:

[source,cpp]
----
extern std::string const string1;
std::string const string2 = string1; // Noncompliant: undefined behavior
----

And even, in case when particular implementation supports using zero-initialized object,
the program may still encounter undefined-behavior even:

[source,cpp]
----
extern std::vector<std::string> const list;
// Defined in different source file as:
// std::vector<std::string> const list{"entry1", "entry2"};

std::string const firstElem = list[0]; // Noncompliant: undefined behavior
----

=== Static class data members also use dynamic initialization

Static data members of the class, are dynamically initialized, if they initializer is not constant expression.
As in of global variables, the rule will raise issue, if static data member of the class with dynamic initialization:
 * is refering to global variable of static data member of the class that may not yet be initialized
 * is refered by initializer of global variable of static data member of class in place, when it may not yet be initialized.

[source,cpp]
----
// Clazz.hpp
extern int global;
class Clazz {
  static int staticMem;
};

// Clazz.cpp
#include "Clazz.hpp"

int Clazz::staticMem = global + 10; // Non-complaint: `global` may not yet be initialized

// Source.cpp
#include "Clazz.hpp"

int global = 10;
int otherGlobal = Clazz::staticMem; // Non-complaint: `Clazz::staticMem` may not yet be initalized
----

=== Initialization of variable template instantiations is unordered

The {cpp}14 introduced possibilty to define a template for the global variable, that can be instantiated by providing a template argument.
If instantition of such template requires a dynamic initialization (because initialization is non-constant),
there is no guarantee for the ordering of such initialization.
It may be performed before initializer of global variable that was declared before it.
As consequence any such variable should not refer in initializer or be refered from initializer,
any global variables with dynamic initialization.

[source,cpp]
----
int global1 = runtimeFunc();

template<typename T>
T varTempl = global1; // Non-compliant: `global1` may be initializer later

int global2 = varTempl<long>; // Non-complaint: `varTempl` may be initializer later
----


Similary, the intialization of static data members of class template instantiations are unordered:
[source,cpp]
----
int global1 = runtimeFunc();

template<typename T>
struct Clazz {
  static T staticMem;
};

template<typename T>
T Clazz<T>::staticMem = global1; // Non-compliant: `global1` may be initializer later

int global2 = Clazz<long>::staticMem; // Non-complaint: `Clazz<long>::varTempl` may be initializer later
----

To avoid such problems initializers of variable templates, should refer only to constant global variables.

== How to fix it

This section present few general approaches to resolving issues related to order of initialization,
covering various scenarios and uses of the code.

=== Define connected variables in one source file.

As order of initialization is defined by the standard for variables defined in same file,
defining all dependent variables in single source file addressed the issue.

==== Noncompliant code example

[source,cpp,diff-id=1,diff-type=noncompliant]
----
// header.h
extern std::string s1;
extern std::string s2;

// source1.cpp
#include "header.h"
std::string s1 = "Some string";

// source2.cpp
#include "header.h"
std::string s2 = s1 + " in other file"; // Noncompliant: `s1` may be initialized after `s2`
----

==== Compliant solution

[source,cpp,diff-id=1,diff-type=compliant]
----
// header.h
extern std::string s1;
extern std::string s2;

// source1.cpp
#include "header.h"
std::string s1 = "Some string";
std::string s2 = s1 + " in other file"; // Complaint: `s1` is initialized before `s2`

// source2.cpp
#include "header.h"
----

=== Force constant initialization of reffered variable.

Order of initialization issues are limited to variables that are initialized at runtime (has dynamic initialization),
and does not affect variable that are initialized at compile time, i.e. has constant initialization.

This requires the initializer of the variable to be available at compile time,
i.e. use only literals, other constant variables, and invocation of `constexpr` functions or constructors.

==== Noncompliant code example

[source,cpp,diff-id=2,diff-type=noncompliant]
----
// header.h
extern int const count;
extern std::vector<int> entries;

// source1.cpp
#include "header.h"
int const count = 20;

// source2.cpp
#include "header.h"
std::vector<int> entries(count); // Noncomplaint: `count` may not initialized before `entries`
----

==== Compliant solution

If the project uses {cpp}11 or later standard, you may defined the variable as `constexpr`, to foce constant initialization.
In case when the initialization cannot be performed at compile time, the program will be ill-formed.

[source,cpp,diff-id=2,diff-type=compliant]
----
// header.h
constexpr int count = 20;
extern std::vector<int> entries;

// source1.cpp
#include "header.h"

// source2.cpp
#include "header.h"
std::vector<int> entries(count); // Complaint: `count` is initialized as compile time to 20
----

If the project is limited to {cpp}98/{cpp}03, the constant initialization is only supported for the variables of integral types,
that are defined as `const` and user literals or other constant in initializer.

[source,cpp]
----
// header.h
int const count = 20;
extern std::vector<int> entries;

// source1.cpp
#include "header.h"

// source2.cpp
#include "header.h"
std::vector<int> entries(count); // Complaint: `count` is initialized as compile time to 20
----

==== Handling class static data members

If the static data member is constant, it's value may be defined in class:
[source,cpp]
----
struct Clazz {
  static int const constMem = 10;
  static constexpr int constexprMem = 10;
};
----

However, in case of `const` members and `constexpr` static data members before {cpp}17,
the definition of the class needs to be provided when address or reference to such variable is taken.

Such defintion should not repeat the initializer, and can be placed in source file:
[source,cpp]
----
int const Clazz::constMem;
int const Clazz::constexprMem; // const is implied by `constexpr`
----

Or when using {cpp}17 or later in the header file with `inline` keyword,
in this case only `const` variable needs to be defined:
[source,cpp]
----
inline int const Clazz::constMem;
----

==== Using `inline` to avoid multiple definitions.

In {cpp} variables declares as `const`, which also covers `constexpr`, has internal linkage.
This means that they are not visible outside of the source file.
As consequence multiple files can defined variable with same name, and each of such file will contain indenpedent copy of variable.

This affects also cases, when `const` variable is defined in the header file, that is included from multiple files.
In the following example, each `source1.cpp` and `source2.cpp` files contains independent copies of variables `count`.

[source,cpp]
----
// header.h
constexpr int count = 20;

// source1.cpp
#include "header.h"

void print1() {
  std::cout << &count << std::endl;
}

// source2.cpp
#include "header.h"

void print2() {
  std::cout << &count << std::endl;
}
----

This behavior is usually not affecting the code, as the value read from the variable is always the same, due it being `const`.
However, the taking the address of such variable will produce different result (i.e. `print1` and `print2` will produce different outputs).

Since {cpp}17 this may be addressed by makrking such variable as `inline`, for more details plese refer to later section.

=== Replace global variable with static function variable

A static variable defined in the function body, is initialized when the function is called for the first time,
so it is not possible to read it value before the initialization.
In consequence, replacing a global variable with a function that declares a static variable and return reference to it eliminates the order of initialization issues.

==== Noncompliant code example

[source,cpp,diff-id=3,diff-type=noncompliant]
----
// header.h
extern std::string s1;
extern std::string s2;

// source1.cpp
#include "header.h"
std::string s1 = "Some string";

// source2.cpp
#include "header.h"
std::string s2 = s1 + " in other file"; // Noncompliant: `s1` may be initialized after `s2`
----

==== Compliant solution

[source,cpp,diff-id=3,diff-type=compliant]
----
// header.h
std::string& getS1();
extern std::string s2;

// source1.cpp
#include "header.h"
std::string& getS1() {
  static std::string s1 = "Some string";
  return s1;
}

// source2.cpp
#include "header.h"

std::string s2 = getS1() + " in other file"; // Compliant: `s1` is initialized as part of `getS1()` call
----

While the above is sufficient to fix the issue,
replacing `s2` with `getS2` function defined in similar way would prevent future problems.

This solution is also aplicable for the variable templates and static data members of class templates.

[source,cpp,diff-id=4,diff-type=noncompliant]
----
template<typename CharT>
std::basic_string<CharT> const basicBuildID = /* runtime initializer */;

std::string const buildID = basicBuildID<char>(); // Noncompliant: `basicBuildID<char>` may not be initialized
----

==== Compliant solution

[source,cpp,diff-id=4,diff-type=compliant]
----
template<typename CharT>
std::basic_string<CharT> const& getBuildID() {
  static std:basic_stirng<CharT> basicBuildID =  /* runtime initializer */;
  return basicBuildID;
}

std::string const buildID = getBuildID<char>(); // Compliant: `basicBuildID` is intialized as part of `getBuildID<char>` call
----

=== Define variables as inline in the header

With introduction of `inline` variables in the {cpp}17, non-local variables can be now defined in header without causing double definition errors.
Dynamic initialization of any such `inline` variables is performed before any variable that are consistently defined after it  source files,
which is generaly true for variables defined in same headers, or in source that always include given header.

==== Noncompliant code example

[source,cpp,diff-id=5,diff-type=noncompliant]
----
// header.h
extern std::string s1;
extern std::string s2;

// source1.cpp
#include "header.h"
std::string s1 = "Some string";

// source2.cpp
#include "header.h"
std::string s2 = s1 + " in other file"; // Noncompliant: `s1` may be initialized after `s2`
----

==== Compliant solution

[source,cpp,diff-id=5,diff-type=compliant]
----
// header.h
inline std::string s1 = "Some string";
extern std::string s2;

// source1.cpp
#include "header.h"

// source2.cpp
#include "header.h"
std::string s2 = s1 + " in other file"; // Compliant: `s1` may be initialized after `s2`
----

Again, declaring `s1` in the header file is sufficient for adressing the issue,
however changing `s2` to also be declared in header file, will prevent initialization order issues related to them.

==== `inline` and templates

Instantiations of variable templates and static data members of class template instantiation, are implicitly `inline`.
As consequence marking them as `inline` does not have impact of order of initialization, and does not prevent the issue from occuring.

== Resources

=== Documentation

* {cpp} reference - https://en.cppreference.com/w/cpp/language/siof[Static Initialization Order Fiasco]
* {cpp} reference - https://en.cppreference.com/w/cpp/language/initialization#Non-local_variables[Initialization of non-local variables]
* {cpp} reference - https://en.cppreference.com/w/cpp/language/zero_initialization[Zero-initialization]
* {cpp} reference - https://en.cppreference.com/w/cpp/language/constant_initialization[Constant initialization]
