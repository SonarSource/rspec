This rule raises an issue if initializer of the variable with static storage duration (global or static),
refers to variable that may not yet be initialized. 

== Why is this an issue?

{cpp} allows variables with static storage duration, 
such as global or static variables inside of class of funciton,
to have arbitrally complex initializers.

Such variables are zero-initialized at the start of the program,
and further initialization is performed at runtime,
in the process reffered as dynamic initialization.

The dynamic such variables is performed in the order of they defintions in the source file.
However, the order of initialization of variables defined in different source files is not specified.
In case when the global variable refers to variable defined in different source file,
the behavior of the program is not guaranteed:

[source,cpp]
----
extern int global1;
// Defined in different source file as:
// int global1 = 20;

int const global2 = global1 + 10; // Noncomplaint 
----

Depending on the ordering of the initialization of `global1` and `global2` variables,
the `global2` may be set to:

* `30` if `global1` is initialized before `global2`
* `10` if `global2` is initialized before `global1`, as `global1` will have value `0`.

This rule raises issue if the initializer of the global or static variable,
directly refers to the other global variable, that may not yet be initialized.
In other words, refering to a variable is not required to be initialized before given variable.

This is subset of issues related to initialization of global variables,
commonly reffered as static initialization order fiasco.

=== What is the potential impact?

The bahavior of any program that is prone to static initialization order fiasco issue,
is very fragile. 
The order of initialization may change with modification of source files, 
that does not contain impacted variable, or even differ between the builds of same source.
As such any such issues are hard to reproduce and debug.

Furthermore, the impact of this issues are vast and varied.
It is not only limited to observing different values of variables betwen builds,
as presented in example of `global1` and `global2`.

For the class types, invoking any member functions of object that was zero-initialized,
but for which constructor was not run, may cause undefined behavior and crash the program:

[source,cpp]
----
extern std::string const string1;
std::string const string2 = string1; // Noncompliant: undefined behavior
----

And even, in case when particular implementation supports using zero-initialized object,
the program may still encounter undefined-behavior even:

[source,cpp]
----
extern std::vector<std::string> const list;
// Defined in different source file as:
// std::vector<std::string> const list{"entry1", "entry2"};

std::string const firstElem = list[0]; // Noncompliant: undefined behavior
----

=== Static variable in template classes and variable templates are also impacted

TODO

== How to fix it

This section present few general approaches to resolving issues related to order of initialization,
covering various scenarios and uses of the code.

=== Define connected variables in one source file.

As order of initialization is defined by the standard for variables defined in same file,
defining all dependent variables in single source file addressed the issue. 

==== Noncompliant code example

[source,cpp,diff-id=1,diff-type=noncompliant]
----
// header.h
extern std::string s1;
extern std::string s2;

// source1.cpp
#include "header.h"
std::string s1 = "Some string";

// source2.cpp
#include "header.h"
std::string s2 = s1 + " in other file"; // Noncompliant: `s1` may be initialized after `s2`
----

==== Compliant solution

[source,cpp,diff-id=1,diff-type=compliant]
----
// header.h
extern std::string s1;
extern std::string s2;

// source1.cpp
#include "header.h"
std::string s1 = "Some string";
std::string s2 = s1 + " in other file"; // Complaint: `s1` is initialized before `s2`

// source2.cpp
#include "header.h"
----

=== Force constant initialization of reffered variable.

Order of initialization issues are limited to variables that are initialized at runtime (has dynamic initialization),
and does not affect variable that are initialized at compile time, i.e. has constant initialization.

This requires the initializer of the variable to be available at compile time, 
i.e. use only literals, other constant variables, and invocation of `constexpr` functions or constructors.

==== Noncompliant code example

[source,cpp,diff-id=2,diff-type=noncompliant]
----
// header.h
extern int const count;
extern std::vector<int> entries;

// source1.cpp
#include "header.h"
int const count = 20;

// source2.cpp
#include "header.h"
std::vector<int> entries(count); // Noncomplaint: `count` may not initialized before `entries`
----

==== Compliant solution

If the project uses {cpp}11 or later standard, you may defined the variable as `constexpr`, to foce constant initialization.
In case when the initialization cannot be performed at compile time, the program will be ill-formed.

[source,cpp,diff-id=2,diff-type=compliant]
----
// header.h
constexpr int count = 20;
extern std::vector<int> entries;

// source1.cpp
#include "header.h"

// source2.cpp
#include "header.h"
std::vector<int> entries(count); // Complaint: `count` is initialized as compile time to 20
----

If the project is limited to {cpp}98/{cpp}03, the constant initialization is only supported for the variables of integral types,
that are defined as `const` and user literals or other constant in initializer.

[source,cpp]
----
// header.h
int const count = 20;
extern std::vector<int> entries;

// source1.cpp
#include "header.h"

// source2.cpp
#include "header.h"
std::vector<int> entries(count); // Complaint: `count` is initialized as compile time to 20
----

==== Using `inline` to avoid multiple definitions. 

In {cpp} variables declares as `const`, which also covers `constexpr`, has internal linkage.
This means that they are not visible outside of the source file.
As consequence multiple files can defined variable with same name, and each of such file will contain indenpedent copy of variable.

This affects also cases, when `const` variable is defined in the header file, that is included from multiple files.
In the following example, each `source1.cpp` and `source2.cpp` files contains independent copies of variables `count`.

[source,cpp]
----
// header.h
constexpr int count = 20;

// source1.cpp
#include "header.h"

void print1() {
  std::cout << &count << std::endl;
}

// source2.cpp
#include "header.h"

void print2() {
  std::cout << &count << std::endl;
}
----

This behavior is usually not affecting the code, as the value read from the variable is always the same, due it being `const`.
However, the taking the address of such variable will produce different result (i.e. `print1` and `print2` will produce different outputs).

Since {cpp}17 this may be addressed by makrking such variable as `inline`, for more details plese refer to later section.


=== Define.


* static variable in function
* inline variable

* pitfall: const implies static - may need inline



//=== How does this work?

//=== Pitfalls

//=== Going the extra mile


== Resources

=== Documentation

* {cpp} reference - https://en.cppreference.com/w/cpp/language/siof[Static Initialization Order Fiasco]
* {cpp} reference - https://en.cppreference.com/w/cpp/language/initialization#Non-local_variables[Initialization of non-local variables]
* {cpp} reference - https://en.cppreference.com/w/cpp/language/zero_initialization[Zero-initialization]
* {cpp} reference - https://en.cppreference.com/w/cpp/language/constant_initialization[Constant initialization]
