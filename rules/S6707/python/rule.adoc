This rule raises an issue when the comparison variable compared with ``++numpy.nan++``.

== Why is this an issue?

Comparing variables with ``++numpy.nan++`` in NumPy can lead to unexpected and incorrect results due to the special nature of ``++numpy.nan++`` as a "Not a Number" value. NumPy treats ``++numpy.nan++`` as a placeholder for undefined or missing values in numerical computations. Because of its unique properties, comparing variables with ``++numpy.nan++`` using standard comparison operators can produce indeterminate and counterintuitive outcomes.

=== Code examples

==== Noncompliant code example

[source,python,diff-id=1,diff-type=noncompliant]
----
import numpy as np

x = np.nan

if x == np.nan: # Noncompliant: always False
    ...
----


==== Compliant solution

[source,python,diff-id=1,diff-type=compliant]
----
import numpy as np

x = np.nan

if np.isnan(x):
   ...
----

== Resources
=== Documentation
* NumPy API Reference - https://numpy.org/doc/stable/reference/constants.html#numpy.nan[numpy.nan]
* NumPy API Reference - https://numpy.org/doc/stable/reference/generated/numpy.isnan.html[numpy.isnan()]


ifdef::env-github,rspecator-view[]

'''
== Implementation Specification
(visible only on this page)

=== Message

Use 'numpy.isnan()' function instead of direct comparison.


'''
== Comments And Links
(visible only on this page)

endif::env-github,rspecator-view[]
