This rule raises an issue when a custom exception class extends `Error` or `Throwable` instead of `Exception` or one of its subclasses.

== Why is this an issue?

Java and Groovy have a clear exception hierarchy designed for different purposes:

* `Exception` and its subclasses represent recoverable conditions that applications can handle
* `Error` and its subclasses represent serious system-level problems (like `OutOfMemoryError` or `StackOverflowError`) that applications typically cannot and should not handle
* `Throwable` is the root class for both exceptions and errors, making it too broad for specific use cases

When you extend `Error` for custom exceptions, you're misclassifying your exception as a system-level problem. This can confuse other developers and lead to improper exception handling. Code that catches `Error` expects to handle serious system failures, not application-specific problems.

Extending `Throwable` directly is also problematic because it's too general. It includes both recoverable exceptions and unrecoverable errors, making it unclear what kind of problem your custom exception represents.

Following the proper exception hierarchy makes your code more predictable and helps other developers understand how to handle your exceptions appropriately.

=== What is the potential impact?

Using the wrong exception base class can lead to:

* Confusion about whether the exception represents a recoverable application error or a serious system problem
* Improper exception handling by code that catches your custom exception
* Difficulty in debugging when system-level error handling code unexpectedly catches application exceptions
* Reduced code maintainability as the exception's purpose becomes unclear

== How to fix it

Change your custom exception to extend `Exception` instead of `Error`. This clearly indicates that your exception represents a recoverable application-level problem.

=== Code examples

==== Noncompliant code example

[source,groovy,diff-id=1,diff-type=noncompliant]
----
class MyCustomException extends Error { // Noncompliant
    MyCustomException(String message) {
        super(message)
    }
}
----

==== Compliant solution

[source,groovy,diff-id=1,diff-type=compliant]
----
class MyCustomException extends Exception {
    MyCustomException(String message) {
        super(message)
    }
}
----

== Resources

=== Documentation

 * Oracle Java Documentation - Exception Hierarchy - https://docs.oracle.com/javase/tutorial/essential/exceptions/definition.html[Official Java documentation explaining the difference between exceptions and errors]

 * Groovy Documentation - Exception Handling - https://groovy-lang.org/semantics.html#_exception_handling[Groovy-specific documentation on exception handling and best practices]

=== Standards

 * CWE-754: Improper Check for Unusual or Exceptional Conditions - https://cwe.mitre.org/data/definitions/754.html[Related to proper exception handling and classification]

=== Related rules

 * RSPEC-2166 - https://rules.sonarsource.com/java/RSPEC-2166/[Java rule for the same exception hierarchy issue]
