<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>std::forward</code> forwards lvalues either as lvalues or as rvalues based on its template argument.</p>
</div>
<div class="paragraph">
<p><code>std::forward</code> should always take as a non-template argument a forwarding reference which is defined by the standard as:</p>
</div>
<div class="paragraph">
<p><em>rvalue reference to a cv-unqualified template parameter that does not represent a template parameter of a class template.</em></p>
</div>
<div class="paragraph">
<p>If you don’t pass forwarding reference as an argument to <code>std::forward</code> <a data-rspec-id="S5417" class="rspec-auto-link">S5417</a> will be triggered.</p>
</div>
<div class="paragraph">
<p>If you don’t pass the template parameter referred to by the forwarded reference or the <code>decltype</code> of the forwarded expression this rule will be triggered.</p>
</div>
<div class="sect2">
<h3 id="_noncompliant_code_example">Noncompliant code example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">template &lt;class T&gt;
void g(T&amp;&amp; t);

template &lt;class T&gt;
void f(T&amp;&amp; t) {
 g(std::forward&lt;T&amp;&amp;&gt;(t)); // Noncompliant
 g(std::forward&lt;T&amp;&gt;(t)); // Noncompliant
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_compliant_solution">Compliant solution</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">template &lt;class T&gt;
void g(T&amp;&amp; t);

template &lt;class T&gt;
void f(T&amp;&amp; t) {
  g(std::forward&lt;T&gt;(t)); // Compliant
}

struct StrWrapper {
  std::string s = "rand";
  std::string getStr() &amp;&amp; {
    return s;
  }
  std::string&amp; getStr() &amp; {
    return s;
  }
};
template &lt;class T&gt;
void fstr(T&amp;&amp; str);

template &lt;class T&gt;
void wrapper(T&amp;&amp; strWrapper ) {
  fstr(forward&lt;decltype(forward&lt;T&gt;(strWrapper).getStr())&gt;(forward&lt;T&gt;(strWrapper).getStr())); // Compliant
}</code></pre>
</div>
</div>
</div>
</div>
</div>