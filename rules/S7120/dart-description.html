<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Widget constructors should have a <a href="https://api.flutter.dev/flutter/widgets/Widget/key.html"><code>key</code></a> parameter, forwarded to the superclass constructor.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <a href="https://api.flutter.dev/flutter/widgets/Widget/Widget.html"><code>Widget</code> constructor</a> takes a <code>key</code> as a named parameter. However, such a parameter is optional:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-dart" data-lang="dart">class Widget {
  Widget({ Key? key }) { ...}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This means that widgets inheriting from it can be created without a <code>key</code> parameter.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-dart" data-lang="dart">class MyWidget extends Widget {
  MyWidget() : super(); // No key parameter forwarded
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The same applies to the <a href="https://api.flutter.dev/flutter/widgets/StatefulWidget-class.html"><code>StatefulWidget</code></a> and the <a href="https://api.flutter.dev/flutter/widgets/StatelessWidget-class.html"><code>StatelessWidget</code></a>.</p>
</div>
<div class="paragraph">
<p>They both define constructors with an optional <code>key</code> parameter, which:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>is forwarded to the <code>Widget</code> constructor when specified</p>
</li>
<li>
<p>is not forwarded when omitted</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>That results in a widget with a <code>null</code> key.</p>
</div>
<div class="paragraph">
<p>While this is not a problem in itself, it is a good practice to always provide a <code>key</code> parameter to widgets, as it can be useful for debugging, testing, and performance optimizations.</p>
</div>
<div class="paragraph">
<p>For example, when a widget needs to potentially be rebuilt, Flutter compares the new widget with the old one to determine what has changed. If the widgets have the same key, Flutter assumes that they are the same, and it will not perform the rebuild. This can be useful when building the widget is expensive, or when the it has a state that should be preserved across rebuilds.</p>
</div>
<div class="paragraph">
<p>Scenarios where keys are useful include preserving the scroll position of a list, the state of a form, or the content of an editing collection.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_fix_it">How to fix it</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Add a <code>key</code> parameter of type <code>Key</code> to each of the constructor of the widget, and forward it to the superclass constructor:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>either using a <code>super</code> parameter formal: <code>MyWidget({ this.key });</code></p>
</li>
<li>
<p>or forwarding explicitly: <code>MyWidget({ Key? key }) : super(key: key);</code></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_code_examples">Code examples</h3>
<div class="sect3">
<h4 id="_noncompliant_code_example">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-dart" data-lang="dart">class MyWidget extends Widget {
  MyWidget() : super(); // Non compliant
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-dart" data-lang="dart">class MyWidget extends Widget {
  MyWidget({ super.key });
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_noncompliant_code_example_2">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-dart" data-lang="dart">class MyWidget extends Widget {
  final int widgetConfig;

  MyWidget(this.widgetConfig) : super(); // Non compliant
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution_2">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-dart" data-lang="dart">class MyWidget extends Widget {
  final int widgetConfig;

  MyWidget(this.widgetConfig, { Key? key }) : super(key: key);
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_documentation">Documentation</h3>
<div class="ulist">
<ul>
<li>
<p>Dart Docs - <a href="https://dart.dev/tools/linter-rules/use_key_in_widget_constructors">Dart Linter rule - use_key_in_widget_constructors</a></p>
</li>
<li>
<p>Flutter API Reference - <a href="https://api.flutter.dev/flutter/widgets/Widget/Widget.html">Widget class - constructor</a></p>
</li>
<li>
<p>Flutter API Reference - <a href="https://api.flutter.dev/flutter/widgets/Widget/key.html">Widget class - key property</a></p>
</li>
</ul>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_implementation_specification">Implementation Specification</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_message">Message</h3>
<div class="paragraph">
<p>Constructors for public widgets should have a named 'key' parameter.</p>
</div>
</div>
<div class="sect2">
<h3 id="_highlighting">Highlighting</h3>
<div class="paragraph">
<p>If the widget class has no constructor declarations in it: the identifier name of the widget class: e.g. <code>MyWidget</code> in <code>class MyWidget { &#8230;&#8203; }</code>.</p>
</div>
<div class="paragraph">
<p>If the widget class has constructors declarations in it: the identifier name of the constructor missing the <code>key</code> parameter: e.g. <code>MyWidget</code> in <code>MyWidget()</code>. If the constructor is named, only the name of the constructor is highlighted, and the class name is not: e.g. <code>named</code> in <code>MyWidget.named()</code>.</p>
</div>
</div>
</div>
</div>