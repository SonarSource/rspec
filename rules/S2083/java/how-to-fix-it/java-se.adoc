=== How to fix it in Java SE

The following code is vulnerable to path injection as it is constructing a path using untrusted data. This path is then used to delete a file without being validated first. Therefore, it can be leveraged by an attacker to delete arbitrary files.

[cols="a"]
|===
h| Non-compliant code example
|
[source,java]
----
@RestController
public class ApiController
{
    static private String targetDirectory = "/path/to/target/directory/";

    @GetMapping(value = "/endpoint")
    public void endpoint(@RequestParam("filename") filename) throws IOException {

        File file = new File(targetDirectory + filename);
        file.delete(); // Noncompliant
    }
}
----
h| Compliant solution
|
[source,java]
----
@RestController
public class ApiController
{
    static private String targetDirectory = "/path/to/target/directory/";

    @GetMapping(value = "/endpoint")
    public void endpoint(@RequestParam("filename") filename) throws IOException {

        File file = new File(targetDirectory + filename);
        String canonicalDestinationPath = file.getCanonicalPath();

        if (!canonicalDestinationPath.startsWith(targetDirectory)) {
            throw new IOException("Entry is outside of the target directory");
        }

        file.delete();
    }
}
----
|===

=== How does this work?

The universal way to prevent path injection is to validate paths constructed from untrusted data. 

The validation should be done as follow:

1. Resolve the canonical path of the file by using methods like java.io.File/getCanonicalPath. This will resolve relative path or path components like `../` and removes any ambiguity regarding the file's location. 
2. Check that the canonical path is within the directory where the file should be located.
