<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>C&#43;&#43;20 introduces rewriting rules that enable defining only a few operator overloads in a class to be able to compare class instances in many ways:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the "spaceship" <code>operator&lt;=&gt;</code> can replace all the other comparison operators in most cases: The code <code>a @ b</code> (where <code>@</code> is one of the following operators: <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, or <code>&gt;=</code>) can be implicitly rewritten to use either <code>a&lt;=&gt;b</code> or <code>b&lt;=&gt;a</code>, and its three-way comparison semantics instead.</p>
</li>
<li>
<p>If <code>operator==</code> is defined, <code>a!=b</code> can be implicitly rewritten <code>!(a==b)</code></p>
</li>
<li>
<p>If an <code>operator&lt;=&gt;</code> is defined as <code>=default</code>, a matching <code>operator==</code> is automatically generated if it does not already exist.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If you define your own version of any particular comparison operator, e.g., <code>operator&lt;</code> in addition to the <code>operator&lt;=&gt;</code>, it will supersede the compiler-generated version and might result in a surprising behavior with <code>operator&lt;</code> semantics inconsistent with the semantics of other operators defined through <code>operator&lt;=&gt;</code>.</p>
</div>
<div class="paragraph">
<p>In most cases, you will only have to define the following set of comparison operators in your class (possibly several of those sets, to allow for mixed-type comparison):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>No comparison operator, if the class should not be compared, or</p>
</li>
<li>
<p>only <code>operator==</code> for classes that can only be compared for equality (and inequality), or</p>
</li>
<li>
<p>only <code>operator&lt;=&gt;</code>, defined as <code>=default</code> for fully comparable classes that only need to perform comparison member by member, or</p>
</li>
<li>
<p>both <code>operator&lt;=&gt;</code> and <code>operator==</code> when the comparison is more complex.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This rule will raise an issue when a class is defined:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>With an <code>operator&lt;=&gt;</code> and any of the four operators <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code> defined with the same argument type.</p>
</li>
<li>
<p>With both <code>operator==</code> and <code>operator!=</code> defined for the same types.</p>
</li>
<li>
<p>With a defaulted <code>operator&lt;=&gt;</code> and a defaulted <code>operator==</code> with the same argument types defined.</p>
</li>
<li>
<p>With two <code>operator&lt;=&gt;</code> or two <code>operator==</code> that are declared with the same argument types in reverse order.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_noncompliant_code_example">Noncompliant code example</h3>
<div class="paragraph">
<p>Example with redundant operations in the same class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">class A {
  int field;
  public:
    auto operator&lt;=&gt;(const A&amp;) const = default;
    bool operator&lt;(const A&amp; other) const { // Noncompliant: this definition is redundant when operator&lt;=&gt; is present
      return field &lt; other.field;
    }
    bool operator==(const A&amp;) const = default; // Noncompliant: unnecessary, this line is added implicitly
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Example with equivalent operations in different order:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">class MyStr {
  friend std::strong_ordering operator&lt;=&gt;(MyStr const &amp;s1, std::string const &amp;s2);
  friend std::strong_ordering operator&lt;=&gt;(std::string const &amp;s1, MyStr const &amp;s2); // Noncompliant, redundant with the previous line
};</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_compliant_solution">Compliant solution</h3>
<div class="paragraph">
<p>The class has been reduced to a minimal set:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">class A {
  int field;
  public:
    auto operator&lt;=&gt;(const A&amp;) const = default; // Compliant: operator== is implicitly generated, and expressions with &lt; can be written
};

// The following code is valid:
void f(A const &amp;a1, A const &amp;a2) {
  bool b1 = a1 == a2; // Uses implicitly generated operator==
  bool b2 = a1 != a2; // Uses implicitly generated operator==, rewritten as: !(a1 == a2)
  bool b3 = a1 &lt; a2; // Rewritten as: (a1 &lt;=&gt; a2) &lt; 0
  bool b4 = a1 &gt;= a2; // Uses implicitly generated operator==
  bool b1 = a1 == a2; // Uses implicitly generated operator==
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Only one order needs to be written</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">class MyStr {
  friend std::strong_ordering operator&lt;=&gt;(MyStr const &amp;s1, std::string const &amp;s2); // Compliant
};

// The following code is valid
void f(MyStr const &amp;s1, std::string const &amp;s2) {
  bool b1 = s1 &lt; s2; // Rewritten as: (s1&lt;=&gt;s2) &lt; 0
  bool b2 = s2 &gt;= s1; // Rewritten as 0 &gt;= (s1&lt;=&gt;s2);
}</code></pre>
</div>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_comments_and_links">Comments And Links</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_is_related_to_s6187">is related to: <a data-rspec-id="S6187" class="rspec-auto-link">S6187</a></h3>

</div>
<div class="sect2">
<h3 id="_is_related_to_s6230">is related to: <a data-rspec-id="S6230" class="rspec-auto-link">S6230</a></h3>

</div>
</div>
</div>