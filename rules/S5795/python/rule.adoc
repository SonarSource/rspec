This rule raises an issue when the identity operator is used with literals.

== Why is this an issue?

Identity operators ``++is++`` and ``++is not++`` check if the same object is on both sides, 
i.e. ``++a is b++`` returns ``++True++`` if ``++id(a) == id(b)++``.

The CPython interpreter caches certain builtin values for integers, bytes, floats, strings, frozensets and tuples. 
For example, the literal `1` will be cached and when using `int("1")` the object return is the integer `1` from the cache. This is why `1 is int("1")` is `True`. 
However this does not work with every values, for example the integer `1000` will not be cached, this means that `int("1000") is 1000` will always be `False` as the two objects have a different id. 
Using the identity operators on integers, bytes, floats, strings, frozensets and tuples could lead to bugs as the behaviour could change depending on the value.

Moreover the caching behavior is not part of the Python language specification and could vary between interpreters. 
CPython 3.8 https://docs.python.org/3.8/whatsnew/3.8.html#changes-in-python-behavior[warns about comparing literals using identity operators].

If you need to compare these types you should use instead equality operators ``++==++`` or ``++!=++``.

This rule raises an issue when at least one operand of an identity operator:

* is of type ``++int++``, ``++bytes++``, ``++float++``, ``++frozenset++`` or ``++tuple++``.
* is a string literal.

=== Exceptions

The only case where the `is` operator could be used with a cached type is with "interned" strings. 
Note however that interned strings don't necessarily have the same identity as string literals.

[source,python]
----
from sys import intern

some_string = "text"
intern("text") is intern(some_text) # This returns True 
----

== How to fix it

Use the equality operator to compare ``++int++``, ``++bytes++``, ``++float++``, ``++frozenset++``, ``++tuple++`` and string literals.

=== Code examples

==== Noncompliant code example

[source,python,diff-id=1,diff-type=noncompliant]
----
int("2000") is 2000 # Noncompliant: as the integer 2000 is not cached, the identity operator will return False.

() is tuple() # Noncompliant: as the empty tuple object is cached this line will return True.
(1,) is tuple([1])  # Noncompliant: comparing non empty tuples will return False as none of these objects are cached. 
----


==== Compliant solution

[source,python,diff-id=1,diff-type=compliant]
----
int("2000") == 2000

() == tuple()
(1,) == tuple([1]) 
----


== Resources

=== Documentation 

* Python Documentation - https://docs.python.org/3.8/whatsnew/3.8.html#changes-in-python-behavior[Changes in Python behaviour].
* Python Documentation - https://docs.python.org/3.7/library/sys.html?highlight=sys.intern#sys.intern[sys.intern]

=== Articles & blog posts

* Adam Johnson's Blog - https://adamj.eu/tech/2020/01/21/why-does-python-3-8-syntaxwarning-for-is-literal/[Why does Python 3.8 log a SyntaxWarning for 'is' with literals?]
* Trey Hunner's Blog - https://treyhunner.com/2019/03/unique-and-sentinel-values-in-python/#Equality_vs_identity[Equality vs identity] 

ifdef::env-github,rspecator-view[]

'''
== Implementation Specification
(visible only on this page)

=== Message

* Replace this "is" operator with "=="; identity operator is not reliable here.
* Replace this "is not" operator with "!="; identity operator is not reliable here.


=== Highlighting

Primary: the "is" or "is not" operator.


endif::env-github,rspecator-view[]
