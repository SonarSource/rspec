<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This rule raises an issue when the identity operator is used with cached literals.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The identity operators <code>is</code> and <code>is not</code> check if the same object is on both sides,
i.e. <code>a is b</code> returns <code>True</code> if <code>id(a) == id(b)</code>.</p>
</div>
<div class="paragraph">
<p>The CPython interpreter caches certain built-in values for integers, bytes, floats, strings, frozensets and tuples. When a value is cached, all its references are pointing to the same object in memory; their ids are identical.</p>
</div>
<div class="paragraph">
<p>The following example illustrates this caching mechanism:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">my_int = 1
other_int = 1

id(my_int) == id(other_int) # True</code></pre>
</div>
</div>
<div class="paragraph">
<p>In both assignments (to <code>my_int</code> and <code>other_int</code>), the assigned value <code>1</code> comes from the interpreter cache, only one integer object <code>1</code> is created in memory.
This means both variables are referencing the same object. For this reason, their ids are identical and <code>my_int is other_int</code> evaluates to <code>True</code>.
This mechanism allows the interpreter for better performance, saving memory space, by not creating new objects every time for commonly accessed values.</p>
</div>
<div class="paragraph">
<p>However this caching mechanism does not apply to every value:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">my_int = 1000

id(my_int) == id(1000) # False
my_int is 1000 # False</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example the integer <code>1000</code> is not cached. Each reference to <code>1000</code> creates an new integer object in memory with a new id.
This means that <code>my_int is 1000</code> is always <code>False</code>, as the two objects have different ids.</p>
</div>
<div class="paragraph">
<p>This is the reason why using the identity operators on integers, bytes, floats, strings, frozensets and tuples is unreliable as the behavior changes depending on the value.</p>
</div>
<div class="paragraph">
<p>Moreover the caching behavior is not part of the Python language specification and could vary between interpreters.
CPython 3.8 <a href="https://docs.python.org/3.8/whatsnew/3.8.html#changes-in-python-behavior">warns about comparing literals using identity operators</a>.</p>
</div>
<div class="paragraph">
<p>This rule raises an issue when at least one operand of an identity operator:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>is of type <code>int</code>, <code>bytes</code>, <code>float</code>, <code>frozenset</code> or <code>tuple</code>.</p>
</li>
<li>
<p>is a string literal.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If you need to compare these types you should use the equality operators instead <code>==</code> or <code>!=</code>.</p>
</div>
<div class="sect2">
<h3 id="_exceptions">Exceptions</h3>
<div class="paragraph">
<p>The only case where the <code>is</code> operator could be used with a cached type is with "interned" strings.
The Python interpreter provides a way to explicitly cache any string literals and benefit from improved performances, such as:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>saved memory space.</p>
</li>
<li>
<p>faster string comparison: as only their memory address need to be compared.</p>
</li>
<li>
<p>faster dictionary lookup: if the dictionary keys are interned, the lookup can be done by comparing memory address as well.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This explicit caching is done through interned strings (i.e. <code>sys.intern("some string")</code>).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">from sys import intern

my_text = "text"
intern("text") is intern(my_text) # True</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note however that interned strings don&#8217;t necessarily have the same identity as string literals.</p>
</div>
<div class="paragraph">
<p>It is also important to note that interned strings may be garbage collected, so in order to benefit from their caching mechanism,
a reference to the interned string should be kept.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_fix_it">How to fix it</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Use the equality operators (<code>==</code> or <code>!=</code>) to compare <code>int</code>, <code>bytes</code>, <code>float</code>, <code>frozenset</code>, <code>tuple</code> and string literals.</p>
</div>
<div class="sect2">
<h3 id="_code_examples">Code examples</h3>
<div class="sect3">
<h4 id="_noncompliant_code_example">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">my_int = 2000
my_int is 2000 # Noncompliant: the integer 2000 may not be cached, the identity operator could return False.

() is tuple() # Noncompliant: this will return True only because the CPython interpreter cached the empty tuple.
(1,) is tuple([1])  # Noncompliant: comparing non empty tuples will return False as none of these objects are cached.</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">my_int = 2000
my_int == 2000

() == tuple()
(1,) == tuple([1])</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_documentation">Documentation</h3>
<div class="ulist">
<ul>
<li>
<p>Python Documentation - <a href="https://docs.python.org/3.8/whatsnew/3.8.html#changes-in-python-behavior">Changes in Python behaviour</a>.</p>
</li>
<li>
<p>Python Documentation - <a href="https://docs.python.org/3/library/sys.html?highlight=sys.intern#sys.intern">sys.intern</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_articles_blog_posts">Articles &amp; blog posts</h3>
<div class="ulist">
<ul>
<li>
<p>Adam Johnson&#8217;s Blog - <a href="https://adamj.eu/tech/2020/01/21/why-does-python-3-8-syntaxwarning-for-is-literal/">Why does Python 3.8 log a SyntaxWarning for 'is' with literals?</a></p>
</li>
<li>
<p>Trey Hunner&#8217;s Blog - <a href="https://treyhunner.com/2019/03/unique-and-sentinel-values-in-python/#Equality_vs_identity">Equality vs identity</a></p>
</li>
</ul>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_implementation_specification">Implementation Specification</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_message">Message</h3>
<div class="ulist">
<ul>
<li>
<p>Replace this "is" operator with "=="; identity operator is not reliable here.</p>
</li>
<li>
<p>Replace this "is not" operator with "!="; identity operator is not reliable here.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_highlighting">Highlighting</h3>
<div class="paragraph">
<p>Primary: the "is" or "is not" operator.</p>
</div>
</div>
</div>
</div>