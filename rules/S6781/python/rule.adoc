include::../../../shared_content/secrets/description.adoc[]

== Why is this an issue?

include::../../../shared_content/secrets/rationale.adoc[]

=== What is the potential impact?

If a JWT secret key leaks to an unintended audience, it can have serious
security implications for the corresponding application. The secret key is used
to encode and decode JWTs when using a symmetric signing algorithm, and an
attacker could potentially use it to perform malicious actions.

For example, an attacker could use the secret key to create their own
authentication tokens that appear to be legitimate, allowing them to bypass
authentication and gain access to sensitive data or functionality.

In the worst-case scenario, an attacker could be able to execute arbitrary code
on the application by abusing administrative features, and take over its hosting
server.

include::../../../shared_content/secrets/fix/revoke.adoc[]

Changing the secret value is sufficient to invalidate any data that it protected.

== How to fix it in Flask

=== Code examples

The following noncompliant code contains a hard-coded secret that can be exposed unintentionnaly. A solution is to set this secret in an environmnt string.

==== Noncompliant code example

[source,python,diff-id=101,diff-type=noncompliant]
----
from flask import Flask

app = Flask(__name__)
app.config['JWT_SECRET_KEY'] = secret_key  # Noncompliant
----

==== Compliant solution

[source,python,diff-id=101,diff-type=compliant]
----
from flask import Flask
import os

app = Flask(__name__)
app.config['JWT_SECRET_KEY'] = os.environ["JWT_SECRET_KEY"]
----

== How to fix it in python-jose

The following noncompliant FastAPI application contains a hard-coded secret that can be exposed unintentionnaly. A solution is to set this secret in an environment variable.

[source,python,diff-id=201,diff-type=noncompliant]
----
from typing import Dict
from fastapi import Depends, FastAPI
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from jose import jwt


oauth2_scheme = OAuth2PasswordBearer(tokenUrl="login")
secret_key = 'secret'


def create_access_token(data: dict):
    to_encode = data.copy()
    to_encode.update({"exp": datetime.now(timezone.utc) +
                      timedelta(minutes=15)})
    return jwt.encode(to_encode, secret_key, algorithm="HS256")  # Noncompliant

def validate_login(username: str, password: str) -> None:
     ...


@app.post("/login")
async def login(
    form_data: OAuth2PasswordRequestForm = Depends()
) -> Dict[str, str]:
    validate_login(form_data.username, form_data.password)
    return dict(access_token=create_access_token(data={"sub": form_data.username}))
----

[source,python,diff-id=201,diff-type=compliant]
----
from typing import Dict
from fastapi import Depends, FastAPI
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from jose import jwt
import os


oauth2_scheme = OAuth2PasswordBearer(tokenUrl="login")
secret_key = os.environ["JWT_SECRET_KEY"]


def create_access_token(data: dict):
    to_encode = data.copy()
    to_encode.update({"exp": datetime.now(timezone.utc) +
                      timedelta(minutes=15)})
    return jwt.encode(to_encode, secret_key, algorithm="HS256")

def validate_login(username: str, password: str) -> None:
     ...


@app.post("/login")
async def login(
    form_data: OAuth2PasswordRequestForm = Depends()
) -> Dict[str, str]:
    validate_login(form_data.username, form_data.password)
    return dict(access_token=create_access_token(data={"sub": form_data.username}))
----

When using an asymmetric encryption algorithm, the keys can be loaded from a file instead of being hardcoded:

[source,python,diff-id=202,diff-type=noncompliant]
----
from typing import Dict
from fastapi import Depends, FastAPI
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from jose import jwt


oauth2_scheme = OAuth2PasswordBearer(tokenUrl="login")

private_key = '''-----BEGIN PRIVATE KEY-----
MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQDAK5Lsx5Ow0N+d
...
-----END PRIVATE KEY-----'''


def create_access_token(data: dict):
    to_encode = data.copy()
    to_encode.update({"exp": datetime.now(timezone.utc) +
                      timedelta(minutes=15)})
    return jwt.encode(to_encode, private_key, algorithm="RS256")  # Noncompliant

def validate_login(username: str, password: str) -> None:
     ...


@app.post("/login")
async def login(
    form_data: OAuth2PasswordRequestForm = Depends()
) -> Dict[str, str]:
    validate_login(form_data.username, form_data.password)
    return dict(access_token=create_access_token(data={"sub": form_data.username}))
----

[source,python,diff-id=202,diff-type=compliant]
----
from typing import Dict
from fastapi import Depends, FastAPI
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from jose import jwt


oauth2_scheme = OAuth2PasswordBearer(tokenUrl="login")

private_key = ''
with open('resources/rs256.pem', 'r') as f:
    private_key = f.read()


def create_access_token(data: dict):
    to_encode = data.copy()
    to_encode.update({"exp": datetime.now(timezone.utc) +
                      timedelta(minutes=15)})
    return jwt.encode(to_encode, private_key, algorithm="RS256")

def validate_login(username: str, password: str) -> None:
     ...


@app.post("/login")
async def login(
    form_data: OAuth2PasswordRequestForm = Depends()
) -> Dict[str, str]:
    validate_login(form_data.username, form_data.password)
    return dict(access_token=create_access_token(data={"sub": form_data.username}))
----

== How to fix it in PyJWT

The following noncompliant FastAPI application contains a hard-coded secret that can be exposed unintentionnaly. A solution is to set this secret in an environmnt string.

[source,python,diff-id=301,diff-type=noncompliant]
----
from typing import Dict
from fastapi import Depends, FastAPI
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
import jwt


oauth2_scheme = OAuth2PasswordBearer(tokenUrl="login")
secret_key = 'secret'


def create_access_token(data: dict):
    to_encode = data.copy()
    to_encode.update({"exp": datetime.now(timezone.utc) +
                      timedelta(minutes=15)})
    return jwt.encode(to_encode, secret_key, algorithm="HS256")  # Noncompliant

def validate_login(username: str, password: str) -> None:
     ...


@app.post("/login")
async def login(
    form_data: OAuth2PasswordRequestForm = Depends()
) -> Dict[str, str]:
    validate_login(form_data.username, form_data.password)
    return dict(access_token=create_access_token(data={"sub": form_data.username}))
----

[source,python,diff-id=301,diff-type=compliant]
----
from typing import Dict
from fastapi import Depends, FastAPI
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
import jwt
import os


oauth2_scheme = OAuth2PasswordBearer(tokenUrl="login")
secret_key = os.environ["JWT_SECRET_KEY"]


def create_access_token(data: dict):
    to_encode = data.copy()
    to_encode.update({"exp": datetime.now(timezone.utc) +
                      timedelta(minutes=15)})
    return jwt.encode(to_encode, secret_key, algorithm="HS256")

def validate_login(username: str, password: str) -> None:
     ...


@app.post("/login")
async def login(
    form_data: OAuth2PasswordRequestForm = Depends()
) -> Dict[str, str]:
    validate_login(form_data.username, form_data.password)
    return dict(access_token=create_access_token(data={"sub": form_data.username}))
----

When using an asymmetric encryption algorithm, the keys can be loaded from a file instead of being hardcoded:

[source,python,diff-id=302,diff-type=noncompliant]
----
from typing import Dict
from fastapi import Depends, FastAPI
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
import jwt


oauth2_scheme = OAuth2PasswordBearer(tokenUrl="login")

private_key = '''-----BEGIN PRIVATE KEY-----
MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQDAK5Lsx5Ow0N+d
...
-----END PRIVATE KEY-----'''


def create_access_token(data: dict):
    to_encode = data.copy()
    to_encode.update({"exp": datetime.now(timezone.utc) +
                      timedelta(minutes=15)})
    return jwt.encode(to_encode, private_key, algorithm="RS256")  # Noncompliant

def validate_login(username: str, password: str) -> None:
     ...


@app.post("/login")
async def login(
    form_data: OAuth2PasswordRequestForm = Depends()
) -> Dict[str, str]:
    validate_login(form_data.username, form_data.password)
    return dict(access_token=create_access_token(data={"sub": form_data.username}))
----

[source,python,diff-id=302,diff-type=compliant]
----
from typing import Dict
from fastapi import Depends, FastAPI
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
import jwt


oauth2_scheme = OAuth2PasswordBearer(tokenUrl="login")

private_key = ''
with open('resources/rs256.pem', 'r') as f:
    private_key = f.read()


def create_access_token(data: dict):
    to_encode = data.copy()
    to_encode.update({"exp": datetime.now(timezone.utc) +
                      timedelta(minutes=15)})
    return jwt.encode(to_encode, private_key, algorithm="RS256")

def validate_login(username: str, password: str) -> None:
     ...


@app.post("/login")
async def login(
    form_data: OAuth2PasswordRequestForm = Depends()
) -> Dict[str, str]:
    validate_login(form_data.username, form_data.password)
    return dict(access_token=create_access_token(data={"sub": form_data.username}))
----

== How to fix it in Django

The following noncompliant Django REST framework application contains a hard-coded secret that can be exposed unintentionnaly. A solution is to set this secret in an environment variable.

[source,python,diff-id=401,diff-type=noncompliant]
----
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'rest_framework',
]

REST_FRAMEWORK = {
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.DjangoModelPermissionsOrAnonReadOnly',
    ],
    'DEFAULT_AUTHENTICATION_CLASSES': (
      'rest_framework_simplejwt.authentication.JWTAuthentication',
    )
}

SIMPLE_JWT = {
  "ALGORITHM": "HS256",
  "SIGNING_KEY": "secret"  # Noncompliant
}
----

[source,python,diff-id=401,diff-type=compliant]
----
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'rest_framework',
]

REST_FRAMEWORK = {
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.DjangoModelPermissionsOrAnonReadOnly',
    ],
    'DEFAULT_AUTHENTICATION_CLASSES': (
      'rest_framework_simplejwt.authentication.JWTAuthentication',
    )
}

SIMPLE_JWT = {
  "ALGORITHM": "HS256",
  "SIGNING_KEY": os.environ["SIGNING_KEY"]
}
----


//=== How does this work?

//=== Pitfalls

=== Going the extra mile

include::../../../shared_content/secrets/fix/vault.adoc[]

== Resources

include::../../../shared_content/secrets/resources/standards.adoc[]

=== Documentation

* Flask JWT documentation - https://flask-jwt-extended.readthedocs.io/en/stable/options.html#jwt-secret-key[Config - JWT_SECRET_KEY]
* Python-Jose documentation - https://python-jose.readthedocs.io/en/latest/jwt/index.html[JSON Web Token]
* PyJWT documentation - https://pyjwt.readthedocs.io/en/stable/api.html[API Reference]
* Simple JWT documentation - https://django-rest-framework-simplejwt.readthedocs.io/en/latest/settings.html#signing-key[SIGNING_KEY]

//=== Benchmarks
