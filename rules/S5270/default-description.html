<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Variadic arguments allow a function to accept any number of arguments (in this rule, we are not talking about variadic templates, but about functions with ellipses). But these arguments have to respect some criteria to be handled properly.</p>
</div>
<div class="paragraph">
<p>The standard imposes some requirements on the class types that can be passed as variadic arguments, and those requirements vary according to the C&#43;&#43; standard version in use:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Before C&#43;&#43;11, the standard only allows POD types to be used as variadic arguments.</p>
</li>
<li>
<p>In C&#43;&#43;11, the rules are relaxed such that any class type with an eligible non-trivial copy constructor, an eligible non-trivial move constructor, or a non-trivial destructor can be used in variadic arguments.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The rule detects any violations of these requirements since they can trigger undefined behavior.</p>
</div>
<div class="paragraph">
<p>Additionally, since using an incorrect type to access the passed parameter within the variadic function can lead to undefined behavior, the rule goes a step further and reports all cases when class types are passed as variadic arguments. The rationale is that, most likely, the user forgot to call a method on the object being passed (<code>std::string_view::data()</code> for example) that would get a member of a built-in type.</p>
</div>
<div class="paragraph">
<p>When in need to pass class types to functions that take a variable number of arguments, consider using modern type-safe alternatives like C&#43;&#43;11 parameter packs instead of variadic functions.</p>
</div>
<div class="sect2">
<h3 id="_noncompliant_code_example">Noncompliant code example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">void my_log(const char* format, ...);

void f() {
  std::string someStr = "foo";
  my_log("%s", someStr);  // Noncompliant; the C++11 standard requires types passed as variadic arguments to have a trivial copy constructor. The user probably meant to pass someStr.c_str() here

  std::string_view someStrView = "bar";
  my_log("%s", someStrView); // Noncompliant; the user probably meant to pass someText.data()
  std::chrono::duration&lt;float&gt; duration;
  my_log("%f", duration); // Noncompliant, the user probably meant to pass duration.count()
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_compliant_solution">Compliant solution</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">void my_log(const char* format, ...);

void f() {
  std::string someStr = "foo";
  my_log("%s", someStr.c_str());  // Compliant

  std::string_view someStrView = "bar";
  my_log("%s", someStrView.data()); // Compliant
  std::chrono::duration&lt;float&gt; duration;
  my_log("%f", duration.count()); // Compliant
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_exceptions">Exceptions</h3>
<div class="paragraph">
<p>The rule doesn&#8217;t report an issue in the following cases:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When the called variadic function doesn&#8217;t have any non-variadic parameters. This is a common pattern when the function is used as a catch-all net for an overload set. This is also guaranteed to be safe since there is no portable to access the passed arguments.</p>
</li>
<li>
<p>When the called variadic function is known to accept a class type object as a variadic argument (e.g., the <code>semctl</code> system call).</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">// This variadic function is used as a catch-all net to terminate recursion
std::size_t elementsCount(...) { return 1u; }

template&lt;typename T&gt;
std::size_t elementsCount(const std::vector&lt;T&gt;&amp; vec) {
  // Sum the elements of all nested vectors recursively
  return std::accumulate(vec.begin(), vec.end(), 0u, [] (const std::size_t count, const T&amp; element) {
    return count + elementsCount(element); // Compliant (the callee doesn't have non-variadic arguments)
  });
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>MISRA C:2004, 16.1 - Functions shall not be defined with a variable number of arguments.</p>
</li>
<li>
<p><a href="https://wiki.sei.cmu.edu/confluence/x/5ns-BQ">CERT, DCL50-CPP.</a> - Do not define a C-style variadic function</p>
</li>
<li>
<p>C++ Core Guidelines - <a href="https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#-es34-dont-define-a-c-style-variadic-function"> ES.34: Don&#8217;t define a (C-style) variadic function</a></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_related_rules">Related rules</h3>
<div class="ulist">
<ul>
<li>
<p><a data-rspec-id="S2275" class="rspec-auto-link">S2275</a> and <a data-rspec-id="S3457" class="rspec-auto-link">S3457</a> are rules that specialize in detecting type mismatches with format strings.</p>
</li>
</ul>
</div>
</div>
</div>
</div>