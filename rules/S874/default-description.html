<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Most built-in bitwise operators (<code>~</code>, <code>&gt;&gt;</code>, <code>&gt;&gt;=</code>, <code>&amp;</code>, <code>&amp;=</code>, <code>^</code>, <code>^=</code>, <code>|</code>, and <code>|=</code>) have implementation-dependent results when performed on signed operands, and bitwise left shift (<code>&lt;&lt;</code> and <code>&lt;&lt;=</code>) has unspecified or undefined behavior when performed on negative operands.</p>
</div>
<div class="paragraph">
<p>Therefore, bitwise operations should not be performed on signed operands.</p>
</div>
<div class="paragraph">
<p>Starting with C&#43;&#43;20, the behaviors have been defined more accurately (negative values have to be represented using two&#8217;s complement), and therefore this rule will only report an issue when the second operand of a shift operator is signed (shifting by a negative value is still undefined behavior).</p>
</div>
<div class="sect2">
<h3 id="_noncompliant_code_example">Noncompliant code example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">if ( ( uint16_a &amp; int16_b ) == 0x1234U ) // Noncompliant until C++20
if ( ~int16_a == 0x1234U ) // Noncompliant until C++20

auto f(int i) {
    return 1 &lt;&lt; i; // Noncompliant
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_compliant_solution">Compliant solution</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">if ( ( uint16_a | uint16_b ) == 0x1234U )
if ( ~uint16_a == 0x1234U )

auto f(unsigned int i) {
    return 1 &lt;&lt; i;
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_exceptions">Exceptions</h3>
<div class="paragraph">
<p>When used as bit flags, it is acceptable to use preprocessor macros as arguments to the &amp; and | operators even if the value is not explicitly declared as unsigned.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">fd = open(file_name, UO_WRONLY | UO_CREAT | UO_EXCL | UO_TRUNC, 0600);</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the right-side operand to a shift operator is known at compile time, it is acceptable for the value to be represented with a signed type provided it is positive.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#define SHIFT 24
foo = 15u &gt;&gt; SHIFT;</code></pre>
</div>
</div>
<div class="paragraph">
<p>When combining several bitwise operations, even if all leaf operands are unsigned, if they are smaller than an <code>int</code>, some intermediate results will be of type <code>signed int</code>, due to integral promotion. However, this situation is usually not an issue, and is an exception for this rule:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">unsigned int f(unsigned short src) {
  return (src &gt;&gt; 3) &amp; 0x1F; // (src &gt;&gt; 3) is of type signed int
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>MISRA C:2004, 12.7 - Bitwise operators shall not be applied to operands whose underlying type is signed</p>
</li>
<li>
<p>MISRA C&#43;&#43;:2008, 5-0-21 - Bitwise operators shall only be applied to operands of unsigned underlying type</p>
</li>
<li>
<p>MISRA C:2012, 10.1 - Operands shall not be of an inappropriate essential type</p>
</li>
<li>
<p><a href="https://wiki.sei.cmu.edu/confluence/x/9tYxBQ">CERT, INT13-C.</a> - Use bitwise operators only on unsigned operands</p>
</li>
<li>
<p>CWE - <a href="https://cwe.mitre.org/data/definitions/682">CWE-682 - Incorrect Calculation</a></p>
</li>
</ul>
</div>
<hr>
</div>
</div>
<div class="sect1">
<h2 id="_implementation_specification">Implementation Specification</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_message">Message</h3>
<div class="paragraph">
<p>Do not apply "X" bitwise operator to a signed operand.</p>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_comments_and_links">Comments And Links</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_relates_to_s5354">relates to: <a data-rspec-id="S5354" class="rspec-auto-link">S5354</a></h3>

</div>
<div class="sect2">
<h3 id="_on_3_nov_2014_122139_evgeny_mandrikov_wrote">on 3 Nov 2014, 12:21:39 Evgeny Mandrikov wrote:</h3>
<div class="paragraph">
<p>Both <a href="https://www.securecoding.cert.org/confluence/x/BoAD">CERT, INT13-C</a> and <a href="https://www.securecoding.cert.org/confluence/x/vIAyAQ">CERT, INT13-CPP</a> describe exclusions for this rule.</p>
</div>
</div>
<div class="sect2">
<h3 id="_on_26_may_2015_135159_freddy_mallet_wrote">on 26 May 2015, 13:51:59 Freddy Mallet wrote:</h3>
<div class="paragraph">
<p>This rule was generating too much noise on Nemo, so :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The severity has been decreased from Blocker to Critical</p>
</li>
<li>
<p>The rule is no more part of the default "Sonar Way" quality profile</p>
</li>
</ul>
</div>
</div>
</div>
</div>