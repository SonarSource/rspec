== Why is this an issue?

The class `std::optional` stores an optional value: a `std::optional<T>` can either contain a value of type `T` or be empty.

One way to access the value of a non-empty optional is the `operator*`, making an optional look like a pointer. However, the similarity ends there: an optional object models an object, not a pointer. Assigning a value to the dereferenced optional or the result of the function `value()` is undefined behavior if the optional has no value. That is why the preferred way to assign a value to an optional is to assign it directly: it will work in any case.

== How to fix it

=== Code examples

==== Noncompliant code example

[source,cpp,diff-id=1,diff-type=noncompliant]
----
void g(std::optional<int> &val, bool b) {
    if (b) {
      *val = 314; // Noncompliant; the behavior is undefined if the optional is empty.
    } else {
      val.value() = 42; // Noncompliant, it will throw if the optional is empty
    }
}
----

==== Compliant solution

[source,cpp,diff-id=1,diff-type=compliant]
----
void g(std::optional<int> &val, bool b) {
    if (b) {
      val = 314; // Compliant
    } else {
      val = 42; // Compliant
    }
}
----

== Resources

* CPP reference - https://en.cppreference.com/w/cpp/utility/optional[std::optional]
