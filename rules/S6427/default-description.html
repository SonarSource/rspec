<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The class <code>std::optional&lt;T&gt;</code> either stores a value of type <code>T</code> or is empty.</p>
</div>
<div class="paragraph">
<p>One way to access the value of a non-empty optional is the <code>operator*</code>. But using the dereference operator gives the optional appearance of a pointer when it is not: it models an object. Additionally, attempting to call the <code>operator*</code> on an empty optional will result in undefined behavior.</p>
</div>
<div class="paragraph">
<p>Another way to access the value of a non-empty optional is the function <code>value()</code>. But assigning a value to the optional object through this function will throw an exception (<code>std::bad_optional_access</code>) if the optional has no value, and the assignment will not happen.</p>
</div>
<div class="paragraph">
<p>For the assignment of an optional to happen correctly, whatever its state, it is better to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>assign the value directly with the <code>operator=</code>: e.g. <code>myOptionalInteger = 3;</code></p>
</li>
<li>
<p>use the <code>emplace</code> function (for example, when the move or copy operation is expensive or forbidden).</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_fix_it">How to fix it</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The rule raises an issue when the <code>operator*</code> or the <code>value()</code> function are used to assign a new value to an optional.</p>
</div>
<div class="sect2">
<h3 id="_code_examples">Code examples</h3>
<div class="sect3">
<h4 id="_noncompliant_code_example">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">void g(std::optional&lt;int&gt; &amp;val, bool b) {
    if (b) {
      *val = 314; // Noncompliant; the behavior is undefined if the optional is empty.
    } else {
      val.value() = 42; // Noncompliant; it will throw if the optional is empty.
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">void g(std::optional&lt;int&gt; &amp;val, bool b) {
    if (b) {
      val = 314; // Compliant
    } else {
      val = 42; // Compliant
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>C&#43;&#43; reference - <a href="https://en.cppreference.com/w/cpp/utility/optional">std::optional</a></p>
</li>
</ul>
</div>
</div>
</div>