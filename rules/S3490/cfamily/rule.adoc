== Why is this an issue?

All special member functions (default constructor, copy and move constructors, copy and move assignment operators, destructor) can be automatically generated by the compiler if you don't prevent it (for many classes, it is good practice to organize your code so that you can use these default versions, see S4963).


There are cases where it's still useful to manually write such a function because the default implementation is not doing what you need. But when the manually written function is equivalent to the default implementation, this is an issue because:

* It's more code to write, test, and maintain for no good reason
* Correctly writing the code of those functions is surprisingly difficult
* Once you write one such function, you will typically have to write several (see S3624)
* If you want your class to be _trivial_ or to be an _aggregate_, those functions cannot be user-provided anyways

In most cases, you should just remove the code of the redundant function. In some cases, the compiler will not automatically generate the default version of the function, but you can force it to do so by using the ``++= default++`` syntax.


For default constructors, you can often use the default version if you use in-class initialization instead of the initializer list. You must make it explicitly defaulted if your class has any other constructor.


For destructors, you may want to use the ``++=default++`` syntax to be able to declare it as virtual (see S1235).


This rule raises an issue when any of the following is implemented in a way equivalent to the default implementation:

* default constructor
* destructor
* move constructor
* move-assignment operator
* copy constructor
* copy-assignment operator


=== Noncompliant code example

[source,cpp]
----
struct Book {
  string Name;

  Book() { } // Noncompliant
  Book(const Book &Other) : Name(Other.Name) { } // Noncompliant
  Book &operator=(const Book &);
};

Book &Book::operator=(const Book &Other) { // Noncompliant
  Name = Other.Name;
  return *this;
}
----


=== Compliant solution

[source,cpp]
----
struct Book {
  string Name;

  Book() = default; // Restores generation of default
  Book(const Book &Other) = default;
  Book &operator=(const Book &) = default;
};

// Or, more common:
struct Book {
  string Name;
};
----


== Resources

* {cpp} Core Guidelines - https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c30-define-a-destructor-if-a-class-needs-an-explicit-action-at-object-destruction[C.30: Define a destructor if a class needs an explicit action at object destruction]
* {cpp} Core Guidelines - https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c48-prefer-in-class-initializers-to-member-initializers-in-constructors-for-constant-initializers[C.48: Prefer in-class initializers to member initializers in constructors for constant initializers]


ifdef::env-github,rspecator-view[]

'''
== Implementation Specification
(visible only on this page)

=== Message

Remove this definition (or in some cases use "=default") instead of explicitly implementing this special member functions.


=== Highlighting

method name


'''
== Comments And Links
(visible only on this page)

=== is related to: S3538

endif::env-github,rspecator-view[]
