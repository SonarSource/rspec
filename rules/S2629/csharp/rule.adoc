== Why is this an issue?

Suppose the current minimum log level setting is higher than at what log level the message is being logged (for example having a minimum log level of warning and trying to log at Info). In that case, the message being logged is not going to be logged.
However, even if the method effectively does nothing, its arguments may still need to be evaluated before the method is called.

Passing concatenated strings or string interpolations into a logging method can incur a needless performance hit because the evaluation will be performed every time the method is called, whether or not the log level is low enough to show the message.

Instead, you should use the overload of the logger to pass the log format and its arguments as separate parameters.

Additionally, having the log format as a constant will allow for better observability and search in log aggregation and monitoring software.

The rule covers the following logging frameworks:

* https://www.nuget.org/packages/Castle.Core[Castle.Core]
* https://www.nuget.org/packages/log4net[log4net]
* https://www.nuget.org/packages/Serilog[Serilog]
* https://www.nuget.org/packages/NLog[Nlog]

[source,csharp,diff-id=1,diff-type=noncompliant]
----
public void Method(ILogger logger, bool parameter)
{
    logger.DebugFormat($"The value of the parameter is: {parameter}.");
}
----

[source,csharp,diff-id=1,diff-type=compliant]
----
public void Method(ILogger logger, bool parameter)
{
    logger.DebugFormat("The value of the parameter is: {Parameter}.", parameter);
}
----

=== Exceptions

No issues will be raised if the interpolated string argument is passed to a parameter whose type is marked with the https://learn.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.interpolatedstringhandlerattribute[InterpolatedStringHandlerArgumentAttribute].

== Resources

=== Documentation

* Microsoft Learn - https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/statements/exception-handling-statements[Exception-handling statements]