When an object of aggregate type (array of aggregate class) is non-zero initialized,
values for each element or field should be provided.

== Why is this an issue?

A syntax for initializing an array in c or {cpp},
allows to provide an initial value for the elements of the array.
When no value is provided for the tailing elements, 
such elements will be zero-initialized for builtin-types (like `int` or pointers),
and _value-initialized_ in case of records of struct.

[source,c]
----
int a1[5] = {1, 2, 3};              // Noncompliant, last two elements are initialized with 0
int a2[4] = {1, 2, 3, 4, 5};        // Compliant
int* a3[3] = {a1, a1 + 1};          // Noncompliant, last pointer is null
int* a4[3] = {a1, a1 + 1, nullptr}; // Compliant
----

Similarly, when an aggregate class or struct is initialized, 
an initial value may be provided for each field. 
All reaming fields are initialized in the same manner as
elements of the array: 

[source,cpp]
----
struct Pod {
  int x;
  int y;
};

Pod p1{1};    // Noncompliant, `y` do not have initial value
Pod p2{1, 0}; // Compliant
----

These rule also applies when arrays and aggregate structs,
are nested:

[source,c]
----
struct PodPair {
  Pod first;
  Pod second;
};

struct ArrayMember {
  int id;
  int vals[4];
};

int c1[2][2] = {{1}, {2}};  // Noncompliant, second element of each nested array does not have an initial value provided
Pod c2[3] = {{1, 2}, {2}};  // Noncompliant, field `y` of `c2[1]` and whole `c2[2]` object does not have initial value provided
PodPair c3 = {{1}};         // Noncompliant, field `y` of `c3.first` and whole `c3.second` object do not have initial value provided,
ArrayMember c4 = {1, 2, 3}; // Noncompliant, last two elements of array `c4.vals` do not have initial value provided
----

This rule raises issues if such non-zero initialization of aggregate (array or class/struct),
does not provide values for all elements or fields.

=== What is the potential impact?

When the initializer omits the value for some of the elements of the array or the field of the aggregate,
the intent of the code is unclear.
It is impossible to determine if the initial value was skipped on purpose, or is the result of the later modification of the code,
that changed the size of the array or added a new field to the aggregate class.
In the latter case, the zero or default value of the element or the field, may not be handled properly,
leading to unexpected program behavior.

As an illustration, if the field or element has a pointer type, it will be initialized with a null-pointer value,
and may lead to null-pointer dereference.

=== What about zero initialization?

When initializing an array with a large number of elements, or a complex structure,
it is often desired to set all elements or fields to zero, or default value (for class with default constructor).  
Such situations are usually indicated by an empty set of braces `{}` for {cpp},
or braces with `{0}` or `{NULL}` in the case of C. 
The issue is not raised in such a situation.

[source,c]
----
int a1[10] = {0}; // Compliant
Pod p1 = {0};     // Compliant
PodPair c1 = {0}; // Compliant
----

This exception also applies when the nested aggregate is zero-initialized:

[source,cpp]
----
int c1[2][2]{{1, 2}, {}};     // Compliant
Pod c2[3] = {{1, 2}, {}, {}}; // Compliant
PodPair c3 = {{}, {1, 0}};    // Compliant
ArrayMember c4{1, {}};        // Compliant
----

=== What if designated initializers are used?

C standard provides a designated initialization syntax, 
that explicitly denotes the field or element of the aggregate for which value is provided.
Even if the design is used, this rule raises an issue, if the initial value for
all elements of fields is not provided.

[source,c]
----
int a1[3] = { [1] = 1, [2] = 2 };          // Noncompliant, first element do not have initial value provided
int a2[3] = { [0] = 0, [1] = 1, [2] = 2 }; // Compliant
Pod p1 = {.y = 10};                        // Noncompliant, `p.x` do not have initial value provided
Pod p2 = {.x = 0, .y = 10};                // Compliant
----

{cpp} have adopted limited version of this feature in {cpp}20 standard,
and the issue is also raised in the case of incomplete initializers.

=== What if the field has a default member initializer?

{cpp}11 allows the data members (fields) of a class to specify a default value
that will be used if no other value is provided during construction.
Such default member initializers cannot be used in aggregate types until {cpp}14,
which guarantees that the default value is used if the initializer list does not provide a value for the field.
The issue is not raised in such a situation, as the initial value of the class was provided by the class author,
and should be handled properly. 

[source,cpp]
----
struct Aggr {
  int a;
  int b;
  int c = 0;
};

Aggr a0{};           // Compliant, zero-initialization
Aggr a1{10};         // Noncompliant, no initial value for field `b`, which does not have a default value
Aggr a2{10, 20};     // Compliant, field `c` has a default value specified in `Aggr` definition
Aggr a3{10, 20, 30}; // Compliant, all fields have initial values
----

With the use of a designated initializer, such default value is meaningful for non-trailing fields:
[source,cpp]
----
struct Mid {
  int a;
  int b = 10;
  int c;
};

Mid m1{.a = 10, .b = 10}; // Noncompliant, no initial for field `c` that does not have a default value
Mid m1{.a = 10, .c = 2};  // Compliant, field `b` has a default value specified in `Mid` definition
----

=== Why is the issue raised when I use parenthesis?

{cpp}20 allows aggregate types to be initialized using the parenthesis (`()`) in addition to the braces (`{}`),
which simplies writting generic code that creates an object (see rule S6872 for more details).
This syntax still allows skipping initial values of a field or an element of aggregate, and the rule also raises issues in such a situation:

[source,c]
----
int a1[5](1, 2, 3);       // Noncompliant, last two elements do not have initial value
int a2[4](1, 2, 3, 4, 5); // Compliant
Pod p1(1);                // Noncompliant, `y` does not have inital value
Pod p2(1, 0);             // Compliant
----

== How to fix it

This issue can be addressed by either:

* providing intial value for the element or field in initializer of in class defintion ({cpp}14 or later)
* using idomatic zero-initialization syntax

=== Code examples

Provide values for all elements of field in intializer.
 
==== Noncompliant code example

[source,cpp,diff-id=1,diff-type=noncompliant]
----
struct Pod {
  int x;
  int y;
};

struct PodPair {
  Pod first;
  Pod second;
};

struct ArrayMember {
  int id;
  int vals[4];
};


int a1[5] = {1, 2, 3};        // Noncompliant
Pod p1{1};                    // Noncompliant
int c1[2][2] = {{1}, {2}};    // Noncompliant
Pod c2[3] = {{1, 2}, {2}};    // Noncompliant
PodPair c3 = {{1}};           // Noncompliant
ArrayMember c4 = {1, {2, 3}}; // Noncompliant
----

==== Compliant solution

[source,c,diff-id=1,diff-type=compliant]
-----
struct Pod {
  int x;
  int y;
};

struct PodPair {
  Pod first;
  Pod second;
};

struct ArrayMember {
  int id;
  int vals[4];
};


int a1[5] = {1, 2, 3, 0, 0};             // Compliant
Pod p1{1, 0};                            // Compliant
int c1[2][2] = {{1, 0}, {2, 0}};         // Compliant
Pod c2[3] = {{1, 2}, {2, 0}, {0, 0}};    // Compliant
PodPair c3 = {{1, 0}, {0, 0}};           // Compliant
ArrayMember c4 = {1, {2, 3, 0, 0, 0}};   // Compliant
----

Or use zero-initialization syntax for `c2` and `c3`:
[source,cpp]
----
Pod c2[3] = {{1, 2}, {2, 0}, {}};  // Compliant
PodPair c3{{1, 0}, {}};            // Compliant
----

=== Code examples

Use idomatic syntax for zero-intialization.

==== Noncompliant code example

[source,c,diff-id=2,diff-type=noncompliant]
----
struct ArrayMember {
  int id;
  int vals[4];
};

int a1[5] = {0, 0, 0};           // Noncompliant
int c1[2][3] = {{0, 0}, {0, 0}}; // Noncompliant
ArrayMember c2 = {11};           // Noncompliant
----

==== Compliant solution

[source,c,diff-id=2,diff-type=compliant]
-----
struct ArrayMember {
  int id;
  int vals[4];
};

int a1[5] = {0};            // Compliant
int c1[2][3] = {0};         // Compliant
ArrayMember c2 = {11, {0}}; // Compliant
----

Or in case of {cpp}:
[source,cpp]
-----
int a1[5]{};               // Compliant
int c1[2][3] = {{}, {}};   // Compliant
ArrayMember c2 = {11, {}}; // Compliant
----

=== Code examples

For {cpp14} or later, provide default value for the field in class.

==== Noncompliant code example

[source,cpp,diff-id=3,diff-type=noncompliant]
----
struct Pod {
  int x;
  int y;
};

struct ArrayMember {
  int id;
  int vals[4];
};

Pod p1{1};           // Noncompliant
ArrayMember m1{11};  // Noncompliant
----

==== Compliant solution

[source,cpp,diff-id=3,diff-type=compliant]
-----
struct Pod {
  int x;
  int y = 2;
};

struct ArrayMember {
  int id;
  int vals[4]{1, 2, 3, 4};
};

Pod p1{1};           // Compliant
ArrayMember m1{11};  // Compliant
----

=== Going the extra mile

When initializing an nested aggregate type (e.g. array of aggregates) an braces around nested object initial values may be omitted.
This feature is referred to as _brace elision_.

[source,c]
----
struct Pod {
  int x;
  int y;
};

int e1[3][2] = {1, 2, 3}; // Noncompliant, `e1[1][2]` and `e1[2]` do not have initial valus 
Pod e2[4] = {1, 2, 3};    // Noncompliant, `e2[1].y`, `e[2]`, and `e[3]` do not have initial value
----

For the purpose of compliance with this rule, supplying initial value to all elements is required:
[source,c]
----
int e1[3][2] = {1, 2, 3, 0, 0, 0};    // Compliant
Pod e2[2] = {1, 2, 3, 0, 0, 0, 0, 0}; // Compliant
----

However, for the sake of readability it is recommended to use a nested brace to indicate a structure (see S835 rule):
[source,c]
----
int e1[3][2] = {{1, 2}, {3, 0}, {0, 0}};      // Compliant
Pod e2[2] = {{1, 2}, {3, 0}, {0, 0}, {0, 0}}; // Compliant
----

Or using zero initialization, when appropariate:
[source,cpp]
----
int e1[3][2] = {{1, 2}, {3, 0}, {}};  // Compliant
Pod e2[2] = {{1, 2}, {3, 0}, {}, {}}; // Compliant
----



== Resources

=== Documentation

 * {cpp} reference -- https://en.cppreference.com/w/cpp/language/aggregate_initialization[Aggregate initialization]
 * {cpp} reference -- https://en.cppreference.com/w/cpp/language/value_initialization[Value-initialization]

=== External coding guidelines

* MISRA C:2012, 9.3 - Arrays shall not be partially initialized.


=== Related rules

 * S835 - Braces should be used to indicate and match the structure in the non-zero initialization of arrays and structures
 * S6872 - Aggregates should be initialized with braces in non-generic code

