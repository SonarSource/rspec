<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Since C&#43;&#43;17, it is possible to add an initialization to an <code>if</code> or a <code>switch</code>, and this possibility has been extended to range-based <code>for</code> loops in C&#43;&#43;20.</p>
</div>
<div class="paragraph">
<p>The intended use case of this feature is to declare and initialize variables that can be used in the condition or the range but whose scope does not extend beyond the body of the control-flow statement.</p>
</div>
<div class="paragraph">
<p>For instance, in this compliant code, the intent is to lock the mutex associated with the object <code>obj</code> while manipulating this object and unlock it immediately after. A lock object is, therefore, declared in the initialization of the condition.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">if (std::scoped_lock lock(obj.getMutex()); obj.isVisible()) {
  obj.draw();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>However, the language&#8217;s syntax also allows simple expressions to be written in this place as well as using declarations since C&#43;&#43;23.
This leads to code that is more complex to read for no real benefits. In some cases, it can hide nasty bugs. Let&#8217;s revisit the previous example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">if (std::scoped_lock (obj.getMutex()); obj.isVisible()) {
  obj.draw();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This very similar-looking code does not declare a variable in the initialization part of the <code>if</code>. Instead, it creates a temporary lock object that is then immediately discarded. The mutex is unlocked before <code>isVisible</code> or <code>draw</code> are called.</p>
</div>
<div class="paragraph">
<p>Note: A classical <code>for</code> loop presents the same flexibility for its initialization part (the first part of the loop). However, since the initialization part is not optional, it is common practice to use it for simple expressions and not only variable declarations. So, this rule does not apply to classical <code>for</code> loops.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_fix_it">How to fix it</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_code_examples">Code examples</h3>
<div class="paragraph">
<p>In many cases, a statement that does not declare a variable can be moved to the previous line.</p>
</div>
<div class="sect3">
<h4 id="_noncompliant_code_example">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">char const* message(Items items) {
  int i;
  switch (items.computeCount(i); i) {
    case 0: return "empty";
    case 1: return "unique";
    default: return "several";
  }
  for (using Val = Items::value_type; Val v : items) {
    display(v);
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">char const* message2(Items items) {
  int i;
  items.computeCount(i);
  switch (i) {
    case 0: return "empty";
    case 1: return "unique";
    default: return "several";
  }
  using Val = Items::value_type;
  for (Val v : items) {
    display(v);
  }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>