<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Catch blocks define how to deal with exceptions. It is possible to partially handle an exception before passing it on to a higher level for complete handling with the empty throw statement <code>throw;</code>.</p>
</div>
<div class="paragraph">
<p>However, when an empty throw is called outside of a catch clause, and there is no exception object to re-throw, the program will call <code>std::terminate</code>. This will cause the program to end, which is unlikely to be the expected behavior.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_fix_it">How to fix it</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The rule raises an issue when an empty throw expression is used outside of a catch clause.</p>
</div>
<div class="sect2">
<h3 id="_code_examples">Code examples</h3>
<div class="sect3">
<h4 id="_noncompliant_code_example">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">void f(int i) {
  if (i &lt;= 0) {
    throw;   // Noncompliant: it will call std::terminate() if f1 is called while no exception is active
  }
}

void g(int i) {
  try {
    f(i);
    throw; // Noncompliant
  } catch (...) {
    doSomething();
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">void f(int i) {
  try {
    if (i &lt;= 0) {
      throw std::out_of_range("Invalid negative index.");
    }
  } catch (const std::out_of_range&amp; e) { // The catch block handles partially the exception
    std::cout &lt;&lt; e.what() &lt;&lt; '\n';
    if (i &lt; 0) {
      throw; // And passes control to the next exception handler
    }
  }
}

void g(int i) noexcept {
  try {
    f(i);
  } catch (...) {
    // The catch block handles the re-throw from f
    doSomething();
  }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_documentation">Documentation</h3>
<div class="ulist">
<ul>
<li>
<p>C&#43;&#43; reference - <a href="https://en.cppreference.com/w/cpp/language/throw"><code>throw</code> expression</a></p>
</li>
<li>
<p>C&#43;&#43; reference - <a href="https://en.cppreference.com/w/cpp/error/terminate"><code>std::terminate</code></a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_external_coding_guidelines">External coding guidelines</h3>
<div class="ulist">
<ul>
<li>
<p>MISRA C&#43;&#43;:2008, 15-1-3 - An empty throw (<code>throw;</code>) shall only be used in the compound-statement of a catch handler.</p>
</li>
</ul>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_comments_and_links">Comments And Links</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_relates_to_s5747">relates to: <a data-rspec-id="S5747" class="rspec-auto-link">S5747</a></h3>

</div>
<div class="sect2">
<h3 id="_on_31_mar_2015_190435_evgeny_mandrikov_wrote">on 31 Mar 2015, 19:04:35 Evgeny Mandrikov wrote:</h3>
<div class="paragraph">
<p>\[~ann.campbell.2] implementation seems more complete (SQALE, description) than this spec.</p>
</div>
</div>
<div class="sect2">
<h3 id="_on_13_apr_2015_193722_evgeny_mandrikov_wrote">on 13 Apr 2015, 19:37:22 Evgeny Mandrikov wrote:</h3>
<div class="paragraph">
<p>\[~ann.campbell.2] I&#8217;m wondering why blocker, but not active by default? Note that in implementation currently active.</p>
</div>
</div>
</div>
</div>