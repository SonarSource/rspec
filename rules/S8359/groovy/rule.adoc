This rule raises an issue when a class defines multiple methods with the same name that accept closures and have parameter types that could cause ambiguous method resolution in Groovy.

== Why is this an issue?

Groovy's dynamic method resolution system can struggle with overloaded methods that have similar parameter types, especially when closures are involved. This can lead to unexpected method calls and runtime `ClassCastException` errors.

When you define methods like `each(List list, Closure closure)` and `each(Iterator iter, Closure closure)`, Groovy's method dispatcher might incorrectly choose one over the other. Since `List` implements `Iterable` (which extends from similar collection interfaces as `Iterator`), the type system can become confused about which method to call.

This problem is particularly troublesome because:

* The error only appears at runtime, not during compilation
* The wrong method might be called silently, leading to unexpected behavior
* Debugging these issues can be very difficult since the method resolution happens dynamically
* The error messages often don't clearly indicate the root cause

The issue becomes more complex when dealing with Groovy's metaclass system and method caching, where the order of method calls and the state of the runtime can affect which method gets resolved.

=== What is the potential impact?

This can cause `ClassCastException` at runtime when the wrong overloaded method is called. The application may fail unexpectedly, and debugging can be difficult since the method resolution happens dynamically. In some cases, the wrong method might be called silently, leading to incorrect behavior that's hard to detect.

== How to fix it

Use distinct method names instead of overloading methods with similar parameter types. This eliminates ambiguity in method resolution and makes the code more explicit about which operation is being performed.

=== Code examples

==== Noncompliant code example

[source,groovy,diff-id=1,diff-type=noncompliant]
----
class MyClass {
    def each(List list, Closure closure) { // Noncompliant
        list.each(closure)
    }
    
    def each(Iterator iter, Closure closure) { // Noncompliant
        while (iter.hasNext()) {
            closure(iter.next())
        }
    }
}
----

==== Compliant solution

[source,groovy,diff-id=1,diff-type=compliant]
----
class MyClass {
    def eachList(List list, Closure closure) {
        list.each(closure)
    }
    
    def eachIterator(Iterator iter, Closure closure) {
        while (iter.hasNext()) {
            closure(iter.next())
        }
    }
}
----

== Resources

=== Documentation

 * Groovy Method Selection - https://groovy-lang.org/objectorientation.html#_method_selection_algorithm[Official documentation on how Groovy selects methods during runtime dispatch]

 * Groovy Closures - https://groovy-lang.org/closures.html[Comprehensive guide to closures in Groovy]
