<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This is an issue when a FastAPI path operation function (typically for POST, PUT, PATCH, or DELETE requests) declares a request body parameter that is not typed with a Pydantic <code>BaseModel</code> class. This includes parameters that are untyped, typed as <code>dict</code>, or typed as plain Python classes that don&#8217;t inherit from <code>BaseModel</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>FastAPI relies on Pydantic models to handle request body parsing, validation, and serialization. When you declare a function parameter with a Pydantic <code>BaseModel</code> type, FastAPI automatically:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Reads the request body as JSON</p>
</li>
<li>
<p>Validates the data against the model&#8217;s field definitions</p>
</li>
<li>
<p>Converts the data to the appropriate Python types</p>
</li>
<li>
<p>Generates OpenAPI documentation describing the expected request body structure</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Without a Pydantic model, FastAPI cannot determine how to parse the request body. The framework uses type hints to distinguish between different parameter types:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Path parameters are declared in the URL path template</p>
</li>
<li>
<p>Query parameters use singular types like <code>int</code>, <code>str</code>, <code>bool</code></p>
</li>
<li>
<p>Request body parameters must use Pydantic <code>BaseModel</code> classes</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When you use an untyped parameter, a <code>dict</code> type, or a plain class, FastAPI doesn&#8217;t recognize it as a request body parameter. This causes the framework to either:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Treat it as a query parameter (for singular types)</p>
</li>
<li>
<p>Fail to parse the request body at all (for untyped or <code>dict</code> parameters)</p>
</li>
<li>
<p>Return a 422 Unprocessable Entity error to the client</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Additionally, without Pydantic models, you lose:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Automatic validation</strong>: No checking of required fields, data types, or custom validators</p>
</li>
<li>
<p><strong>Type conversion</strong>: Raw JSON values aren&#8217;t converted to appropriate Python types</p>
</li>
<li>
<p><strong>Documentation</strong>: The OpenAPI schema doesn&#8217;t include request body structure</p>
</li>
<li>
<p><strong>Editor support</strong>: No autocomplete or type checking for request body fields</p>
</li>
<li>
<p><strong>Data integrity</strong>: Invalid data can reach your business logic, causing runtime errors</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_what_is_the_potential_impact">What is the potential impact?</h3>
<div class="paragraph">
<p>Without proper Pydantic models for request bodies, your API will experience:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Runtime failures</strong>: Requests will fail with 422 errors, breaking client applications</p>
</li>
<li>
<p><strong>Security vulnerabilities</strong>: Missing validation allows malformed or malicious data to reach your application logic</p>
</li>
<li>
<p><strong>Poor developer experience</strong>: API consumers cannot understand the expected request format from documentation</p>
</li>
<li>
<p><strong>Maintenance burden</strong>: Manual validation code is error-prone and harder to maintain than declarative Pydantic models</p>
</li>
<li>
<p><strong>Type safety issues</strong>: Your code loses the benefits of Python&#8217;s type system, making bugs more likely</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_fix_it">How to fix it</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Define a Pydantic <code>BaseModel</code> class that describes the structure of your request body. Add type annotations for each field, and use this model as the type hint for your request body parameter. This enables FastAPI&#8217;s automatic validation, parsing, and documentation generation.</p>
</div>
<div class="sect2">
<h3 id="_code_examples">Code examples</h3>
<div class="sect3">
<h4 id="_noncompliant_code_example">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">from fastapi import FastAPI

app = FastAPI()

class Item:
    def __init__(self, name, price):
        self.name = name
        self.price = price

@app.put("/items/{item_id}")
def update_item(item_id: int, item: Item):  # Noncompliant
    return {"item_name": item.name}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class Item(BaseModel):
    name: str
    price: float
    is_offer: bool = None

@app.put("/items/{item_id}")
def update_item(item_id: int, item: Item):
    return {"item_name": item.name}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_documentation">Documentation</h3>
<div class="ulist">
<ul>
<li>
<p>FastAPI Request Body Documentation - <a href="https://fastapi.tiangolo.com/tutorial/body/">Official FastAPI documentation on declaring request bodies using Pydantic models</a></p>
</li>
<li>
<p>Pydantic BaseModel Documentation - <a href="https://docs.pydantic.dev/latest/concepts/models/">Pydantic documentation explaining how to create and use BaseModel classes</a></p>
</li>
<li>
<p>FastAPI Body - Multiple Parameters - <a href="https://fastapi.tiangolo.com/tutorial/body-multiple-params/">Guide on using multiple body parameters and mixing them with path and query parameters</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>