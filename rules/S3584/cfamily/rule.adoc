Memory allocated dynamically with `calloc(...)`, `malloc(...)`, `realloc(...)`, or `new` should be released when it is not needed anymore.
Failure to do so will result in a memory leak that could bring the box to its knees.

== Why is this an issue?

Memory is a limited resource shared between all the applications running on the same host machine.

C, Objective-C, and {cpp} do not manage memory.
The developer has to keep track of the memory they use in the application.
Unlike the stack that automatically allocates local variables on a function call
and deallocates them on a function return, the heap offers no automatic memory management.
The developer has to make sure to deallocate the memory they allocate dynamically on the heap.

This rule raises an issue when memory is allocated dynamically and not freed within the same function.
This rule ignores allocated memory if a pointer to it is `+return+`ed to the caller or stored in a structure that is external to the function.

=== What is the potential impact?

TODO: find a better word instead of "forgetting". "ignoring" "defecting"

Forgetting to free the memory leads to a memory leak.

The application that leaks memory will consume more and more of it over time,
eventually claiming all the memory available on the host machine.
When this happens and the system runs out of memory, it typically does one of the following:

- The operating system terminates the application.
- The operating system terminates some other application,
  and the problem reoccurs when the reclaimed memory gets used up by the leaking application.
- The operating system starts offloading some of the memory pages to disk and slows down some memory accesses 100 fold.
- The entire system crashes as a whole and reboots automatically or hangs waiting for a manual reboot.

impact on the power use?

Users of the application notice this and get frustrated.

== How to fix it?

=== Code examples

==== Noncompliant code example

[source,cpp,diff-id=1,diff-type=noncompliant]
----
int fun() {
  char* name = (char *) malloc (size);
  if (!name) {
    return 1;
  }
  // ...
  return 0; // Noncompliant: memory pointed to by "name" has not been released
}
----


==== Compliant solution

[source,cpp,diff-id=1,diff-type=noncompliant]
----
int fun() {
  char* name = (char *) malloc (size);
  if (!name) {
    return 1;
  }
  // ...
  free(name); // Compliant
  return 0;
}
----


== Resources

=== Documentation

* Wikipedia - https://en.wikipedia.org/wiki/Memory_leak[Memory leak]

=== Standards

* MITRE - https://cwe.mitre.org/data/definitions/401[CWE-401 Improper Release of Memory Before Removing Last Reference ('Memory Leak')]
* CERT - https://wiki.sei.cmu.edu/confluence/x/FtYxBQ[MEM00-C. Allocate and free memory in the same module, at the same level of abstraction]
* CERT - https://wiki.sei.cmu.edu/confluence/x/GNYxBQ[MEM31-C. Free dynamically allocated memory when no longer needed]



ifdef::env-github,rspecator-view[]

'''
== Implementation Specification
(visible only on this page)

=== Message

Review the data-flow; this memory allocation might not have been released when reaching exit point at line ``++line++``.


=== Highlighting

* Primary: the allocation call - [m|c|re]alloc|new
* Additional: statement exiting the function
** Message: Exit point


'''
== Comments And Links
(visible only on this page)

=== on 30 Mar 2016, 17:03:39 Ann Campbell wrote:
\[~massimo.paladin] I've expanded the description, and added an "issue raised when" section. It describes what seems like a reasonable scope for the rule, but may not match the scope you had in mind. 


Also, I've greatly expanded the references section based on the standards' titles.

endif::env-github,rspecator-view[]
