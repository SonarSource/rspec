== Why is this an issue?

With `std::format`, you can control many aspects of the textual representation of a value.
Its width and precision can be specified in two ways:

* Statically: the desired values are directly embedded in the format specification. +
+
In the following example, the padding character is `_`, the alignment is to the right (`>`), the width specifier is `10`, and the precision specifier is `.2` with a fixed decimal notation (`f`).
The formatted floating-point value (3.14159) is displayed with two digits after the decimal point and padded with underscores to a minimum width of 10 characters.
The resulting string is `+"______3.14"+`.
+
[source,cpp]
----
std::format("{:_>10.2f}", 3.14159)
----

* Dynamically: `{}` or `{arg-id}` is used to refer to a complementary function argument. +
+
The next example results in the same value as in the previous example.
+
[source,cpp]
----
std::format("{0:_>{1}.{2}f}", 3.14159, 10, 2)
----

On the one hand, using static values is safe and predictable but not very flexible.
On the other hand, using dynamic values can result in runtime exceptions and unexpected program termination.

Specifically, a `std::format_error` exception is thrown when a dynamic value for the width or the precision specifiers is either negative or not a built-in integer.

This rule focuses on the latter problem: it raises an issue when the specifier used for the width or the precision is not an integer.

[source,cpp]
----
void example(std::string_view s, double d, int maxLen) {
  // Noncompliant: the width specifier is a floating point value.
  std::format("{0:*^{1}}", s, 5.0);
  // Compliant: the integer 5 is used instead.
  std::format("{0:*^{1}}", s, 5);

  // Noncompliant: the precision specifier is a string literal.
  std::format("{0:*^10.{1}}", d, "3");
  // Compliant: the value 3 is inlined.
  std::format("{0:*^10.3}", d);

  // Noncompliant: the width and precision specifiers are not integers.
  std::format("{0:*^{1}.{2}}", d, "12", 4.0);
  // Compliant: appropriate integer values are used.
  std::format("{0:*^{1}.{2}}", d, 12, 4);

  // Noncompliant: "d" is interpreted as the width specifier.
  std::format("{:*^{}.{}} {}", s, d, maxLen, maxLen + 2);
  // Compliant: use explicit argument index.
  std::format("{0:*^{2}.{3}} {1}", s, d, maxLen, maxLen + 2);
}
----

== Resources

=== Documentation

* {cpp} reference -
  https://en.cppreference.com/w/cpp/utility/format/format[`std::format`] and
  https://en.cppreference.com/w/cpp/utility/format/formatter#Standard_format_specification[standard format specification]
