== Why is this an issue?

`std::format` and the related formatting functions provide the possibility to specify the desired length and padding of the textual representation of the argument through the width and precision options.
The value of each of these options can be specified:

* statically, by placing the desired value in a format specification,
* or dynamically, by using `{}` or `{arg-id}` to refer to a complementary function argument.

A `std::format_error` exception is thrown when a dynamic value for the width or the precision specifiers is either not a built-in integer or negative.

This rule focuses on the first problem: it raises an issue when the specifier used for the width or the precision is not an integer.

=== Noncompliant code example

[source,cpp]
----
std::format("{0:*^{1}}", s, 5.0); // Noncompliant: the width specifier is not an integer.
std::format("{0:*^10.{1}}", d, "3"); // Noncompliant: the precision specifier is not an integer.
std::format("{0:*^{1}.{2}}", d, "12", 4.0); // Noncompliant: neither the width nor the precision specifiers are integers.
std::format("{:*^{}.{}} {}", s, d, maxLen, maxLen + 2); // Noncompliant: the second argument (d) is interpreted as the width specifier.
----

=== Compliant solution

[source,cpp]
----
std::format("{0:*^{1}}", s, 5);
std::format("{0:*^10.3}", d);
std::format("{0:*^{1}.{2}}", d, 12, 4);
std::format("{0:*^17.5}", s, "17", 5.0);
std::format("{0:*^{2}.{3}} {1}", s, d, maxLen, maxLen + 2);
----

