== Why is this an issue?

`std::format` and the related formatting functions provide the possibility to specify the desired length and padding of the textual representation of the argument through the width and precision options.
The value of each of these options can be specified:

* statically, by placing the desired value in a format specification,
* or dynamically, by using `{}` or `{arg-id}` to refer to a complementary function argument.

A `std::format_error` exception is thrown when a dynamic value for the width or the precision specifiers is either not a built-in integer or negative.

This rule focuses on the first problem: it raises an issue when the specifier used for the width or the precision is not an integer.

[source,cpp]
----
void example(std::string_view s, double d, int maxLen) {
  // Noncompliant: the width specifier is a floating point value.
  std::format("{0:*^{1}}", s, 5.0);
  // Compliant: the integer 5 is used instead.
  std::format("{0:*^{1}}", s, 5);

  // Noncompliant: the precision specifier is a string literal.
  std::format("{0:*^10.{1}}", d, "3");
  // Compliant: the value 3 is inlined.
  std::format("{0:*^10.3}", d);

  // Noncompliant: the width and precision specifiers are not integers.
  std::format("{0:*^{1}.{2}}", d, "12", 4.0);
  // Compliant: appropriate integer values are used.
  std::format("{0:*^{1}.{2}}", d, 12, 4);

  // Noncompliant: "d" is interpreted as the width specifier.
  std::format("{:*^{}.{}} {}", s, d, maxLen, maxLen + 2);
  // Compliant: use explicit argument index.
  std::format("{0:*^{2}.{3}} {1}", s, d, maxLen, maxLen + 2);
}
----
