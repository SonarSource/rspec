This rule raises an issue when the `private` keyword is used before public method definitions in a Ruby class, or when private methods are scattered throughout the class instead of being grouped at the end.

== Why is this an issue?

In Ruby, the `private` keyword affects all methods defined after it within the same class. This behavior is different from many other programming languages where visibility is declared per method.

When `private` is placed in the middle of a class definition, any methods defined after it become private, even if they were intended to be public. This can lead to several problems:

* *Runtime errors*: In Rails applications, controller actions that accidentally become private will not be accessible via HTTP routes, causing `AbstractController::ActionNotFound` errors.
* *Broken public APIs*: Methods that should be part of the class's public interface become inaccessible to other parts of the application.
* *Debugging difficulties*: The error messages may not clearly indicate that the issue is related to method visibility.

The Ruby community convention is to place all private methods at the bottom of the class definition under a single `private` declaration. This creates a clear separation between the public interface (what the class exposes to other code) and the implementation details (private helper methods).

=== What is the potential impact?

When public methods are accidentally made private, it can cause runtime failures in production applications. In Rails controllers, this typically results in routing errors where users receive 404 or 500 errors when trying to access pages. The impact can be severe if critical functionality becomes inaccessible, and debugging can be time-consuming since the error may not clearly indicate the root cause is method visibility.

== How to fix it

Move all private methods to the end of the class and group them under a single `private` declaration. This ensures that all public methods remain accessible and creates a clear separation between the public interface and implementation details.

=== Code examples

==== Noncompliant code example

[source,ruby,diff-id=1,diff-type=noncompliant]
----
class PostsController < ApplicationController
  def index
    @posts = Post.all
  end

  def create
    @post = Post.new(post_params)
    @post.save
    redirect_to @post
  end

  private # Noncompliant

  def post_params
    params.require(:post).permit(:title, :text)
  end

  # These methods are now accidentally private
  def show
    @post = Post.find(params[:id])
  end
end
----

==== Compliant solution

[source,ruby,diff-id=1,diff-type=compliant]
----
class PostsController < ApplicationController
  # Public methods first
  def index
    @posts = Post.all
  end

  def show
    @post = Post.find(params[:id])
  end

  def create
    @post = Post.new(post_params)
    @post.save
    redirect_to @post
  end

  # Private methods at the end
  private

  def post_params
    params.require(:post).permit(:title, :text)
  end
end
----

== Resources

=== Documentation

 * Ruby Documentation - Method Visibility - https://ruby-doc.org/core/doc/syntax/methods_rdoc.html#label-Method+Visibility[Official Ruby documentation explaining how private, protected, and public method visibility works]

 * Ruby Style Guide - Method Visibility - https://rubystyle.guide/#consistent-classes[Community style guide recommendations for organizing class methods and visibility]

=== Standards

 * Ruby Style Guide - Class Organization - https://rubystyle.guide/#consistent-classes[Established conventions for organizing Ruby class definitions]
