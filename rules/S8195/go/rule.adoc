This is an issue when creating new errors with `fmt.Errorf` or similar functions without using the `%w` verb to wrap the original error, causing loss of error context.

== Why is this an issue?

When handling errors in Go, it's important to preserve the original error context to maintain the error chain. Creating entirely new errors without wrapping the original error breaks this chain and loses valuable debugging information.

Error wrapping, introduced in Go 1.13, allows you to add context to an error while preserving the original error. This enables:

* Better debugging by maintaining the full error chain
* Proper error inspection using `errors.Is()` and `errors.As()`
* Traceability of the root cause through multiple layers of error handling

When you create a new error without wrapping, you lose the ability to inspect the original error type and its properties. This makes it harder to implement proper error handling strategies and can hide important details about what actually went wrong.

=== What is the potential impact?

Loss of error context makes debugging significantly more difficult. Applications cannot properly inspect or handle specific error types, breaking error handling patterns that rely on `errors.Is()` and `errors.As()`. This can lead to generic error responses instead of specific handling for different error conditions, reducing the application's ability to recover gracefully from errors.

== How to fix it

Use the `%w` verb in `fmt.Errorf` to wrap the original error, preserving the error chain while adding context.

=== Code examples

==== Noncompliant code example

[source,go,diff-id=1,diff-type=noncompliant]
----
func processFile(filename string) error {
    file, err := os.Open(filename)
    if err != nil {
        return fmt.Errorf("failed to process file") // Noncompliant
    }
    defer file.Close()
    return nil
}
----

==== Compliant solution

[source,go,diff-id=1,diff-type=compliant]
----
func processFile(filename string) error {
    file, err := os.Open(filename)
    if err != nil {
        return fmt.Errorf("failed to process file %s: %w", filename, err)
    }
    defer file.Close()
    return nil
}
----

== Resources

=== Documentation

 * Working with Errors in Go 1.13 - https://go.dev/blog/go1.13-errors[Official Go blog post explaining error wrapping and the new error handling features in Go 1.13]

 * Go by Example: Errors - https://gobyexample.com/errors[Practical examples of error handling patterns in Go]

 * Effective Go - Errors - https://go.dev/doc/effective_go#errors[Official Go documentation on effective error handling practices]

=== Standards

 * Go 1.13 Error Wrapping - https://golang.org/doc/go1.13#error_wrapping[Official specification for error wrapping introduced in Go 1.13]
