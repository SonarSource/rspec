Except for templated code, brace initialization should be preferred over {cpp}20's parenthesis initialization for aggregates.

== Why is this an issue?

With {cpp}20, it is now possible to initialize aggregate types using parentheses.
This language feature was introduced to simplify writing generic code and consistently initialize objects, whether they are aggregates or not.

For the sake of simplicity, aggregate types include arrays, unions, and structures without user-declared constructors and with only public non-static data members and public bases.

Initializing objects with parentheses have several downsides compared to braces.

 * Firstly, they allow narrowing conversion of arithmetic types that can result in unexpected program behaviors. See also S5276.

 * Secondly, they can result in the most vexing parse.
   For example, ``++Aggregate a(std::string());++`` declares function, while ``++Aggregate a{std::string()};++`` declares a variable.

 * Furthermore, using braces is idiomatic and consistent with C.

For all these reasons, braces should be preferred for non-generic code when initializing aggregates.
And the fix is often trivial: replace the parentheses `()` with braces `{}`.

Here is a noncompliant example:

[source,cpp,diff-id=1,diff-type=noncompliant]
----
struct Coordinate {
  int x;
  int y;
};

long readInteger();

auto readCoordinate() {
  // Be aware of the narrowing conversions on the next line.
  return Coordinate(readInteger(), readInteger()); // Noncompliant
}
----

There are multiple ways of handling the narrowing conversion; here is one alternative:

[source,cpp,diff-id=1,diff-type=compliant]
----
struct Coordinate {
  int x;
  int y;
};

long readInteger();

auto readCoordinate() {
  // Explicitly handle the conversion:
  // Here, we saturate, but throwing an exception may also be appropriate.
  auto readInt = []() { return saturate_cast<int>(readInteger()); }
  return Coordinate{readInt(), readInt()}; // Compliant
}
----

=== Exceptions

_Value-initialization_ with `()` (i.e., with no arguments) is unrelated to _aggregate-initialization_ and is accepted.
None of the drawbacks listed above apply in such situations.

// There are also edge cases not worth covering or even mentioning here.
//
// Example: having a member with an explicit default constructor does not compile.
// https://godbolt.org/z/exerMGM9x

[source,cpp]
----
Coordinate function(); // Irrelevant -- this is a function declaration.

auto variable = Coordinate(); // Value-initialization - compliant by exception.

struct Object {
  Coordinate coord;
  Object() : coord() { } // Value-initialization - compliant by exception.
};
----

== Resources

=== Documentation

 * {cpp} reference -- https://en.cppreference.com/w/cpp/language/aggregate_initialization#Definitions[Aggregate definition]
 * {cpp} reference -- https://en.cppreference.com/w/cpp/language/value_initialization[Value-initialization]
 * Wikipedia -- https://en.wikipedia.org/wiki/Most_vexing_parse[Most vexing parse]

=== Standards

 * Open Standards - https://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4462.html[N4462] presents the problem with initializing objects in generic code using braces, and https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0960r2.html[P0960] solves it by introducing parenthesized initialization.

=== Related rules

 * S835 - Braces should be used to indicate and match the structure in the non-zero initialization of arrays and structures
// TODO CPP-4792 - Update S835's title and list S6871.
 * S5276 - Implicit casts should not lower precision
