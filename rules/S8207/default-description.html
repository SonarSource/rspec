<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This rule raises an issue when shared variables are accessed by multiple goroutines without proper synchronization mechanisms like mutexes, channels, or atomic operations.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Go&#8217;s concurrency model allows multiple goroutines to run simultaneously, sharing the same memory space. When multiple goroutines access the same variable concurrently, and at least one of them performs a write operation, a race condition occurs.</p>
</div>
<div class="paragraph">
<p>Race conditions are problematic for several reasons:</p>
</div>
<div class="paragraph">
<p><strong>Data corruption</strong>: Without synchronization, concurrent reads and writes can interfere with each other, leading to inconsistent or corrupted data. For example, if two goroutines increment the same counter simultaneously, the final value might be incorrect because both goroutines might read the same initial value before either writes back the incremented result.</p>
</div>
<div class="paragraph">
<p><strong>Unpredictable behavior</strong>: Race conditions make programs non-deterministic. The same code might produce different results on different runs, making bugs extremely difficult to reproduce and debug.</p>
</div>
<div class="paragraph">
<p><strong>Memory visibility issues</strong>: Modern processors and compilers can reorder operations for optimization. Without proper synchronization, changes made by one goroutine might not be immediately visible to other goroutines, leading to stale data being used.</p>
</div>
<div class="paragraph">
<p><strong>Performance degradation</strong>: When multiple goroutines write to the same memory location simultaneously, it can cause cache line contention and false sharing, significantly impacting performance.</p>
</div>
<div class="paragraph">
<p>The Go memory model specifies that programs with data races have undefined behavior. This means that the compiler and runtime are free to make optimizations that assume no races exist, potentially breaking code that relies on unsynchronized access patterns.</p>
</div>
<div class="sect2">
<h3 id="_what_is_the_potential_impact">What is the potential impact?</h3>
<div class="paragraph">
<p>Race conditions can cause data corruption, unpredictable program behavior, and performance degradation. In severe cases, they can lead to application crashes, incorrect business logic execution, or security vulnerabilities where sensitive data becomes corrupted or accessible inappropriately.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_fix_it">How to fix it</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Use a mutex to synchronize access to shared variables. Lock the mutex before accessing the variable and unlock it afterward.</p>
</div>
<div class="sect2">
<h3 id="_code_examples">Code examples</h3>
<div class="sect3">
<h4 id="_noncompliant_code_example">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-go" data-lang="go">var counter int

func increment() {
    go func() {
        counter++ // Noncompliant
    }()
    go func() {
        counter++ // Noncompliant
    }()
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-go" data-lang="go">var counter int
var mu sync.Mutex

func increment() {
    go func() {
        mu.Lock()
        counter++
        mu.Unlock()
    }()
    go func() {
        mu.Lock()
        counter++
        mu.Unlock()
    }()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_documentation">Documentation</h3>
<div class="ulist">
<ul>
<li>
<p>Go Memory Model - <a href="https://go.dev/ref/mem">Official documentation explaining Go&#8217;s memory model and synchronization requirements</a></p>
</li>
<li>
<p>Go Race Detector - <a href="https://go.dev/doc/articles/race_detector">Guide on using Go&#8217;s built-in race detector to find race conditions</a></p>
</li>
<li>
<p>Effective Go - Concurrency - <a href="https://go.dev/doc/effective_go#concurrency">Best practices for concurrent programming in Go</a></p>
</li>
<li>
<p>Go Tour - Concurrency - <a href="https://go.dev/tour/concurrency/1">Interactive tutorial covering Go&#8217;s concurrency primitives</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_standards">Standards</h3>
<div class="ulist">
<ul>
<li>
<p>CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization - <a href="https://cwe.mitre.org/data/definitions/362.html">Race condition vulnerability classification</a></p>
</li>
<li>
<p>CWE-366: Race Condition within a Thread - <a href="https://cwe.mitre.org/data/definitions/366.html">Thread-level race condition vulnerability</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>