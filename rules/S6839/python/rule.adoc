HTTP response headers should not be vulnerable to response splitting attacks

include::../description.adoc[]

include::../how-to-fix-it.adoc[]

=== Code examples

==== Noncompliant code example

[source,python,diff-id=1,diff-type=noncompliant]
----
from http.server import HTTPServer, BaseHTTPRequestHandler
from urllib.parse import urlparse, parse_qs

class ReqHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        parsed = urlparse(self.path)
        params = parse_qs(parsed.query)
        self.send_response(200)
        self.send_header("Content-Type", params.get('header')[0]) # Noncompliant
        self.end_headers()
        self.wfile.write(bytes("Hello World!", "utf-8"))
----

==== Compliant solution

[source,python,diff-id=1,diff-type=compliant]
----
from http.server import HTTPServer, BaseHTTPRequestHandler
from urllib.parse import urlparse, parse_qs
import re

class ReqHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        parsed = urlparse(self.path)
        params = parse_qs(parsed.query)
        self.send_response(200)
        allowed_content_types = r'application/(pdf|json|xml)'
        if re.match(allowed_content_types, params.get('header')[0]):        
            self.send_header("Content-Type", params.get('header')[0])  
        else:
            self.send_header("Content-Type", "application/json")   
        self.end_headers()
        self.wfile.write(bytes("Hello World!", "utf-8"))
----

//=== How does this work?

//=== Pitfalls

//=== Going the extra mile


//== Resources
include::../see.adoc[]

//=== Documentation
//=== Articles & blog posts
//=== Conference presentations
//=== Standards
//=== External coding guidelines
//=== Benchmarks
