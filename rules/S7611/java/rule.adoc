== Why is this an issue?

Methods like  `++StringBuilder.append++` or `++PrinStream.println++` are designed to accept different datatypes, manually converting them using `toString()` is unnecessary and leads to verbose code.

`++StringBuilder.append++`, `++StringBuffer.append++` or `++PrintStream.println++` accepts all the primitive types.
Manual conversion using toString() or valueOf() results in verbose code that obstructs readability and maintainability. The issue may hide potential discrepancies when the conversion is implicitly handled by the respective classes.

StringBuilder, StringBuffer, or PrintStream


== How to fix it
Remove the redundant calls to `++toString()++` or `++valueOf()++`.

=== Code examples

==== Noncompliant code example
[source,java,diff-id=1,diff-type=noncompliant]
----
void noncompliant(StringBuilder sb) {
  char c = 'c';
  sb.append(Character.toString(c)); // Noncompliant
  System.out.println(Character.toString(c)); // Noncompliant

  Character d = Character.valueOf('d');
  sb.append(d.toString()); // Noncompliant
  System.out.println(d.toString()); // Noncompliant
}
----

==== Compliant solution
[source,java,diff-id=1,diff-type=compliant]
----
void compliant(StringBuilder sb) {
  char c = 'c';
  sb.append(c); // Compliant
  System.out.println(c); // Compliant

  Character d = 'd';
  sb.append(d); // Compliant
  System.out.println(d); // Compliant
}
----

//=== How does this work?
The compliant solution works because the utility classes perform implicit conversion. Removing explicit calls such as `toString()` ensures that the built-in conversion is used, which simplifies the code and reduces redundancy.
//=== Pitfalls
When refactoring, ensure that removing the manual conversion does not alter the output, even though in these cases it is safe.
When refactoring, ensure that removing the manual conversion does not alter the output, even though in these cases it is safe.



