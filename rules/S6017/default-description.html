<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>C&#43;&#43;17 version of the standards introduces <code>if constexpr</code>. If the <code>constexpr</code> keyword follows the <code>if</code> keyword in an if statement, then the <code>if</code> condition must be a constant and the <code>then</code> or <code>else</code> block is discarded at compile time, depending on the value of the constant.</p>
</div>
<div class="paragraph">
<p>More precisely, <code>if constexpr</code> branches that are discarded are not going to be instantiated. This behavior enables us to write some overloaded function templates in a more readable way: you don&#8217;t need to use complex patterns (eg: by using <code>std::enable_if</code>) to make code compile.</p>
</div>
<div class="paragraph">
<p>This rule points out whereÂ a complex overloaded functions template could simply be replaced by <code>if constexpr</code>.</p>
</div>
<div class="sect2">
<h3 id="_noncompliant_code_example">Noncompliant code example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">template&lt;typename Type&gt;
typename std::enable_if_t&lt;std::is_arithmetic_v&lt;Type&gt;&gt; process(Type&amp;&amp; type); // Noncompliant, this function can be combined with the one below

template&lt;typename Type&gt;
typename std::enable_if_t&lt;!std::is_arithmetic_v&lt;Type&gt;&gt; process(Type&amp;&amp; type);

template &lt;typename It, typename Distance&gt;
void moveForward(It&amp; it, Distance d, std::input_iterator_tag); // Noncompliant, this function can be combined with the one below

template &lt;typename It, typename Distance, typename T&gt;
void moveForward(It&amp; it, Distance d, T);

template &lt;typename It, typename Distance&gt;
void moveForward(It&amp; it, Distance d) { // Wrapper of the "moveForward" functions
    moveForward(it, d, typename std::iterator_traits&lt;It&gt;::iterator_category{} );
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_compliant_solution">Compliant solution</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">template&lt;typename Type&gt;
void process(Type&amp;&amp; type) {
    if constexpr(std::is_arithmetic_v&lt;type&gt;) {
        // implementation
    } else {
        // implementation
    }
}

template &lt;typename It, typename Distance&gt;
void moveForward(It&amp; it, Distance d) { // Modifications have been directly done inside the wrapper
    if constexpr (std::iterator_traits&lt;It&gt;::input_iterator_tag) {
        // implementation
    } else {
        // implementation
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>