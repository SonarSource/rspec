<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In C&#43;&#43;, it usually does not matter how many times you access a variable as long as the variable value is the right one. However, this is not the case when the variable is in a memory region mapped to external hardware. In that case, for instance, several successive reads can yield different values (if the memory is updated by the hardware in-between), and several writes of the same value may be significant (some hardware trigger events each time a memory location is written to).</p>
</div>
<div class="paragraph">
<p>To specify that every read and write has an impact outside of the abstract machine of the language, access to a variable may be qualified as <code>volatile</code>: it will oblige the program to perform all specified reads and writes operations without optimizing anything away.</p>
</div>
<div class="paragraph">
<p>When a variable appears in a compound expression (for instance, <code>a&#43;&#43;</code> or <code>a+=2</code>), the variable is accessed twice even if it is only named once. The standard was not explicit on this topic up until C&#43;&#43;23, but this detail matters for <code>volatile</code> variables for which every access to the variable matters.</p>
</div>
<div class="paragraph">
<p>Consequently, it is usually clearer to rewrite the code so that the variable appears twice, matching the number of accesses that will happen.</p>
</div>
<div class="paragraph">
<p>Note: In C&#43;&#43;20, compound expressions on volatile variables were deprecated. This deprecation was removed in C&#43;&#43;23, and the number of accesses was made explicit. The reason for removing the deprecation is that such operations are commonly used in embedded code, especially to access specific variable bits. However, using a function with a dedicated name instead of direct bit manipulation usually leads to code that is easier to read.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_fix_it">How to fix it</h2>
<div class="sectionbody">
<div class="paragraph">
<p>As every access to a <code>volatile</code> variable matters, the number of access should be explicitly visible in the code.</p>
</div>
<div class="sect2">
<h3 id="_code_examples">Code examples</h3>
<div class="sect3">
<h4 id="_noncompliant_code_example">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">void f1(int volatile* p) {
  ++(*p); // Noncompliant
}

void f2(volatile int&amp; in) {
  in += 2; // Noncompliant
}

void f3(volatile int&amp; in) {
  int i = in = 2; // Noncompliant
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">void f1(int volatile* p) {
  auto val = *p;  // One access to read the register
  *p = val + 1; // One access to write to it (and potentially overwrite another change)
}

void f2(volatile int&amp; in) {
  auto val = in;
  in = val + 2;
}

void f3(volatile int&amp; in) {
  in = 2;
  int i = in;
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>