<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p><em>Forwarding references</em> (also known as <em>universal references</em>) provide the ability to write a template that can deduce and accept any kind of reference to the object (<em>rvalue</em>/<em>lvalue</em> <em>mutable</em>/<em>const</em>).
This enables the creation of a perfect forwarding constructor for wrapper types: the constructor arguments are forwarded to build the underlying type:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">class Wrapper {
public:
  // A defaulted copy constructor
  Wrapper(Wrapper const&amp; other) = default;

  template &lt;typename T&gt;
  Wrapper(T&amp;&amp; str)  // A noncompliant forwarding constructor
    : str(std::forward&lt;T&gt;(str)) {}

private:
  std::string str;
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>However, this constructor is too greedy: overload resolution prefers it over the copy constructor as soon as the argument type is slightly different from a <code>Wrapper const&amp;</code>.
For instance, when passing a non-const <em>lvalue</em> (<code>w</code> in the following example), calling the copy constructor requires a non-const to const conversion, while the forwarding reference parameter is an exact match,
and will therefore be selected. This is usually not the expected behavior.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">Wrapper const cw("str1");
Wrapper w("str2");

Wrapper w1(cw);  // Ok: calls Wrapper(Wrapper const&amp; other)
Wrapper w2(w);   // Ill-formed: calls Wrapper(T&amp;&amp; str) with [T = Wrapper&amp;]
                 // This tries to initialize a std::string using a Wrapper object</code></pre>
</div>
</div>
<div class="paragraph">
<p>This rule specifically targets constructors that can be called with a single <em>forwarding reference</em> argument.
In such cases, they compete with copy or move constructors, including those implicitly generated by the compiler.
Yet, selecting the wrong overload can also happen with forwarding references on regular functions and methods, but this is out of scope for this rule.</p>
</div>
<div class="paragraph">
<p>Even if the non-constrained forwarding constructor may currently seem to work fine, using it with different value categories in the future
could result in unexpected compilation errors or, even worse, hard-to-debug run-time behavior if the wrapped type happens to be
constructible from instances of the wrapper.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_fix_it">How to fix it</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The rule reports forwarding constructors without proper constraints if they can be called with a single argument.
To eliminate this pitfall, add constraints to such constructors so that they are not considered an overload candidate when the argument is
a reference to the class itself. This can be achieved by adding any of the following checks to the forwarding reference constructor:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a check of the concept <code>!std::same_as&lt;std::remove_cvref_t&lt;U&gt;, Wrapper&gt;</code>, or</p>
</li>
<li>
<p>a check of type predicate  <code>!std::is_same_v&lt;std::remove_cvref_t&lt;U&gt;, Wrapper&gt;</code>, or</p>
</li>
<li>
<p>an <code>std::enable_if</code> with the equivalent condition.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Note that special care has to be taken when <code>Wrapper</code> is a base class. This is explained in more detail in "Going the extra mile"
below. In this case, those checks would become:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the concept <code>!std::derived_from&lt;std::remove_cvref_t&lt;U&gt;, Wrapper&gt;</code>, or</p>
</li>
<li>
<p>a type-predicate <code>!std::is_base_of_v&lt;Wrapper, std::remove_cvref_t&lt;U&gt;&gt;</code>, or</p>
</li>
<li>
<p>an <code>std::enable_if</code> with the equivalent condition.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The concept-based solutions require C&#43;&#43;20. The <code>std::enable_if</code> solution is more cumbersome to write but can always be used.</p>
</div>
<div class="paragraph">
<p>Note that there are other ways to constrain such a constructor, but this rule only recognizes the explicit checks described above as compliant.</p>
</div>
<div class="sect2">
<h3 id="_code_examples">Code examples</h3>
<div class="sect3">
<h4 id="_noncompliant_code_example">Noncompliant code example</h4>
<div class="paragraph">
<p>In this noncompliant example, the implicitly compiler-generated copy constructor can receive calls only when copying non-const lvalues (i.e., exact
matches). Otherwise, the forwarding constructor is used, even when the given type can not be used to initialize the wrapped
<code>std::string</code> object.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">class Wrapper {
public:
  template &lt;typename T&gt;
  Wrapper(T&amp;&amp; str)  // Noncompliant: competes with compiler-generated copy constructor
    : str(std::forward&lt;T&gt;(str)) {}

private:
  std::string str;
};</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution">Compliant solution</h4>
<div class="paragraph">
<p>We fix the problem by adding a constraint to our forwarding constructor. This enables the copy constructor to receive calls again by
excluding the forwarding constructor when the deduced <code>T</code> is <code>Wrapper</code> (after discarding references and const-volatile qualifiers).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">class Wrapper {
public:
  template &lt;typename T&gt;
  requires (!std::same_as&lt;Wrapper, std::remove_cvref_t&lt;T&gt;&gt;)
  Wrapper(T&amp;&amp; str)  // Compliant: no longer competes with the copy constructor
    : str(std::forward&lt;T&gt;(str)) {}

private:
  std::string str;
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>If C&#43;&#43;20 is not available, we can use <code>std::enable_if</code> instead of concepts. We also can not use <code>std::remove_cvref_t</code>, and we have to
be more verbose:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">// Define our own remove_cvref_t for use in C++11
template &lt;typename T&gt;
using remove_cvref_t = typename std::remove_cv&lt;typename std::remove_reference&lt;T&gt;::type&gt;::type;

class Wrapper {
public:
  template &lt;
    typename T,
    typename std::enable_if&lt;
      !std::is_same&lt;Wrapper, remove_cvref_t&lt;T&gt;&gt;::value, int&gt;::type /* Unnamed */ = 0&gt;
  Wrapper(T&amp;&amp; str)  // Compliant: no longer competes with the copy constructor
    : str(std::forward&lt;T&gt;(str)) {}

private:
  std::string str;
};</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_noncompliant_code_example_2">Noncompliant code example</h4>
<div class="paragraph">
<p>This noncompliant example demonstrates a bad attempt at constraining a forwarding constructor in a template wrapper:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">template&lt;typename T&gt;
class TemplateWrapper {
public:
  TemplateWrapper(TemplateWrapper const&amp; other) = default;

  template&lt;typename U&gt;
    requires std::constructible_from&lt;T, U&gt;
  TemplateWrapper(U&amp;&amp; u) // Noncompliant: constructible_from check is not sufficient in general
    : value(std::forward&lt;U&gt;(u))
  {}

private:
  T value;
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>The problem with this constraint is that it depends on how the type <code>T</code> can be constructed; For example, it can yield unexpected results if
<code>T</code> itself has a forwarding constructor.</p>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution_2">Compliant solution</h4>
<div class="paragraph">
<p>In order to properly make our <code>TemplateWrapper</code> generic, we need to add the necessary constraint alongside <code>std::constructible_from</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">template&lt;typename T&gt;
class TemplateWrapper {
public:
  TemplateWrapper(TemplateWrapper const&amp; other) = default;

  template&lt;typename U&gt;
    requires (!std::derived_from&lt;std::remove_cvref_t&lt;U&gt;, TemplateWrapper&gt; &amp;&amp; std::constructible_from&lt;T, U&gt;)
  TemplateWrapper(U&amp;&amp; u)  // Compliant: properly constrained regardless of how T can be constructed
    : value(std::forward&lt;U&gt;(u))
  {}

private:
  T value;
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using <code>std::derived_from</code> instead of <code>std::same_as</code> is only meant for demonstration purposes here. <code>std::derived_from</code> is necessary only if
<code>TemplateWrapper</code> has derived classes, to ensure that the copy constructors of these derived classes don&#8217;t end up calling the forwarding
constructor. This is explained in more detail in the "Going the extra mile" section below.</p>
</div>
</div>
<div class="sect3">
<h4 id="_noncompliant_code_example_3">Noncompliant code example</h4>
<div class="paragraph">
<p>In this noncompliant example, the forwarding constructor accepts a parameter pack and uses it to initialize the wrapped type. This can
still compete with the copy constructor when called with a single argument. Using <code>std::constructible_from</code> is not sufficient for the same
reasons as the previous example.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">template&lt;typename T&gt;
class EmplaceWrapper {
public:
  EmplaceWrapper(EmplaceWrapper const&amp; other) = default;

  template&lt;typename... Args&gt;
    requires std::constructible_from&lt;T, Args...&gt;
  EmplaceWrapper(Args&amp;&amp;... args) // Noncompliant: will compete with copy-constructor
    : value(std::forward&lt;Args&gt;(args)...)
  {}

private:
  T value;
};</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution_3">Compliant solution</h4>
<div class="paragraph">
<p>In this case, we can use a type tag to allow the user to explicitly choose the emplace constructor.
This approach is simpler to implement and offers greater flexibility.
It is the same approach used by many wrapper types in the standard library,
such as <a href="https://en.cppreference.com/w/cpp/utility/optional/optional"><code>std::optional</code></a>
and <a href="https://en.cppreference.com/w/cpp/utility/expected/expected"><code>std::expected</code></a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">template&lt;typename T&gt;
class EmplaceWrapper {
public:
  EmplaceWrapper(EmplaceWrapper const&amp; other) = default;

  template&lt;typename... Args&gt;
    requires std::constructible_from&lt;T, Args...&gt;
  EmplaceWrapper(std::in_place_t, Args&amp;&amp;... args)  // Compliant: use type tag to explicitly choose emplace constructor
    : value(std::forward&lt;Args&gt;(args)...)
  {}

private:
  T value;
};</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_going_the_extra_mile">Going the extra mile</h3>
<div class="paragraph">
<p>When the forwarding constructor belongs to a base class, using the <code>same_as</code> constraint check is not sufficient:
The forwarding constructor can still get selected when we are copying from a derived object.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">class Base {
public:
  template &lt;typename T&gt;
  requires (!std::same_as&lt;std::remove_cvref_t&lt;T&gt;, Base&gt;)  // Incorrect: same_as is not sufficient for base classes.
  Base(T&amp;&amp; str) : str(std::forward&lt;T&gt;(str)) {}
private:
  std::string str;
};

class Derived : public Base {};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then the following results in a compilation error:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">Derived d("str");
// Note that the constraint is satisfied when T is Derived&amp;
Base b(d);  // Calls the forwarding constructor instead of the usual "slicing" behavior</code></pre>
</div>
</div>
<div class="paragraph">
<p>Additionally, subclasses can run into trouble when they try to define their copy constructors:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">class Derived2 : public Base {
  // ...
public:
  Derived2(Derived2 const&amp; d)
    // d is of Derived2 type and it therefore satisfies the same_as constraint for the forwarding constructor
    : Base(d) {  // Error: Calls the forwarding constructor instead of the base copy constructor
    // ...
  }
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>To avoid these problems, use <code>std::derived_from</code> or <code>std::base_of</code> checks instead of <code>std::same_as</code> or <code>std::is_same</code> when the forwarding
constructor belongs to a class that has derived classes.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_documentation">Documentation</h3>
<div class="ulist">
<ul>
<li>
<p>C&#43;&#43; reference - <a href="https://en.cppreference.com/w/cpp/utility/forward"><code>std::forward</code></a></p>
</li>
<li>
<p>C&#43;&#43; reference - <a href="https://en.cppreference.com/w/cpp/language/overload_resolution#Ranking_of_implicit_conversion_sequences">Ranking of implicit conversion sequences during overload resolution</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_articles_blog_posts">Articles &amp; blog posts</h3>
<div class="ulist">
<ul>
<li>
<p>Effective Modern C&#43;&#43; item 26: Avoid overloading on universal references</p>
</li>
<li>
<p>Eric Niebler - <a href="https://ericniebler.com/2013/08/07/universal-references-and-the-copy-constructo/">Universal References and the Copy Constructor</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>