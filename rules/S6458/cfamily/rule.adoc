== Why is this an issue?

_Forwarding references_ (also known as _universal references_) provide the ability to write a template that can deduce and accept any kind of reference to the object (_rvalue_/_lvalue_ _mutable_/_const_).
This enables the creation of a perfect forwarding constructor for wrapper types: the constructor arguments are forwarded to build the underlying type:
[source,cpp]
----
class Wrapper {
public:
  // A defaulted copy constructor
  Wrapper(Wrapper const& other) = default;

  template <typename T>
  Wrapper(T&& str)  // A noncompliant forwarding constructor
    : str(std::forward<T>(str)) {}

private:
  std::string str;
};
----

However, this constructor is too greedy: overload resolution prefers it over the copy constructor as soon as the argument type is slightly different from a `Wrapper const&`.
For instance, when passing a non-const _lvalue_ (`w` in the following example), calling the copy constructor requires a non-const to const conversion, while the forwarding reference parameter is an exact match,
and will therefore be selected. This is usually not the expected behavior.

[source,cpp]
----
Wrapper const cw("str2");
Wrapper w("str1");

Wrapper w2(cw);  // Ok: calls Wrapper(Wrapper const& other)
Wrapper w3(w);   // Ill-formed: calls Wrapper(T&& str) with [T = Wrapper&] which tries to initialize a std::string using a Wrapper object.
----

It can be argued that the greediness of forwarding references is a general problem. However, this rule specifically targets constructors
that can be called with a single argument of _forwarding reference_ type. This is because in such cases, they can compete with copy or move
constructors including those that are implicitly generated by the compiler.

Even if the non-constrained forwarding constructor seems to work fine at present, introducing seemingly normal usages with different value
categories in the future can trigger compilation errors that are hard to understand and debug, or even confusing run-time behavior if the
wrapped type happens to be constructible from instances of the wrapper.

== How to fix it

The rule reports forwarding constructors without proper constraints if they can be called with a single argument.
To eliminate this pitfall, add constraints to such constructors so that they are not considered an overload candidate when the argument is a reference to the class type
or to a class derived from the class type. This can be achieved by adding any of the following checks to the forwarding reference constructor:

* A check of the concept `!same_as<remove_cvref_t<U>, Wrapper>`
* A check of type predicate  `!is_same_v<remove_cvref_t<U>, Wrapper>`, or
* An `enable_if` with the equivalent condition.

If `Wrapper` were a base class, those checks would become:

* The concept `!derived_from<std::remove_cvref_t<U>, Wrapper>`
* A type-predicate `!is_base_of_v<Wrapper, std::remove_cvref_t<U>>`, or
* An `enable_if` with the equivalent condition.

The concept-based solutions require {cpp}20. The `enable_if` solution is more cumbersome to write but can always be used.

Note that there are other ways to constrain such a constructor, but this rule only recognizes the explicit checks described above as compliant.

=== Code examples

==== Noncompliant code example

In this noncompliant example, the compiler-generated copy constructor can receive calls only when copying non-const lvalues (i.e., exact
matches). Otherwise, the forwarding constructor will take over, even when the given type can not be used to initialize the wrapped
`std::string` object.

// No diff-ids because the first example has two compliant solutions. The rest were also left out for consistency.
[source,cpp]
----
class Wrapper {
public:
  template <typename T>
  Wrapper(T&& str)  // Noncompliant: competes with compiler-generated copy constructor
    : str(std::forward<T>(str)) {}

private:
  std::string str;
};
----

==== Compliant solution

We fix the problem by adding a constraint to our forwarding constructor. This enables the copy constructor to receive calls again by
excluding the forwarding constructor when the deduced `T` is `Wrapper` (after discarding references and const-volatile qualifiers).

[source,cpp]
----
class Wrapper {
public:
  template <typename T>
  requires (!std::same_as<Wrapper, std::remove_cvref_t<T>>)
  Wrapper(T&& str)  // Compliant: no longer competes with the copy constructor
    : str(std::forward<T>(str)) {}

private:
  std::string str;
};
----

If {cpp}20 is not available yet, we can use `std::enable_if` instead of concepts. We also can not use `std::remove_cvref_t`, and we have to
be more verbose:

[source,cpp]
----
class Wrapper {
public:
  template <typename T,
      typename std::enable_if<
      !std::is_same<
        Wrapper, 
        typename std::remove_cv<typename std::remove_reference<T>::type>::type
      >::value, 
      int>::type /* Unnamed */ = 0>
  Wrapper(T&& str)  // Compliant: no longer competes with the copy constructor
    : str(std::forward<T>(str)) {}

private:
  std::string str;
};
----

==== Noncompliant code example

This noncompliant example demonstrates a bad attempt at constraining a forwarding constructor in a template wrapper:

[source,cpp]
----
template<typename T>
class TemplateWrapper {
public:
  TemplateWrapper(TemplateWrapper const& other) = default;

  template<typename U>
    requires std::constructible_from<T, U>
  TemplateWrapper(U&& u) // Noncompliant: constructible_from check is not sufficient in general
    : value(std::forward<U>(u))
  {} 

private:
  T value;
};
----

The problem with this constraint is that it depends on how the type `T` can be constructed; For example, it can yield unexpected results if
`T` itself has a forwarding constructor.

==== Compliant solution

In order to properly make our `TemplateWrapper` generic, we need to add the necessary constraint alongside `std::constructible_from`:

[source,cpp]
----
template<typename T>
class TemplateWrapper {
public:
  TemplateWrapper(TemplateWrapper const& other) : value(other.value) {}
   
  template<typename U>
    requires (!std::derived_from<std::remove_cvref_t<U>, TemplateWrapper>) && std::constructible_from<T, U>
  TemplateWrapper(U&& u)  // Compliant: properly constrained regardless of how T can be constructed
    : value(std::forward<U>(u))
  {} 

private:
  T value;
};
----

Using `std::derived_from` instead of `std::same_as` is only meant for demonstration purposes here. `std::derived_from` is necessary only if
`TemplateWrapper` has derived classes, to ensure that the copy constructors of these derived classes don't end up calling the forwarding
constructor.

==== Noncompliant code example

In this noncompliant example, the forwarding constructor accepts a parameter pack and uses it to initialize the wrapped type. This can
still compete with the copy constructor when called with a single argument. Using `std::constructible_from` is not sufficient for the same
reasons as the previous example.

[source,cpp]
----
template<typename T>
class EmplaceWrapper {
public:
  EmplaceWrapper(EmplaceWrapper const& other) = default;

  template<typename... Args>
    requires std::constructible_from<T, Args...>
  EmplaceWrapper(Args&&... args) // Noncompliant: will compete with copy-constructor
    : value(std::forward<Args>(args)...)
  {} 

private:
  T value;
};
----

==== Compliant solution

In this case, we can use a type tag to allow the user to explicitly choose the emplace constructor. This approach is simpler to implement
and offers greater flexibility. It is the same approach used by many wrapper types in the standard library, such as `std::optional` and
`std::expected`.

[source,cpp]
----
template<typename T>
class EmplaceWrapper {
public:
  EmplaceWrapper(EmplaceWrapper const& other) = default;

  template<typename... Args>
    requires std::constructible_from<T, Args...>
  EmplaceWrapper(std::in_place_t, Args&&... args)  // Compliant: use type tag to explicitly choose emplace constructor
    : value(std::forward<Args>(args)...)
  {} 

private:
  T value;
};
----

== Resources

=== Documentation

* CPP reference - https://en.cppreference.com/w/cpp/utility/forward[`std::forward`]
* CPP reference - https://en.cppreference.com/w/cpp/language/overload_resolution#Ranking_of_implicit_conversion_sequences[Ranking of implicit conversion sequences during overload resolution]
* CPP reference - https://en.cppreference.com/w/cpp/utility/optional/optional[`std::optional` constructor]

=== Articles & blog posts

* Effective Modern {cpp} item 26: Avoid overloading on universal references
* Eric Niebler - https://ericniebler.com/2013/08/07/universal-references-and-the-copy-constructo/[Universal References and the Copy Constructor]
