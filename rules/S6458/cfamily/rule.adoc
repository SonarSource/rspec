== Why is this an issue?

_Forwarding references_ (also known as _universal references_) provide the ability to write a template that can deduce and accept any kind of reference to the object (_rvalue_/_lvalue_ _mutable_/_const_).
This enables the creation of a perfect forwarding constructor for wrapper types, which allows a wrapper to forward its constructor arguments into the initializer of the underlying type:
[source,cpp]
----
template<typename T>
class Wrapper {
public:
  Wrapper() = default;
  Wrapper(const Wrapper& other) : value(other.value) {}

  template<typename U>
  Wrapper(U&& u) // forwarding constructor
    : value(std::forward<U>(u))
  {}

private:
  T value;
};
----

However, this constructor is too greedy: overload resolution prefers it over the copy constructor as soon as the argument type is slightly different from a `const Wrapper&`.
For instance, when passing a non-const _lvalue_, calling the copy constructor requires a benign non-const to const conversion, while the forwarding reference parameter is an exact match,
and will therefore be selected. This is usually not the expected behavior.

[source,cpp]
----
Wrapper<int> w;
Wrapper<int> const cw;
Wrapper<int> w2(cw); // Ok: calls Wrapper(Wrapper const& other)
Wrapper<int> w3(w); // Ill-formed: calls Wrapper(U&& u) with U = Wrapper<int>&
----

The greediness of forwarding references is a general problem, but it is even more serious for constructors that can be called with a single argument of _forwarding reference_ type
(including variadic template constructors) because in that case, they compete with copy or move constructors.

== How to fix it

The rule reports forwarding constructors without proper constraints if they can be called with a single argument.
To eliminate this pitfall, add constraints to such constructors so that they are not considered an overload candidate when `U&&` is a reference to the class type
or to a class derived from the class type. This can be achieved by adding any of the following checks to the forwarding reference constructor:

* A check of the concept `!same_as<remove_cvref_t<U>, Wrapper>`
* A check of type predicate  `!is_same_v<remove_cvref_t<U>, Wrapper>`, or
* An `enable_if` with the equivalent condition.

If `Wrapper` were a base class, those checks would become:

* The concept `derived_from<std::remove_cvref_t<U>, Wrapper>`
* A type-predicate `!is_base_of_v<Wrapper, std::remove_cvref_t<U>>`, or
* An `enable_if` with the equivalent condition.

The concept-based solutions require {cpp}20; while the `enable_if` solution, which is more cumbersome to write, can always be used.

Note that there are other ways to constrain such a constructor, but this rule only recognizes the explicit checks described above as compliant.

=== Code examples

==== Noncompliant code example

// No diff-ids because the first example has two compliant solutions. The rest were also left out for consistency.
[source,cpp]
----
template<typename T>
class Wrapper {
public:
  Wrapper(Wrapper const& other) : value(other.value) {}

  template<typename U>
  Wrapper(U&& u) // Noncompliant: competes with copy constructor
    : value(std::forward<U>(u))
  {} 

private:
  T value;
};
----

==== Compliant solution

[source,cpp]
----
template<typename T>
class Wrapper {
public:
  Wrapper(Wrapper const& other) : value(other.value) {}
   
  template<typename U>
    requires (!std::same_as<Wrapper, std::remove_cvref_t<U>>)
  Wrapper(U&& u)  // Compliant: no longer competes with copy constructor
    : value(std::forward<U>(u))
  {}

private:
  T value;
};
----

If you can't use {cpp}20 yet, use `std::enable_if` instead:

[source,cpp]
----
template<typename T>
class Wrapper {
public:
  Wrapper(Wrapper const& other) : value(other.value) {}
  
  template<typename U,
    typename std::enable_if<
      !std::is_same<
        Wrapper, 
        typename std::remove_cv<typename std::remove_reference<U>::type>::type
      >::value, 
      int>::type /* Unnamed */ = 0>
  Wrapper(U&& u)  // Compliant: no longer competes with copy constructor
    : value(std::forward<U>(u))
 {} 

private:
  T value;
};
----

==== Noncompliant code example

[source,cpp]
----
template<typename T>
class OtherWrapper {
public:
  OtherWrapper(OtherWrapper const& other) = default;

  template<typename U>
    requires std::constructible_from<T, U>
  OtherWrapper(U&& u) // Noncompliant: constructible_from check is not sufficient in general
    : value(std::forward<U>(u))
  {} 

private:
  T value;
};
----

==== Compliant solution

[source,cpp]
----
template<typename T>
class OtherWrapper {
public:
  OtherWrapper(OtherWrapper const& other) : value(other.value) {}
   
  template<typename U>
    requires (!std::derived_from<std::remove_cvref_t<U>, OtherWrapper>) && std::constructible_from<T, U>
  OtherWrapper(U&& u)  // Compliant: properly constrained regardless of how T can be constructed
    : value(std::forward<U>(u))
  {} 

private:
  T value;
};
----

==== Noncompliant code example

[source,cpp]
----
template<typename T>
class EmplaceWrapper {
public:
  EmplaceWrapper(EmplaceWrapper const& other) = default;

  template<typename... Args>
    requires std::constructible_from<T, Args...>
  EmplaceWrapper(Args&&... args) // Noncompliant: will compete with copy-constructor
    : value(std::forward<Args>(args)...)
  {} 

private:
  T value;
};
----

==== Compliant solution

[source,cpp]
----
template<typename T>
class EmplaceWrapper {
public:
  EmplaceWrapper(EmplaceWrapper const& other) = default;

  template<typename... Args>
    requires std::constructible_from<T, Args...>
  EmplaceWrapper(std::in_place_t, Args&&... args)  // Compliant: use type tag to explicitly choose emplace constructor
    : value(std::forward<Args>(args)...)
  {} 

private:
  T value;
};
----

== Resources

=== Documentation

* CPP reference - https://en.cppreference.com/w/cpp/utility/forward[`std::forward`]
* CPP reference - https://en.cppreference.com/w/cpp/language/overload_resolution#Ranking_of_implicit_conversion_sequences[Ranking of implicit conversion sequences during overload resolution]

=== Articles & blog posts

* Effective Modern {cpp} item 26: Avoid overloading on universal references
* Eric Niebler - https://ericniebler.com/2013/08/07/universal-references-and-the-copy-constructo/[Universal References and the Copy Constructor]
