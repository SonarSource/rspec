<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Casting an object pointer can very easily lead to undefined behavior. Only a few cases are supported, for instance casting an object pointer to a large enough integral type (and back again), casting an object pointer to a pointer to void (and back again)&#8230;&#8203; Using a pointer cast to access an object as if it was of another type than its real type is not supported in general.</p>
</div>
<div class="paragraph">
<p>This rule detects casts between object pointers and incompatible types.</p>
</div>
<div class="sect2">
<h3 id="_noncompliant_code_example">Noncompliant code example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">struct S1 *p1;
struct S2;
void f ()
{
  (float) p1; // Noncompliant, conversion to floating point type
  (int *) p1; // Noncompliant
  float f;
  int *i = (int *)&amp;f; // Noncompliant, undefined behavior even if sizeof(int) == sizeof(float)
  (int) p1; // Compliant, but might be undefined behavior if 'int' is not large enough to hold the value of p1.
  (void *) p1; // Compliant, conversion to 'void *'
  (struct S2 *)p1; // Noncompliant, conversion to another type.
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_exceptions">Exceptions</h3>
<div class="paragraph">
<p>In C, it is allowed to cast an object pointer to a character pointer to access the byte representation of the object. This rule ignores this case.</p>
</div>
<div class="paragraph">
<p>Anything can be safely cast to <code>void</code> (since nothing can be done with a result of this cast), and doing so is a common pattern to silence compiler warnings about unused variables. This rule ignores such casts.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">void f(int *p) {
  (void)p;
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>MISRA C:2004, 11.2 - Conversions shall not be performed between a pointer to object and any type other than an integral type, another pointer to object type or a pointer to void.</p>
</li>
<li>
<p>MISRA C:2012, 11.3 - A cast shall not be performed between a pointer to object type and a pointer to a different object type.</p>
</li>
</ul>
</div>
<hr>
</div>
</div>
<div class="sect1">
<h2 id="_implementation_specification">Implementation Specification</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_message">Message</h3>
<div class="paragraph">
<p>Remove this hazardous cast.</p>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_comments_and_links">Comments And Links</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_relates_to_s1944">relates to: <a data-rspec-id="S1944" class="rspec-auto-link">S1944</a></h3>

</div>
<div class="sect2">
<h3 id="_is_related_to_s855">is related to: <a data-rspec-id="S855" class="rspec-auto-link">S855</a></h3>

</div>
<div class="sect2">
<h3 id="_is_related_to_s860">is related to: <a data-rspec-id="S860" class="rspec-auto-link">S860</a></h3>

</div>
<div class="sect2">
<h3 id="_on_23_oct_2014_150910_ann_campbell_wrote">on 23 Oct 2014, 15:09:10 Ann Campbell wrote:</h3>
<div class="paragraph">
<p>\[~samuel.mercier] might this be a "bug"?</p>
</div>
</div>
<div class="sect2">
<h3 id="_on_23_oct_2014_161252_samuel_mercier_wrote">on 23 Oct 2014, 16:12:52 Samuel Mercier wrote:</h3>
<div class="paragraph">
<p>\[~ann.campbell.2] I will flag it as a bug. Anyway the cases allowed by this rule seems also buggy:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Conversion between pointers and integral types can result in loss of bits depending on the target architecture and the chose integral type. Also manipulating a pointer as integer is probably meaningless.</p>
</li>
<li>
<p>Conversion between pointers to objects requires the objects to have a common part (which is unmaintainable) and should be avoided.</p>
</li>
<li>
<p>Conversion to <code>void *</code> loses the information of the underlying type, so apart for calling free or realloc I don&#8217;t see the point. But for this particular cases the conversion is implicit and does not requires a cast.
so this rule seems odd to me&#8230;&#8203;</p>
</li>
</ul>
</div>
</div>
</div>
</div>