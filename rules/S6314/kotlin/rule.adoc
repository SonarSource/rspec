In Kotlin `Flow` represents a cold stream concept. And similar to `Stream` in Java or `Sequence` in Kotlin we can manipulate the data inside the flow (filter, transform, collect, etc). In `Flow` as well as in `Stream` and `Sequence` api there are 2 kinds of possible operations: intermediate and terminal. Intermediate operations are the ones returning `Flow`, all other operations are considered terminal. As flows are naturally lazy, no operations will actually start unless the terminal operation is called.

This rule reports an issue if the result of the intermediate operation on `Flow` is left unused.

== Noncompliant Code Example

----
suspend fun main() {
    val flow = flow {
        emit(1)
        emit(2)
        emit(3)
    }
    
    flow.take(2) // Noncompliant, the result of this operation is never used
}
----

== Compliant Solution

----
suspend fun main() {
    val flow = flow {
        emit(1)
        emit(2)
        emit(3)
    }

    flow.take(2).collect { println(it) } // Compliant, collect is a terminal operation
}
----

== See

* https://kotlinlang.org/docs/flow.html[Flow documentation]
