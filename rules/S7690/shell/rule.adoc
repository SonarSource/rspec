This rule raises an issue when shell scripts use `let`, `expr`, or comparison operators within `[ ]` or `[[ ]]` for integer arithmetic operations.

== Why is this an issue?

Shell scripts have multiple ways to perform integer arithmetic, but some approaches are better than others in terms of performance, readability, and maintainability.

The `expr` command is an external program that must be launched as a separate process for each arithmetic operation. This makes it significantly slower than shell built-ins, especially when used repeatedly in loops or complex calculations.

The `let` built-in, while faster than `expr`, requires careful attention to quoting. Variables and expressions often need to be quoted to prevent word splitting and pathname expansion, which can lead to subtle bugs if not handled correctly.

Using `[ ]` or `[[ ]]` for integer comparisons works but is less clear in intent compared to arithmetic-specific syntax.

The `(( ))` arithmetic evaluation construct is specifically designed for integer arithmetic in bash. It provides several advantages:

* **Performance**: It's a shell built-in that doesn't spawn external processes
* **Simplicity**: Variables don't require `$` prefix and no special quoting is needed
* **Clarity**: The syntax clearly indicates arithmetic operations
* **Functionality**: It supports all standard arithmetic operators and comparisons

Using `(( ))` makes the code more readable and maintainable while following modern shell scripting best practices.

=== What is the potential impact?

Using slower arithmetic methods like `expr` can impact script performance, especially in loops or when processing large amounts of data. The `let` command's quoting requirements can introduce bugs if variables contain unexpected characters or spaces. Using suboptimal arithmetic syntax makes the code harder to read and maintain.

=== How to fix?


Replace `let` assignments with `(( ))` arithmetic evaluation. The `(( ))` syntax doesn't require quoting and provides cleaner arithmetic operations.

==== Non-compliant code example

[source,shell,diff-id=1,diff-type=noncompliant]
----
let "result = x * 2"  # Noncompliant
let "counter++"       # Noncompliant
----

==== Compliant code example

[source,shell,diff-id=1,diff-type=compliant]
----
(( result = x * 2 ))
(( counter++ ))
----

=== Documentation

 * Bash Manual - Arithmetic Evaluation - https://www.gnu.org/software/bash/manual/html_node/Arithmetic-Evaluation.html[Official documentation for bash arithmetic evaluation using (( ))]
 * LinuxCommand.org - Coding Standards - https://linuxcommand.org/lc3_adv_standards.php[Comprehensive shell scripting coding standards including arithmetic best practices]
 * Advanced Bash-Scripting Guide - Arithmetic Expansion - https://tldp.org/LDP/abs/html/arithexp.html[Detailed guide on arithmetic operations in bash scripts]

=== Standards

 * CWE-1126: Declaration of Variable with Unnecessarily Wide Scope - https://cwe.mitre.org/data/definitions/1126.html[Using inefficient arithmetic methods can indicate poor coding practices]

