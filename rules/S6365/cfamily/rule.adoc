{cpp}20 coroutines, the `co_await`/`co_yield` expression suspends the currently executed coroutine and resumes the execution to either caller of coroutine function
or to some already suspended coroutine (including current coroutine).

The resumption of the coroutine represented by the `std::coroutine_handle` object, is usually performed by calling the `.resume()` on it.
However, performing such operation during execution of `await_suspend` (that is part of the `await`), will preserve the activation frame of the `await_suspend` method and the calling coode on the stack.
This may lead to stack overflow, in a situation when the chain or directly resumed coroutines is deep enough.

This problem may be avoided by the use of the symmetric transfer. If the `await_suspend` function returns a specialization `std::coroutine_handle`,
this handle will be automatically resumed by the compiler after the function returns (and its activation frame is removed from the stack).
Or in a case when special `std::noop_coroutine_handle` is returned, the execution will be passed to the caller.

Symmetric transfer solution can be also used to resume the current coroutine (by returning handle passed as the parameter), 
however in such cases other more optimal methods are available.

This rule raises an issue on invocation of the `resume` method on `coroutine_handle` performed inside the `await_suspend` method.

== Noncompliant Code Example

----
struct InvokeOtherAwaiter {
  std::coroutine_handle<> other;
  /* .... */
  void await_suspend(std::coroutine_handle<PromiseType> current) {
    if (auto other = h.promise().other_handle) {
      other.resume(); // Noncomplaint 
    }
  }
}

struct WaitForAwaiter {
  Event& event;
  /* .... */
  void await_suspend(std::coroutine_handle<> current) {
    if (bool ready = event.register_callback(current)) {
      h.resume(); // Noncomplaint
    }
  }
}

struct BufferedExecutionAwaiter {
  std::queue<std::coroutine_handle<>>& taskQueue;
  /* .... */
  void await_suspend(std::coroutine_handle<> h) {
    if (taskQueue.empty()) {
      h.resume(); // Noncomplaint
    }
    auto next = list.front();
    taskQueue.pop();
    taskQueue.push(h);
    next.resume();
  }
}
----

== Compliant Solution

----
struct InvokeOtherAwaiter {
  std::coroutine_handle<> other;
  /* .... */
  std::coroutine_handle<> await_suspend(std::coroutine_handle<PromiseType> h) {
    if (auto other = h.promise().other_handle) {
      return other;
    } else {
      return std::noop_coroutine();
    }
  }
}

struct BufferedExecutionAwaiter {
  std::queue<std::coroutine_handle<>>& taskQueue;
  /* .... */
  std::coroutine_handle<> await_suspend(std::coroutine_handle<> current) {
    if (taskQueue.empty()) {
       return h;
    }
    auto next = list.front();
    taskQueue.pop();
    taskQueue.push(h);
    return next;
  }
}

struct WaitForAwaiter {
  Event& event;
  /* .... */
  void await_suspend(std::coroutine_handle<> v) {
    if (bool ready = event.register_callback(current)) {
      return current;
    } else {  
      return std:noop_coroutine()
    }
  }
  // Altenativelly
  bool await_suspend(std::coroutine_handle<> current) {
    return !event.register_callback(current);
  }
}
----

== See

FIXME: A list of links
