<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>With C&#43;&#43;20 coroutines, the <code>co_await</code>/<code>co_yield</code> expression suspends the currently executed coroutine and resumes the execution of either the caller or the coroutine function
or to some already suspended coroutine (including the current coroutine).</p>
</div>
<div class="paragraph">
<p>The resumption of the coroutine represented by the <code>std::coroutine_handle</code> object is usually performed by calling the <code>.resume()</code> on it.
However, performing such an operation during the execution of <code>await_suspend</code> (that is part of <code>co_await</code> expression evaluation) will preserve the activation frame of the <code>await_suspend</code> function and the calling code on the stack.
This may lead to stack overflows in a situation where the chain of directly resumed coroutines is deep enough.</p>
</div>
<div class="paragraph">
<p>The use of the symmetric transfer may avoid this problem. When the <code>await_suspend</code> function returns a <code>std::coroutine_handle</code>, the compiler will automatically use this handle to resume its coroutine after <code>await_suspend</code> returns (and its activation frame is removed from the stack).
Or, when a <code>std::noop_coroutine_handle</code> is returned, the execution will be passed to the caller.</p>
</div>
<div class="paragraph">
<p>Symmetric transfer solution can also be used to resume the current coroutine (by returning handle passed as the parameter).
However, in such cases, conditional suspension can be a more optimal solution.</p>
</div>
<div class="paragraph">
<p>This rule raises an issue on <code>await_suspend</code> functions that could use symmetric transfer.</p>
</div>
<div class="sect2">
<h3 id="_noncompliant_code_example">Noncompliant code example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">struct InvokeOtherAwaiter {
  /* .... */
  void await_suspend(std::coroutine_handle&lt;PromiseType&gt; current) {
    if (auto other = current.promise().other_handle) {
      other.resume(); // Noncompliant
    }
  }
};

struct WaitForAwaiter {
  Event&amp; event;
  /* .... */
  void await_suspend(std::coroutine_handle&lt;&gt; current) {
    if (bool ready = event.register_callback(current)) {
      current.resume(); // Noncompliant
    }
  }
};

struct BufferedExecutionAwaiter {
  std::queue&lt;std::coroutine_handle&lt;&gt;&gt;&amp; taskQueue;
  /* .... */
  void await_suspend(std::coroutine_handle&lt;&gt; current) {
    if (taskQueue.empty()) {
      current.resume(); // Noncompliant
    }
    auto next = taskQueue.front();
    taskQueue.pop();
    taskQueue.push(current);
    next.resume(); // Noncompliant
  }
};</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_compliant_solution">Compliant solution</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">struct InvokeOtherAwaiter {
  /* .... */
  std::coroutine_handle&lt;&gt; await_suspend(std::coroutine_handle&lt;PromiseType&gt; current) {
    if (auto other = current.promise().other_handle) {
      return other;
    } else {
      return std::noop_coroutine();
    }
  }
};

struct WaitForAwaiter {
  Event&amp; event;
  /* .... */
  std::coroutine_handle&lt;&gt; await_suspend(std::coroutine_handle&lt;&gt; current) {
    if (bool ready = event.register_callback(current)) {
      return current;
    } else {
      return std::noop_coroutine()
    }
  }
  // Alternatively
  bool await_suspend(std::coroutine_handle&lt;&gt; current) {
    return !event.register_callback(current);
  }
};

struct BufferedExecutionAwaiter {
  std::queue&lt;std::coroutine_handle&lt;&gt;&gt;&amp; taskQueue;
  /* .... */
  std::coroutine_handle&lt;&gt; await_suspend(std::coroutine_handle&lt;&gt; current) {
    if (taskQueue.empty()) {
       return current;
    }
    auto next = list.front();
    taskQueue.pop();
    taskQueue.push(current);
    return next;
  }
};</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a data-rspec-id="S6366" class="rspec-auto-link">S6366</a> - conditionally suspending current coroutine in optimal way</p>
</div>
</div>
</div>