== Why is this an issue?

Creating a mutable reference from an immutable one is unsound because it can lead to multiple live mutable references to the same object, breaking Rust's guarantees of memory safety. Such patterns are particularly dangerous if unsafe code is present as it can lead to undefined behavior.

=== Code examples

==== Noncompliant code example

[source,rust,diff-id=1,diff-type=noncompliant]
----
fn foo(x: &Foo) -> &mut Bar { 
    unsafe {
        // Noncompliant: Converting immutable reference to mutable.
        &mut *(x as *const Foo as *mut Foo).bar 
    }
}
----

==== Compliant solution

[source,rust,diff-id=1,diff-type=compliant]
----
fn foo(x: &mut Foo) -> &mut Bar { 
    // Compliant: Taking a mutable reference and returning a mutable reference.
    &mut x.bar 
}
----

== Resources
=== Documentation

* Clippy Lints - https://rust-lang.github.io/rust-clippy/master/index.html#mut_from_ref
