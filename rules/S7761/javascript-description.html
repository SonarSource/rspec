<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This rule raises an issue when <code>getAttribute()</code>, <code>setAttribute()</code>, <code>removeAttribute()</code>, or <code>hasAttribute()</code> are used with data attributes (attributes starting with <code>data-</code>).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <code>.dataset</code> property provides a cleaner, more semantic way to work with HTML data attributes compared to generic attribute methods.</p>
</div>
<div class="paragraph">
<p>Data attributes are a special category of HTML attributes designed to store custom data. The browser provides the <code>.dataset</code> API specifically for this purpose, which offers several advantages:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Cleaner syntax</strong>: <code>element.dataset.userName</code> is more readable than <code>element.getAttribute('data-user-name')</code></p>
</li>
<li>
<p><strong>Automatic name conversion</strong>: The API automatically converts between kebab-case HTML attributes (<code>data-user-name</code>) and camelCase JavaScript properties (<code>userName</code>)</p>
</li>
<li>
<p><strong>Semantic correctness</strong>: Using <code>.dataset</code> clearly indicates you&#8217;re working with data attributes, making the code&#8217;s intent more obvious</p>
</li>
<li>
<p><strong>Type consistency</strong>: <code>.dataset</code> properties are always strings, avoiding potential confusion with other attribute types</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Using generic attribute methods for data attributes misses these benefits and can make code less maintainable.</p>
</div>
<div class="sect2">
<h3 id="_what_is_the_potential_impact">What is the potential impact?</h3>
<div class="paragraph">
<p>Using generic attribute methods instead of <code>.dataset</code> reduces code readability and maintainability. While functionally equivalent, it makes the code less expressive about working with data attributes and requires manual handling of name conversions between kebab-case and camelCase.</p>
</div>
</div>
<div class="sect2">
<h3 id="_how_to_fix">How to fix?</h3>
<div class="paragraph">
<p>Replace <code>getAttribute()</code> calls for data attributes with <code>.dataset</code> property access. The attribute name is automatically converted from kebab-case to camelCase.</p>
</div>
<div class="sect3">
<h4 id="_non_compliant_code_example">Non-compliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">const value = element.getAttribute('data-user-name'); // Noncompliant</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_code_example">Compliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">const value = element.dataset.userName;
// or with destructuring
const {userName} = element.dataset;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_documentation">Documentation</h3>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/sindresorhus/eslint-plugin-unicorn#readme">eslint-plugin-unicorn</a> - Rule <a href="https://github.com/sindresorhus/eslint-plugin-unicorn/blob/HEAD/docs/rules/prefer-dom-node-dataset.md">prefer-dom-node-dataset</a></p>
</li>
<li>
<p>MDN: HTMLElement.dataset - <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dataset">Official documentation for the dataset API</a></p>
</li>
<li>
<p>MDN: Using data attributes - <a href="https://developer.mozilla.org/en-US/docs/Learn/HTML/Howto/Use_data_attributes">Guide on using HTML data attributes effectively</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>