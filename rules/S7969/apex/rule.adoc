This rule raises an issue when a try-catch block catches only the generic `Exception` type without catching more specific exception types first.

== Why is this an issue?

Catching only the generic `Exception` type makes error handling less precise and harder to maintain. When you catch `Exception`, you're handling all possible errors the same way, which can mask important differences between error types.

Specific exception types like `MathException`, `DMLException`, `QueryException`, and `ListException` provide valuable information about what went wrong. Each type represents a different category of problem that might need different handling strategies.

For example, a `DMLException` might indicate a data validation issue that could be resolved by showing a user-friendly message, while a `QueryException` might suggest a more serious system problem that requires logging and investigation.

When you catch specific exceptions first, you can:

* Provide more targeted error messages to users
* Apply appropriate recovery strategies for different error types
* Log different types of errors with appropriate severity levels
* Make your code's intent clearer to other developers

Using only generic `Exception` catching also makes it harder to identify which specific errors your code might encounter, reducing the effectiveness of testing and debugging.

=== What is the potential impact?

Using generic exception catching can lead to poor error handling, making it difficult to diagnose issues and provide appropriate user feedback. It can also mask serious system problems by treating all errors the same way.

== How to fix it

Replace generic Exception catching with specific exception types. Catch the most specific exceptions first, then use Exception as a fallback for unexpected errors.

=== Code examples

==== Noncompliant code example

[source,apex,diff-id=1,diff-type=noncompliant]
----
try {
    Integer division_result = 10/0;
    system.debug(division_result);
} catch(Exception ex) { // Noncompliant
    System.debug('Exception occurred');
}
----

==== Compliant solution

[source,apex,diff-id=1,diff-type=compliant]
----
try {
    Integer division_result = 10/0;
    system.debug(division_result);
} catch(MathException ex) {
    System.debug('Math Exception: ' + ex.getMessage());
} catch(Exception ex) {
    System.debug('Unexpected Exception: ' + ex.getMessage());
}
----

== Resources

=== Documentation

 * Apex Exception Handling - https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/apex_exception_definition.htm[Official Salesforce documentation on exception handling in Apex]

 * Built-in Exception Types - https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/apex_classes_exception_methods.htm[Complete list of built-in exception types in Apex]

=== Related rules

 * RSPEC-2738 - https://rules.sonarsource.com/python/RSPEC-2738/[Python rule for catching specific exception types]
