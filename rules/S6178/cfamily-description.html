<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In C&#43;&#43;20, <code>std::string</code> and <code>std::string_view</code> gain new member functions <code>starts_with</code> and <code>ends_with</code> that compare their argument to the prefix and postfix of the string.</p>
</div>
<div class="paragraph">
<p>These two functions introduce a standard, concise, and efficient way of checking the prefix and postfix for strings. The ad-hoc implementations predating C&#43;&#43;20 are often less readable, less efficient, and less reliable.</p>
</div>
<div class="paragraph">
<p>This rule raises an issue when an ad-hoc implementation checks prefixes or postfixes of a string.</p>
</div>
<div class="sect2">
<h3 id="_noncompliant_code_example">Noncompliant code example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">if (6 &lt;= str.size() &amp;&amp; str.substr(0, 6) == "prefix") { // Noncompliant
  std::cout &lt;&lt;str &lt;&lt;" starts with the prefix\n";
}
if (6 &lt;= str.size() &amp;&amp; std::string_view(str.begin(), str.begin() + 6) == "prefix") { // Noncompliant
  std::cout &lt;&lt;str &lt;&lt;" starts with the prefix\n";
}
if (7 &lt;= str.size() &amp;&amp; str.substr(str.size() - 7) == "postfix") { // Noncompliant
  std::cout &lt;&lt;str &lt;&lt;" ends with the postfix\n";
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_compliant_solution">Compliant solution</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">if (str.starts_with("prefix")) {
  std::cout &lt;&lt;str &lt;&lt;" starts with the prefix\n";
}
if (str.ends_with("postfix")) {
  std::cout &lt;&lt;str &lt;&lt;" ends with the postfix\n";
}</code></pre>
</div>
</div>
</div>
</div>
</div>