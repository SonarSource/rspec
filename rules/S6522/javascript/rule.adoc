== Why is this an issue?

Assigning a value to an import variable will cause a runtime error and will raise a compilation error in Typescript.

[source,javascript]
----
import { readFile } from 'node:fs';
readFile = 'hello world!';   // Noncompliant: TypeError: Assignment to constant variable.
----

The import is a live binding which is exported by another module. They are called _live bindings_ because they can be updated or reassigned by the exporting module and the imported value would also change. The importing module cannot reassign it.

Moreover, this rule will raise an issue when trying to modify members of a _module namespace object_. A module namespace object is an object that describes all exports from a module. They are accessed through a namespace import:

[source,javascript]
----
import * as fs from 'node:fs';
fs.readPath = fs.readFile; // Noncompliant: TypeError: Cannot add property readPath, object is not extensible
----

Or through the fulfillment value of a dynamic import.

[source,javascript]
----
import('node:fs').then(fs => {
  fs.readPath = fs.readFile; // Noncompliant: TypeError: Cannot add property readPath, object is not extensible
})
----

This rule will not raise an issue when a module mutates the imported object. Please be aware the mutated value can be observed by all other modules importing the same value.

[source,javascript]
----
import fs from 'node:fs';
fs.readPath = fs.readFile; // fs.default now contains readPath
----


== Resources
* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import[MDN import]
* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import#module_namespace_object[MDN Module namespace object]
* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isSealed#description[MDN Sealed Objects]
//=== Documentation
//=== Articles & blog posts
//=== Conference presentations
//=== Standards
