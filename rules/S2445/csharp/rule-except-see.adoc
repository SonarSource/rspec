Locking on a class field synchronizes not on the field itself, but on the object assigned to it. So locking on a non-``++readonly++`` field makes it possible for the field's value to change while a thread is in a block locked on the old value. That would allow a second thread, locked on the new value, to enter the block at the same time.


The story is very similar for locking on a local variable or on a new instance; two different threads running the method in parallel would lock on two different object instances, completely undermining the synchronization.


== Noncompliant Code Example

[source,csharp]
----
private string color = "red";

private void DoSomething()
{
  lock (color) // Noncompliant; lock is actually on object instance "red" referred to by the color variable
  {
    //...
    color = "green"; // other threads now allowed into this block
    // ...
  }
  lock (new object()) // Noncompliant this is a no-op.
  {
     // ...
  }
}
----


== Compliant Solution

[source,csharp]
----
private string color = "red";
private readonly object lockObj = new object();

private void DoSomething()
{
  lock (lockObj) 
  {
    //...
    color = "green";
    // ...
  }
}
----


