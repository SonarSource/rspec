This is an issue when an Angular class defines lifecycle methods like `ngOnInit()` or `ngOnDestroy()` without implementing the corresponding interfaces (`OnInit`, `OnDestroy`, etc.).

== Why is this an issue?

Angular lifecycle methods represent contracts between your component and the Angular framework. When you define methods like `ngOnInit()` or `ngOnDestroy()`, you're telling Angular that your class will handle specific lifecycle events.

Without implementing the corresponding interfaces (`OnInit`, `OnDestroy`, etc.), you lose important benefits:

* **Type Safety**: TypeScript cannot verify that your lifecycle methods have the correct signatures
* **Code Clarity**: Other developers cannot easily see which lifecycle events your class handles
* **IDE Support**: You miss out on autocompletion and refactoring assistance
* **Angular Style Guide**: This violates the official Angular style guide recommendations

The interfaces serve as explicit contracts that make your code more maintainable and less prone to errors. They also help catch typos in method names at compile time rather than runtime.

=== What is the potential impact?

Without proper interface implementation, you may encounter:

* Runtime errors if lifecycle method signatures are incorrect
* Reduced code maintainability and readability
* Missing IDE support for refactoring and autocompletion
* Potential bugs from typos in lifecycle method names that go undetected

=== How to fix in Angular?

Import and implement the appropriate lifecycle interface for your lifecycle method. For `ngOnInit()`, implement `OnInit`.

==== Non-compliant code example

[source,typescript,diff-id=1,diff-type=noncompliant]
----
@Component()
class MyComponent {
  ngOnInit() { // Noncompliant
    console.log('Component initialized');
  }
}
----

==== Compliant code example

[source,typescript,diff-id=1,diff-type=compliant]
----
import { OnInit } from '@angular/core';

@Component()
class MyComponent implements OnInit {
  ngOnInit() {
    console.log('Component initialized');
  }
}
----

For multiple lifecycle methods, implement all corresponding interfaces.

==== Non-compliant code example

[source,typescript,diff-id=2,diff-type=noncompliant]
----
@Component()
class MyComponent {
  ngOnInit() { // Noncompliant
    // initialization logic
  }
  
  ngOnDestroy() { // Noncompliant
    // cleanup logic
  }
}
----

==== Compliant code example

[source,typescript,diff-id=2,diff-type=compliant]
----
import { OnInit, OnDestroy } from '@angular/core';

@Component()
class MyComponent implements OnInit, OnDestroy {
  ngOnInit() {
    // initialization logic
  }
  
  ngOnDestroy() {
    // cleanup logic
  }
}
----

When extending a base class that already implements the interface, use the `override` keyword to indicate you're overriding the method.

==== Non-compliant code example

[source,typescript,diff-id=3,diff-type=noncompliant]
----
@Component()
class BaseComponent implements OnInit {
  ngOnInit() {
    // base logic
  }
}

@Component()
class DerivedComponent extends BaseComponent {
  ngOnInit() { // Noncompliant - missing override
    super.ngOnInit();
    // derived logic
  }
}
----

==== Compliant code example

[source,typescript,diff-id=3,diff-type=compliant]
----
@Component()
class BaseComponent implements OnInit {
  ngOnInit() {
    // base logic
  }
}

@Component()
class DerivedComponent extends BaseComponent {
  override ngOnInit() {
    super.ngOnInit();
    // derived logic
  }
}
----

=== Documentation

 * Angular Lifecycle Hooks - https://angular.dev/guide/components/lifecycle[Official Angular documentation on component lifecycle hooks]
 * Angular Style Guide - Lifecycle Interfaces - https://angular.dev/style-guide#style-09-01[Angular style guide recommendation for implementing lifecycle interfaces]
 * TypeScript Interfaces - https://www.typescriptlang.org/docs/handbook/interfaces.html[TypeScript documentation on interfaces]

