This rule raises an issue when an Angular class defines lifecycle methods (like `ngOnInit`, `ngOnDestroy`) without implementing the corresponding lifecycle interfaces (`OnInit`, `OnDestroy`).

== Why is this an issue?

Angular provides lifecycle interfaces that correspond to lifecycle methods. When a class implements a lifecycle method like `ngOnInit()`, it should also implement the corresponding `OnInit` interface.

This practice offers several benefits:

* **Type Safety**: Interfaces provide compile-time type checking, ensuring method signatures are correct
* **Code Clarity**: Explicit interfaces make the class's lifecycle dependencies obvious to other developers
* **IDE Support**: Better autocomplete, refactoring support, and error detection
* **Angular Best Practices**: Following the official Angular Style Guide recommendations

Without implementing the interfaces, you lose these benefits and may encounter runtime errors if method signatures are incorrect. The TypeScript compiler cannot verify that lifecycle methods match Angular's expected signatures.

=== What is the potential impact?

Missing lifecycle interfaces can lead to:

* Runtime errors if method signatures don't match Angular's expectations
* Reduced code maintainability and readability
* Loss of IDE support for autocomplete and refactoring
* Potential bugs when lifecycle methods are incorrectly implemented

=== How to fix in Angular?

Import and implement the corresponding lifecycle interface for each lifecycle method in your class.

==== Non-compliant code example

[source,typescript,diff-id=1,diff-type=noncompliant]
----
import { Component } from '@angular/core';

@Component({
  selector: 'app-example',
  template: '<div>Example</div>'
})
class ExampleComponent {
  ngOnInit() { // Noncompliant
    console.log('Component initialized');
  }

  ngOnDestroy() { // Noncompliant
    console.log('Component destroyed');
  }
}
----

==== Compliant code example

[source,typescript,diff-id=1,diff-type=compliant]
----
import { Component, OnInit, OnDestroy } from '@angular/core';

@Component({
  selector: 'app-example',
  template: '<div>Example</div>'
})
class ExampleComponent implements OnInit, OnDestroy {
  ngOnInit() {
    console.log('Component initialized');
  }

  ngOnDestroy() {
    console.log('Component destroyed');
  }
}
----

For classes extending other Angular classes, ensure you implement interfaces for any new lifecycle methods you add.

==== Non-compliant code example

[source,typescript,diff-id=2,diff-type=noncompliant]
----
@Component()
class DerivedComponent extends BaseComponent {
  ngOnDestroy(): void { // Noncompliant
    super.ngOnDestroy();
    // cleanup logic
  }
}
----

==== Compliant code example

[source,typescript,diff-id=2,diff-type=compliant]
----
import { OnDestroy } from '@angular/core';

@Component()
class DerivedComponent extends BaseComponent implements OnDestroy {
  override ngOnDestroy(): void {
    super.ngOnDestroy();
    // cleanup logic
  }
}
----

=== Documentation

 * Angular Lifecycle Hooks - https://angular.dev/guide/components/lifecycle[Official Angular documentation on lifecycle hooks and interfaces]
 * Angular Style Guide - Lifecycle Interfaces - https://angular.dev/style-guide#style-09-01[Angular Style Guide recommendation for implementing lifecycle interfaces]

