Partially-initialized objects are surprising to the `clasa` users
and might lead to hard-to-catch bugs.

== Why is this an issue?

In a {cpp} class,
all member variables of a type with an implicit or explicit constructor will be automatically initialized.
This is not the case for the others:
if no initialization is explicitly written,
the variable will be left uninitialized.

It is a common expectation that an object be in a fully-initialized state after its construction.
A partially initialized object breaks the common assumption that class users attach to it.

=== What is the potential impact?

This comes with all the risks associated with uninitialized variables,
and these risks propagate to all the classes using the faulty class as a type.
This is all the more surprising
that most programmers expect a constructor to correctly initialize the members of its class
(this is its raison d'Ãªtre after all).

include::../../../shared_content/cfamily/garbage_value_impact.adoc[]

=== Exceptions

Aggregate classes do not initialize most of their data members
but allow their users to use nice and flexible initialization syntax.
They will be ignored by this rule (but are the subject of S5558).

== How to fix it

To avoid partially-initialized objects,
all non `+class+`-type fields should always be initialized (in order of preference):

* With an in-class initializer
* In the initialization list of a constructor
* In the constructor body

See S3230 for more details about this order.

If none of the above places are a good fit for a data member,
ask yourself whether it belongs to this class.
Instead of a data member, it might be more appropriate to keep the value

- in a delegate class,
- in a (`static`) local variable of a member function, or
- in a parameter of a member function.

=== Code examples

==== Noncompliant code example

[source,cpp,diff-id=1,diff-type=noncompliant]
----
class C {
  int val = 42;
};

class S {
public:
  C c;
  int i;
  int j;

  S() : i(0) {} // Noncompliant: this->j is left uninitialized
  S(bool) : i(0), j(0) {}
};

class T {
public:
  S s;

  T() : s() {} // Noncompliant: s.j is left uninitialized
  T(bool b) : s(b) {}
};

class U {
public:
  T t;

  U() : t() {} // Noncompliant: t.s.j is left uninitialized
};
----

==== Compliant solution

[source,cpp,diff-id=1,diff-type=compliant]
----
class C {
  int val = 42;
};

class S_fixed {
public:
  C c;
  int i;
  int j;

  S_fixed() : i(0), j(0) {} // Compliant
  S_fixed(bool) : i(0), j(0) {}
};

class T_fixed {
public:
  S_fixed s;

  T_fixed() : s() {}  // Compliant
  T_fixed(bool b) : s(b) {}
};

class U {
public:
  T t;

  U() : t() { t.s.j = 0; }  // Compliant
};
----

== Resources

=== External coding guidelines

* {cpp} Core Guidelines - https://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#c41-a-constructor-should-create-a-fully-initialized-object[C.41: A constructor should create a fully initialized object]

=== Related rules

* S836 detects the uses of uninitialized variables.
* S3230 describes the preferred place for initializing class data members.


ifdef::env-github,rspecator-view[]

'''
== Implementation Specification
(visible only on this page)

include::../message.adoc[]

'''
== Comments And Links
(visible only on this page)

include::../comments-and-links.adoc[]

endif::env-github,rspecator-view[]
