include::../summary.adoc[]

== Why is this an issue?

include::../rationale.adoc[]

include::../impact.adoc[]

include::../exceptions.adoc[]

// How to fix it section

== How to fix it

=== Code examples

include::../common/fix/code-rationale.adoc[]

==== Noncompliant code example

[source,go,diff-id=1,diff-type=noncompliant]
----
import (
    "crypto/sha256"
    "golang.org/x/crypto/pbkdf2"
)

func example(password []byte) {
    pbkdf2.Key(password, []byte("fixedSalt"), 4096, 32, sha256.New) // Noncompliant
}
----

==== Compliant solution

[source,go,diff-id=1,diff-type=compliant]
----
import (
    "crypto/rand"
    "crypto/sha256"
    "golang.org/x/crypto/pbkdf2"
)

func example(password []byte) {
    randomSalt := make([]byte, 16)
    rand.Read(randomSalt)
    pbkdf2.Key(password, randomSalt, 4096, 32, sha256.New)
}
----

=== How does this work?

include::../common/fix/salt.adoc[]


Here, the compliant code example ensures the salt is random and has a sufficient
length by calling the `crypto.rand.Read` function. This function internally
uses a cryptographically secure pseudo-random number generator.


== Resources

include::../common/resources/standards.adoc[]

* PBKDF2 RFC - https://www.rfc-editor.org/rfc/rfc2898.html[RFC 2898 PKCS #5: Password-Based Cryptography Specification Version 2.0]
* Scrypt RFC - https://www.rfc-editor.org/rfc/rfc7914.html[RFC 7914 The scrypt Password-Based Key Derivation Function]
* Bcrypt reference - https://www.usenix.org/legacy/events/usenix99/provos/provos.pdf[Provos, N. and D. Mazieres, "A Future-Adaptable Password Scheme", USENIX 1999, June 1999]
* Argon2 RFC - https://www.rfc-editor.org/rfc/rfc9106.html#name-parameter-choice[RFC 9106
Argon2 Memory-Hard Function for Password Hashing and Proof-of-Work Applications - 4. Parameter Choice]

ifdef::env-github,rspecator-view[]

'''
== Implementation Specification
(visible only on this page)

include::../message.adoc[]

endif::env-github,rspecator-view[]
