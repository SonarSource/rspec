<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Lambdas can use variables from their enclosing scope (called "capture") either by reference or by value. Since lambdas may run asynchronously, reference capture should be used with caution because, by the time the lambda runs, the referenced variable may be out of scope, resulting in an access violation at run time.</p>
</div>
<div class="paragraph">
<p>You can specify default capture by reference (<code>[&amp;]</code>), or by value (<code>[=]</code>). Default reference capture can cause scope issues, but so can default value capture. Both forms of default capture implicitly also capture <code>*this</code>, which would automatically be used if, for example, you referenced a method from the enclosing scope.</p>
</div>
<div class="paragraph">
<p>If the lambda is used immediately (for instance, passed as an argument to <code>std::sort</code>), there is no risk of dangling reference. For those lambdas, it is safe to pass everything through a default capture by reference. See also <a data-rspec-id="S5495" class="rspec-auto-link">S5495</a>.</p>
</div>
<div class="paragraph">
<p>This rule raises an issue when default capture is used unless the lambda is immediately executed.</p>
</div>
<div class="sect2">
<h3 id="_noncompliant_code_example">Noncompliant code example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">void fun() {
  Foo foo;
  ...
  executor-&gt;Schedule([&amp;] {  // Noncompliant
    maybeMember(foo);  // implicit use of *this reference if maybeMember is a member function. foo and maybeMember may both be gone by the time this is invoked
  });
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_compliant_solution">Compliant solution</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">void fun() {
  Foo foo;
  ...
  executor-&gt;Schedule([&amp;foo] { // it is clear that foo is captured by reference and compilation is going to fail if maybeMember is a member function
    maybeMember(foo);
  });
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_related_rules">Related rules</h3>
<div class="ulist">
<ul>
<li>
<p><a data-rspec-id="S5495" class="rspec-auto-link">S5495</a> Capture by reference in lambdas used locally</p>
</li>
</ul>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_implementation_specification">Implementation Specification</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_message">Message</h3>
<div class="paragraph">
<p>Explicitly capture the required scope variables.</p>
</div>
</div>
<div class="sect2">
<h3 id="_highlighting">Highlighting</h3>
<div class="paragraph">
<p><code>[&amp;|=]</code></p>
</div>
</div>
</div>
</div>