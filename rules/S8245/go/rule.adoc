This is an issue when code uses traditional threading mechanisms instead of Go's idiomatic concurrency patterns with channels and goroutines, or when goroutines are not properly managed.

== Why is this an issue?

Go was designed with a specific concurrency philosophy: "Don't communicate by sharing memory; share memory by communicating." This principle encourages using channels for communication between goroutines rather than shared variables protected by mutexes.

When developers use traditional threading patterns in Go, they miss out on the language's built-in concurrency advantages. Mutexes and shared memory can lead to complex code that's harder to reason about and more prone to race conditions.

Additionally, improper goroutine management can cause serious problems:

* **Deadlocks** occur when channel operations block indefinitely because there's no corresponding sender or receiver
* **Goroutine leaks** happen when goroutines continue running without a way to stop them, consuming memory and CPU resources
* **Race conditions** can occur when multiple goroutines access shared data without proper synchronization

Go's channels provide a safer, more expressive way to coordinate concurrent operations. They make the flow of data explicit and help prevent many common concurrency bugs.

=== What is the potential impact?

Using improper concurrency patterns can lead to:

* **Application hangs** due to deadlocks where goroutines wait indefinitely
* **Memory leaks** from goroutines that never terminate, gradually consuming system resources
* **Race conditions** that cause unpredictable behavior and data corruption
* **Poor performance** due to excessive locking or inefficient coordination
* **Difficult debugging** as concurrency bugs are often intermittent and hard to reproduce

== How to fix it

Replace mutex-protected shared variables with channel communication. Use channels to pass data between goroutines instead of sharing memory.

=== Code examples

==== Noncompliant code example

[source,go,diff-id=1,diff-type=noncompliant]
----
var counter int
var mu sync.Mutex

func increment() {
    mu.Lock()
    counter++ // Noncompliant
    mu.Unlock()
}
----

==== Compliant solution

[source,go,diff-id=1,diff-type=compliant]
----
func worker(ch chan<- int) {
    ch <- 1
}

func main() {
    ch := make(chan int)
    go worker(ch)
    result := <-ch
}
----

== Resources

=== Documentation

 * Effective Go - Concurrency - https://go.dev/doc/effective_go#concurrency[Official Go documentation on concurrency patterns and best practices]

 * Go Blog - Share Memory By Communicating - https://go.dev/blog/codelab-share[Detailed explanation of Go's concurrency philosophy with examples]

 * Go Tour - Concurrency - https://go.dev/tour/concurrency/1[Interactive tutorial covering goroutines, channels, and concurrency patterns]
