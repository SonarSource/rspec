This rule raises an issue if the division of `sizeof` is used to compute the size of an array,
that could be replaced with `std::size` or `std::ranges::size` (since {cpp}20).

== Why is this an issue?

The `C` array does not expose the number of elements as a data member or a member function.
This information is present in the type system.

In {cpp} it can be extracted by calling `std::size` (introduced in {cpp}17) or `std::ranges::size` (introduced in {cpp}20),
as above functions supports C-arrays in addition to containers and ranges.

An alternative, which is supported also in C, is to divide the size of the array by the size of the element type.
Using this solution does not convey the intent of the code,
and may be prone to producing incorrect values when the element type is changed,
but the `sizeof` code was not updated.

This rule raises an issue when the division of `sizeof` is used to compute a number of elements in the array.

=== Code examples

==== Noncompliant code example

[source,cpp,diff-id=1,diff-type=noncompliant]
----
int carr[10]; 

void process() {
  std::size_t size = sizeof(carr) / sizeof(int); // Non-compliant
}
----

==== Compliant solution

[source,cpp,diff-id=1,diff-type=compliant]
----
int carr[10]; 

void process() {
  std::size_t size = std::size(carr); // Compliant
}
----

The rule also detects cases when the `sizeof` division is expanded from the macro:

==== Noncompliant code example

[source,cpp,diff-id=2,diff-type=noncompliant]
----
#define ARRAY_SIZE(arr) sizeof(arr) / sizeof((arr)[0])

int carr[10]; 

void process() {
  std::size_t size = ARRAY_SIZE(carr); // Non-compliant
}
----

==== Compliant solution

[source,cpp,diff-id=2,diff-type=compliant]
----
#define ARRAY_SIZE(arr) sizeof(arr) / sizeof((arr)[0])

int carr[10]; 

void process() {
  std::size_t size = std::size(carr); // Compliant
}
----

=== `std::array` is also covered

This rule will also raise issue when the `sizeof` division, 
is used to compute the size of the `std::array` type.

Such code may be leftover from the replacement of C-array,
without updating all necessary call sides (see S5954).

==== Noncompliant code example

[source,cpp,diff-id=3,diff-type=noncompliant]
----
#define ARRAY_SIZE(arr) sizeof(arr) / sizeof((arr)[0])

std::array<int, 10> arr; 

void process() {
  std::size_t size1 = sizeof(arr) / sizeof(int); // Non-compliant
  std::size_t size2 = ARRAY_SIZE(arr); // Non-compliant
}
----

==== Compliant solution

[source,cpp,diff-id=3,diff-type=compliant]
----
#define array_size(arr) sizeof(arr) / sizeof((arr)[0])

std::array<int, 10> arr; 

void process() {
  std::size_t size1 = std::size(arr); // Compliant
  std::size_t size2 = std::size(arr); // Compliant
}
----

Alternatively, the `size` member function may be invoked in a non-generic code.

[source,cpp]
----
#define array_size(arr) sizeof(arr) / sizeof((arr)[0])

std::array<int, 10> arr; 

void process() {
  std::size_t size1 = arr.size(); // Compliant
  std::size_t size2 = arr.size(); // Compliant
}
----

=== How does this work?

The implementation of `std::size` for arrays, relies on template argument deduction,
to deduce the size of the array from the parameter that has reference to array type:

[source,cpp]
----
template<typename T, std::size_t N>
constexpr N my_size(T const& (arr)[N]) {
  return N;
}

int arr[10];
std::size_t s = my_size(arr); // Deduces: "N" == 10
----

== Resources

=== Related rules

* S5945 - suggest replacing C-arrays with `std::array` and `std::vector`

