<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This rule raises an issue if a division of <code>sizeof</code> is used to compute the size of an array,
that could be replaced with <code>std::size</code> or <code>std::ranges::size</code> (since C&#43;&#43;20).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>C-arrays do not expose their number of elements as a data member or a member function.
This information is present in the type system.</p>
</div>
<div class="paragraph">
<p>In C&#43;&#43; it can be extracted by calling <code>std::size</code> (introduced in C&#43;&#43;17) or <code>std::ranges::size</code> (introduced in C&#43;&#43;20),
as these functions support C-arrays in addition to containers and ranges.</p>
</div>
<div class="paragraph">
<p>The historical way, inherited from C, is to divide the size of the array by the size of the element type.
However, using this solution does not convey the intent of the code as clearly,
and is prone to producing incorrect values when:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the element type is changed but the <code>sizeof</code> code was not updated,</p>
</li>
<li>
<p><code>sizeof</code> was applied to pointer produced from array decay instead of the array itself.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This rule raises an issue when the division of <code>sizeof</code> is used to compute the number of elements in an array.</p>
</div>
<div class="sect2">
<h3 id="_code_examples">Code examples</h3>
<div class="sect3">
<h4 id="_noncompliant_code_example">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">int carr[10];

void process() {
  std::size_t size = sizeof(carr) / sizeof(int); // Noncompliant
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">int carr[10];

void process() {
  std::size_t size = std::size(carr); // Compliant
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The rule also detects cases where the <code>sizeof</code> division is expanded from a macro:</p>
</div>
</div>
<div class="sect3">
<h4 id="_noncompliant_code_example_2">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#define ARRAY_SIZE(arr) sizeof(arr) / sizeof((arr)[0])

int carr[10];

void process() {
  std::size_t size = ARRAY_SIZE(carr); // Noncompliant
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution_2">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#define ARRAY_SIZE(arr) sizeof(arr) / sizeof((arr)[0])

int carr[10];

void process() {
  std::size_t size = std::size(carr); // Compliant
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Once all uses of the <code>ARRAY_SIZE</code> macro have been removed, the macro should also be removed.
However doing so is not required to address the issues raised by this rule,
as this allows code the be fixed incrementally.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_stdarray_is_also_covered"><code>std::array</code> is also covered</h3>
<div class="paragraph">
<p>This rule will also raise an issue when the <code>sizeof</code> division,
is used to compute the size of the <code>std::array</code> type.</p>
</div>
<div class="paragraph">
<p>Such code may be leftover from the replacement of C-array,
without updating all necessary call sites (see <a data-rspec-id="S5954" class="rspec-auto-link">S5954</a>).</p>
</div>
<div class="sect3">
<h4 id="_noncompliant_code_example_3">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#define ARRAY_SIZE(arr) sizeof(arr) / sizeof((arr)[0])

std::array&lt;int, 10&gt; arr;

void process() {
  std::size_t size1 = sizeof(arr) / sizeof(int); // Noncompliant
  std::size_t size2 = ARRAY_SIZE(arr); // Noncompliant
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution_3">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#define ARRAY_SIZE(arr) sizeof(arr) / sizeof((arr)[0])

std::array&lt;int, 10&gt; arr;

void process() {
  std::size_t size1 = std::size(arr); // Compliant
  std::size_t size2 = std::size(arr); // Compliant
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively, the <code>size</code> member function may be invoked in a non-generic code.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#define ARRAY_SIZE(arr) sizeof(arr) / sizeof((arr)[0])

std::array&lt;int, 10&gt; arr;

void process() {
  std::size_t size1 = arr.size(); // Compliant
  std::size_t size2 = arr.size(); // Compliant
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_how_does_this_work">How does this work?</h3>
<div class="paragraph">
<p>The implementation of <code>std::size</code> for arrays relies on template argument deduction
to deduce the size of the array from the parameter that references an array type:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">template&lt;typename T, std::size_t N&gt;
constexpr N my_size(T const&amp; (arr)[N]) {
  return N;
}

int arr[10];
std::size_t s = my_size(arr); // Deduces: "N" == 10</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_related_rules">Related rules</h3>
<div class="ulist">
<ul>
<li>
<p><a data-rspec-id="S5945" class="rspec-auto-link">S5945</a> - suggest replacing C-arrays with <code>std::array</code> and <code>std::vector</code></p>
</li>
</ul>
</div>
</div>
</div>
</div>