This rule raises an issue when a generic exception (such as `Exception`, `SystemException`, `ApplicationException`, `IndexOutOfRangeException`, `NullReferenceException`, `OutOfMemoryException` or `ExecutionEngineException`) is thrown.

== Why is this an issue?

Throwing generic exceptions such as ``++Exception++``, ``++SystemException++``, ``++ApplicationException++``, ``++IndexOutOfRangeException++``, `NullReferenceException`, `OutOfMemoryException` or `ExecutionEngineException` will have a negative impact on any code trying to catch these exceptions.

When working with a generic type of exception, the only way to distinguish between multiple exceptions is to check their message, which is error-prone and difficult to maintain.

From a consumer perspective, it is generally a best practice to only catch exceptions you intend to handle. Other exceptions should ideally be let to propagate up the stack trace so that they can be dealt with appropriately. When a generic exception is thrown, it forces consumers to catch exceptions they do not intend to handle, which they then have to re-throw.

At best, this makes the code hard to understand and maintain. At worst, legitimate exceptions may be unintentionally silenced and errors may be hidden. For instance, if an exception such as `StackOverflowException` is caught and not re-thrown, it may prevent the program from terminating gracefully.

When throwing an exception, it is therefore recommended to throw the most specific exception possible so that it can be handled intentionally by consumers.

== How to fix it

To fix this issue, make sure to throw specific exceptions that are relevant to the context in which they arise. It is recommended to either:

* Throw a subtype of `++Exception++`` when one matches. For instance ``++InvalidArgumentException++`` could be raised when an unexpected argument is provided to a function.
* Define a custom exception type that derives from `++Exception++`` or one of its subclasses.


=== Code examples

==== Noncompliant code example

[source,csharp,diff-id=1,diff-type=noncompliant]
----
public void DoSomething(object obj)
{
  if (obj == null)
  {
    throw new NullReferenceException("obj");  // Noncompliant: This will be difficult for consumers to handle
  }
  // ...
}
----

==== Compliant solution

[source,csharp,diff-id=1,diff-type=compliant]
----
public void DoSomething(object obj)
{
  if (obj == null)
  {
    throw new ArgumentNullException("obj");
  }
  // ...
}
----

include::../see.adoc[]

ifdef::env-github,rspecator-view[]

'''
== Implementation Specification
(visible only on this page)

=== Message

include::../message.adoc[]


'''
== Comments And Links
(visible only on this page)

=== on 4 Feb 2015, 14:28:31 Ann Campbell wrote:
Gendarme: DoNotThrowReservedExceptionRule

=== on 11 May 2015, 11:52:58 Dinesh Bolkensteyn wrote:
\[~ann.campbell.2] Replacing "using" by "throwing" in the description - is catching also using?

=== on 11 May 2015, 12:03:32 Dinesh Bolkensteyn wrote:
\[~ann.campbell.2] I've also applied the C# style to the code example. This rule LGTM now.

=== on 11 May 2015, 13:51:45 Ann Campbell wrote:
Agreed [~dinesh.bolkensteyn] "throwing" is better than "using" here.

include::../comments-and-links.adoc[]

endif::env-github,rspecator-view[]
