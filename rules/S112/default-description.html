<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This rule raises an issue when a generic exception (such as <code>std::exception</code>, <code>std::logic_error</code> or <code>std::runtime_error</code>) is thrown.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Throwing generic exceptions such as <code>std::exception</code>, <code>std::logic_error</code> and <code>std::runtime_error</code> will have a negative impact on any code trying to catch these exceptions.</p>
</div>
<div class="paragraph">
<p>From a consumer perspective, it is generally a best practice to only catch exceptions you intend to handle. Other exceptions should ideally not be caught and let propagate up the stack trace so that they can be dealt with appropriately. When a generic exception is thrown, it forces consumers to catch exceptions they do not intend to handle, which they then have to re-throw.</p>
</div>
<div class="paragraph">
<p>Besides, when working with a generic type of exception, the only way to distinguish between multiple exceptions is to check their message, which is error-prone and difficult to maintain. Legitimate exceptions may be unintentionally silenced and errors may be hidden.</p>
</div>
<div class="paragraph">
<p>For instance, in the following code, the fact that <code>checkState</code> throws a generic exception leads us to catch a permission error that shouldn&#8217;t have been caught:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">void openFile(File&amp; file) {
  if (!has_permissions(file)) {
    throw std::invalid_argument("Couldn't open file");
  }
  // ...
}

void checkState(File const&amp; file) {
  if (!file.is_valid()) {
    throw std::exception();  // Noncompliant
  }
  // ...
}

void test(File file) {
  try {
    openFile(file);
    checkState(false);
    closeFile(file);
  } catch (std::exception&amp; s) {
    // If we don't have the correct permissions to open, the
    // invalid_argument exception will be caught and we will try closing a
    // file that was never opened
    closeFile(file);
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Therefore, throwing the most specific exception possible is recommended so consumers can handle it intentionally.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_fix_it">How to fix it</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To fix this issue, make sure to throw specific exceptions that are relevant to the context in which they arise. It is recommended to either:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Throw a subtype of <code>std::exception</code> when one matches. For instance, <code>std::invalid_argument</code> could be raised when an unexpected argument is provided to a function.</p>
</li>
<li>
<p>Define a custom exception type that derives from <code>std::exception</code> or one of its subclasses.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_code_examples">Code examples</h3>
<div class="sect3">
<h4 id="_noncompliant_code_example">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#include &lt;stdexcept&gt;

void checkState(S state) {
    if (!state.is_valid()) {
        throw std::exception("State is invalid"); // Noncompliant: this will be difficult for consumers to handle
    }
    // ...
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution">Compliant solution</h4>
<div class="paragraph">
<p>The solution below involves throwing <code>std::invalid_argument</code>, which is an appropriate exception type for this situation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#include &lt;stdexcept&gt;

void checkState(S state) {
    if (!state.is_valid()) {
        throw std::invalid_argument("State is invalid"); // Compliant
    }
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively, one can define a custom <code>invalid_state</code> exception that can be caught specifically:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">struct invalid_state : public std::exception {};

void checkState(S state) {
    if (!state.is_valid()) {
        throw invalide_state(); // Compliant
    }
    // ...
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_standards">Standards</h3>
<div class="ulist">
<ul>
<li>
<p>CWE - <a href="https://cwe.mitre.org/data/definitions/397">CWE-397 Declaration of Throws for Generic Exception</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_external_coding_guidelines">External coding guidelines</h3>
<div class="ulist">
<ul>
<li>
<p>C++ Core Guidelines - <a href="https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#e14-use-purpose-designed-user-defined-types-as-exceptions-not-built-in-types">E.14: Use purpose-designed user-defined types as exceptions (not built-in types)</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_related_rules">Related rules</h3>
<div class="ulist">
<ul>
<li>
<p><a data-rspec-id="S1181" class="rspec-auto-link">S1181</a> - Generic exceptions should not be caught</p>
</li>
</ul>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_implementation_specification">Implementation Specification</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_message">Message</h3>
<div class="paragraph">
<p>Define and throw a dedicated exception instead of using a generic one.</p>
</div>
<hr>
</div>
</div>
</div>