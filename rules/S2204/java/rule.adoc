``++AtomicInteger++``, and ``++AtomicLong++`` extend ``++Number++``, but they're distinct from ``++Integer++`` and ``++Long++`` and should be handled differently. ``++AtomicInteger++`` and ``++AtomicLong++`` are designed to support lock-free, thread-safe programming on single variables. As such, an ``++AtomicInteger++`` will only ever be "equal" to itself. Instead, you should ``++.get()++`` the value and make comparisons on it.


This applies to all the atomic, seeming-primitive wrapper classes: ``++AtomicInteger++``, ``++AtomicLong++``, and ``++AtomicBoolean++``.


== Noncompliant Code Example

----
AtomicInteger aInt1 = new AtomicInteger(0);
AtomicInteger aInt2 = new AtomicInteger(0);

if (aInt1.equals(aInt2)) { ... }  // Noncompliant
----


== Compliant Solution

----
AtomicInteger aInt1 = new AtomicInteger(0);
AtomicInteger aInt2 = new AtomicInteger(0);

if (aInt1.get() == aInt2.get()) { ... }
----


ifdef::env-github,rspecator-view[]

'''
== Implementation Specification
(visible only on this page)

include::message.adoc[]

endif::env-github,rspecator-view[]
