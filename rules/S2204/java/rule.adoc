== Why is this an issue?

``++AtomicInteger++``, and ``++AtomicLong++`` extend ``++Number++``, but they're distinct from ``++Integer++`` and ``++Long++`` and should be handled differently. ``++AtomicInteger++`` and ``++AtomicLong++`` are designed to support lock-free, thread-safe programming on single variables. As such, an ``++AtomicInteger++`` will only ever be "equal" to itself. Instead, you should ``++.get()++`` the value and make comparisons on it.


This applies to all the atomic, seeming-primitive wrapper classes: ``++AtomicInteger++``, ``++AtomicLong++``, and ``++AtomicBoolean++``.


=== Noncompliant code example

[source,java]
----
AtomicInteger aInt1 = new AtomicInteger(0);
AtomicInteger aInt2 = new AtomicInteger(0);

if (aInt1.equals(aInt2)) { ... }  // Noncompliant
----


=== Compliant solution

[source,java]
----
AtomicInteger aInt1 = new AtomicInteger(0);
AtomicInteger aInt2 = new AtomicInteger(0);

if (aInt1.get() == aInt2.get()) { ... }
----


ifdef::env-github,rspecator-view[]

'''
== Implementation Specification
(visible only on this page)

=== Message

Use ".get()" to retrieve the value and compare it instead.


endif::env-github,rspecator-view[]
