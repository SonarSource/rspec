<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Constructors should not be asynchronous because they are meant to initialize an instance of a class synchronously. While you can technically run a promise in a constructor, the instance will be returned before the asynchronous operation completes, which can lead to potential issues if the rest of your code expects the object to be fully initialized. While returning the promise may seem the solution for this problem, it is not standard practice and can lead to unexpected behavior. Returning a promise (or, in general, any object from another class) from a constructor can be misleading and is considered a bad practice as this leads to unexpected results with inheritance and the <code>instanceof</code> operator.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">class MyClass {
  constructor() {
    Promise.resolve().then(() =&gt; this.data = fetchData()); // Noncompliant, this.data will be undefined in the new instance
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Instead, you can create an asynchronous method that performs the necessary asynchronous operations after the object has been constructed</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">class MyClass {
  constructor() {
    this.data = null;
  }

  async initialize() {
    this.data = await fetchData();
  }
}

(async () =&gt; {
  const myObject = new MyClass();
  await myObject.initialize();
})();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Otherwise, you can use a static factory method that returns a promise resolving to an instance of the class after performing the asynchronous operations.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">class MyClass {
  constructor(data) {
    this.data = data;
  }

  static async create() {
    const data = await fetchData();
    return new MyClass(data);
  }
}

(async () =&gt; {
  const myObject = await MyClass.create();
})();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using an asynchronous factory function or an initialization method provides a more conventional, readable, and maintainable approach to handling asynchronous initialization in JavaScript.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_documentation">Documentation</h3>
<div class="ulist">
<ul>
<li>
<p>MDN web docs - <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new">new</a></p>
</li>
<li>
<p>MDN web docs - <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise</a></p>
</li>
<li>
<p>MDN web docs - <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof">instanceof</a></p>
</li>
<li>
<p>MDN web docs - <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain">Inheritance and the prototype chain</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>