== Why is this an issue?

According to the Java API documentation:

____
There are two ways to create a new thread of execution. One is to declare a class to be a subclass of Thread. This subclass should override the run method of class Thread. An instance of the subclass can then be allocated and started...

The other way to create a thread is to declare a class that implements the Runnable interface. That class then implements the run method. An instance of the class can then be allocated, passed as an argument when creating Thread, and started.

____

By definition, extending the Thread class without overriding the ``++run++`` method doesn't make sense, and implies that the contract of the ``++Thread++`` class is not well understood.


=== Noncompliant code example

[source,java]
----
public class MyRunner extends Thread { // Noncompliant; run method not overridden

  public void doSometing() {...}
}  
----


=== Exceptions

If ``++run()++`` is not overridden in a class extending ``++Thread++``, it means that starting the thread will actually call ``++Thread.run()++``. However, ``++Thread.run()++`` does nothing if it has not been fed with a target ``++Runnable++``. The rule consequently ignore classes extending ``++Thread++`` if they are calling, in their constructors, the ``++super(...)++`` constructor with a proper ``++Runnable++`` target.


[source,java]
----
class MyThread extends Thread { // Compliant - calling super constructor with a Runnable
  MyThread(Runnable target) {
    super(target); // calling super constructor with a Runnable, which will be used for when Thread.run() is executed
    // ...
  }
}
----



ifdef::env-github,rspecator-view[]

'''
== Implementation Specification
(visible only on this page)

=== Message

Don't extend "Thread", since the "run" method is not overridden.


'''
== Comments And Links
(visible only on this page)

=== on 10 Oct 2014, 11:14:05 Freddy Mallet wrote:
My 2 cents @Ann, I would:

* Replace the tag "performance" by "bug"
* Replace the category "Efficiency" by "Reliability"

Moreover, I would recommend the following remediation action:

* Make MyRunner directly implements the Runnable interface
* Then create and launch a thread like this : "new Thread(new MyRunner()).start()"

=== on 10 Oct 2014, 18:25:43 Ann Campbell wrote:
\[~freddy.mallet] I've implemented your first 2 suggestions, but the last 2 confused me.


I think the emphasis of this rule was itself confused. The title addressed the ``++Runnable++`` but the description was about the class that created an instance of a vacuous ``++Runnable++``. I've updated the description and code samples to move the emphasis to the empty ``++Runnable++``. Please let me know if you feel changes are still needed.

=== on 11 Oct 2014, 12:23:51 Freddy Mallet wrote:
\[~ann.campbell.2], there are two ways to implement a thread :

____
One is to declare a class to be a subclass of Thread. This subclass should override the run method of class Thread. An instance of the subclass can then be allocated and started

The other way to create a thread is to declare a class that implements the Runnable interface. That class then implements the run method. An instance of the class can then be allocated, passed as an argument when creating Thread, and started

____

In term of separation of concerns, the second approach is definitely the best one. Moreover with this second approach it's simply impossible to forget to implement the run() method whereas when extending the Thread class, nothing compel you to override the Thread.run() method. 

=== on 14 Oct 2014, 20:25:42 Freddy Mallet wrote:
I'm sorry @Ann, but I'm going to rework this rule.

=== on 12 Jun 2015, 15:18:36 Ann Campbell wrote:
CodePro: No Run Method

endif::env-github,rspecator-view[]
