<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Code should not rely on features beyond the configured C&#43;&#43; standard</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Relying on features that are not part of the configured C&#43;&#43; standard leads to non-portable builds and fragile code. Some toolchains accept such code as extensions or for backward compatibility, while others strictly reject it under the same standard setting. This rule flags:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Uses of features from future C&#43;&#43; standards (compared to the configured standard).</p>
</li>
<li>
<p>Uses of features removed in the configured C&#43;&#43; standard.</p>
</li>
<li>
<p>Uses of C-only constructs that some C&#43;&#43; implementations accept as extensions.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Keeping code within the configured standard ensures consistency across compilers and prevents accidental lock-in to permissive extensions. Check the list of related rules for focused rules that report specific compiler extension cases; <a data-rspec-id="S8216" class="rspec-auto-link">S8216</a> covers remaining standard violations not addressed by these specialized rules.</p>
</div>
<div class="paragraph">
<p>This version primarily reports extensions starting from C&#43;&#43;20 and later. For example, it does not yet report use of a C&#43;&#43;17-only feature when the configured standard is C&#43;&#43;14. This limitation is temporary and will be addressed in a future update.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_fix_it">How to fix it</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Replace uses of out-of-scope features with standard-conforming alternatives that exist in the configured C&#43;&#43; standard. If the newer feature (or a removed feature) is truly required, upgrade (or align) the projectâ€™s configured standard and all toolchains consistently.</p>
</div>
<div class="sect2">
<h3 id="_defaulted_comparison_operators">Defaulted comparison operators</h3>
<div class="paragraph">
<p>Defaulted comparison operators are introduced in C&#43;&#43;20. When the configured standard is earlier than C&#43;&#43;20, using defaulted comparison operators is noncompliant. Under C&#43;&#43;20 or later, the same code is compliant.</p>
</div>
<div class="sect3">
<h4 id="_noncompliant_code_example">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">struct Account {
  int id;
  bool operator==(const Account&amp;) const = default; // Noncompliant before C++20
};</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">struct Account {
  int id;
  bool operator==(const Account&amp; other) const { return id == other.id; }
};</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_using_enum_declaration">Using enum declaration</h3>
<div class="paragraph">
<p>The "using enum" declaration is a C&#43;&#43;20 feature. When the configured standard is earlier than C&#43;&#43;20, it is noncompliant to rely on it. Under C&#43;&#43;20 or later, the same code is compliant.</p>
</div>
<div class="sect3">
<h4 id="_noncompliant_code_example_2">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">enum class Status { Ok, Error };
using enum Status; // Noncompliant before C++20
auto s = Ok;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution_2">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">enum class Status { Ok, Error };
auto s = Status::Ok;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_lambda_template_parameter_list">Lambda template parameter list</h3>
<div class="paragraph">
<p>Lambda template parameter lists are available starting in C&#43;&#43;20. When the configured standard is earlier than C&#43;&#43;20, this usage is noncompliant. Under C&#43;&#43;20 or later, the same code is compliant.</p>
</div>
<div class="sect3">
<h4 id="_noncompliant_code_example_3">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">auto mapValue = []&lt;typename T&gt;(T t) { return t; }; // Noncompliant before C++20</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution_3">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">auto mapValue = [](auto t) { return t; };</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_c_array_designators_in_c">C array designators in C&#43;&#43;</h3>
<div class="paragraph">
<p>Some C-only constructs, such as array designators, may be accepted by C&#43;&#43; compilers as extensions, but they are not part of the C&#43;&#43; standard and should be avoided in C&#43;&#43; code.</p>
</div>
<div class="sect3">
<h4 id="_noncompliant_code_example_4">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">int values[3] = { [1] = 5 }; // Noncompliant in C++</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution_4">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">int values[3] = {};
values[1] = 5;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_stdbind1st_and_stdbind2nd">std::bind1st and std::bind2nd</h3>
<div class="paragraph">
<p>The <code>std::bind1st</code> and <code>std::bind2nd</code> function templates were deprecated in C&#43;&#43;11 and removed in C&#43;&#43;17. When the configured standard is C&#43;&#43;17 or later, using these functions is noncompliant. Under earlier standards, the same code may be compliant but is still deprecated.</p>
</div>
<div class="sect3">
<h4 id="_noncompliant_code_example_5">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#include &lt;functional&gt;

auto bound = std::bind1st(std::greater&lt;int&gt;(), 5); // Noncompliant in C++17 or later
auto result = bound(3); // Returns true (5 &gt; 3)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution_5">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#include &lt;functional&gt;

auto bound = std::bind(std::greater&lt;int&gt;(), 5, std::placeholders::_1);
auto result = bound(3); // Returns true (5 &gt; 3)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or use a lambda expression:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">auto bound = [](int x) { return std::greater&lt;int&gt;()(5, x); };
auto result = bound(3); // Returns true (5 &gt; 3)</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_related_rules">Related rules</h3>
<div class="ulist">
<ul>
<li>
<p><a data-rspec-id="S3715" class="rspec-auto-link">S3715</a> - GNU extensions should not be used</p>
</li>
<li>
<p><a data-rspec-id="S8230" class="rspec-auto-link">S8230</a> - MSVC-specific extensions should not be used</p>
</li>
<li>
<p><a data-rspec-id="S8231" class="rspec-auto-link">S8231</a> - Non-standard attributes should not be used</p>
</li>
<li>
<p><a data-rspec-id="S3731" class="rspec-auto-link">S3731</a> reports usages of <code>auto</code> as a storage class specifier, which was removed in C&#43;&#43;11</p>
</li>
<li>
<p><a data-rspec-id="S7129" class="rspec-auto-link">S7129</a> reports assignments of string literals to mutable char pointers, which is allowed only before C&#43;&#43;11</p>
</li>
<li>
<p><a data-rspec-id="S6172" class="rspec-auto-link">S6172</a> - Designated initializers should be used in their C&#43;&#43; compliant form</p>
</li>
<li>
<p><a data-rspec-id="S2754" class="rspec-auto-link">S2754</a> - Declarations should not be empty</p>
</li>
<li>
<p><a data-rspec-id="S796" class="rspec-auto-link">S796</a> - Only escape sequences defined in the ISO C standard should be used</p>
</li>
<li>
<p><a data-rspec-id="S3689" class="rspec-auto-link">S3689</a> - Declaration specifiers should not be redundant</p>
</li>
<li>
<p><a data-rspec-id="S2324" class="rspec-auto-link">S2324</a> - Flexible array members should not be declared</p>
</li>
<li>
<p><a data-rspec-id="S4997" class="rspec-auto-link">S4997</a> reports usages of <code>std::auto_ptr</code>, which was removed in C&#43;&#43;17</p>
</li>
<li>
<p><a data-rspec-id="S2668" class="rspec-auto-link">S2668</a> reports usages of the increment operator on a <code>bool</code> variable, which was removed in C&#43;&#43;17</p>
</li>
<li>
<p><a data-rspec-id="S3522" class="rspec-auto-link">S3522</a> reports usages of the <code>register</code> storage class specifier, which was removed in C&#43;&#43;17</p>
</li>
<li>
<p><a data-rspec-id="S5020" class="rspec-auto-link">S5020</a> - Facilities in &lt;random&gt; should be used instead of "srand", "rand" and "random_shuffle"</p>
</li>
<li>
<p><a data-rspec-id="S2260" class="rspec-auto-link">S2260</a> tracks parsing failures and can help identify compiler-specific extensions that the analyzer fails to recognize</p>
</li>
</ul>
</div>
</div>
</div>
</div>