== Why is this an issue?

`std::format` and the related formatting functions provide two different options to pad numerical values up to a specific width:

* Custom character padding. +
  It can be applied to many types and allows alignment.
  For example, `std::format("{:*>5}", num);` aligns `num` to the right (`>`) by inserting as many `*` characters as necessary to reach a width of 5.

* Numeric padding with `0`. +
  It can be applied to most arithmetic types by adding `0` just before the width.
  For example, `std::format("{:05}", num);` adds enough `0` before `num` to align it to the right to reach a width of 5.

Padding negative numeric values to the right results in surprising outputs:

[source,cpp]
----
// Noncompliant: the use of character padding results in "00-10 00-1."
std::format("{:0>5} {:0>#5}", -10, -1.0);

// Compliant: use numeric padding to produce "-0010 -001."
std::format("{:05} {:#05}", -10, -1.0);
----

This rule raises an issue when a format specification uses `0` as a custom padding character to right-align a value instead of using the numeric padding.

== Resources

=== Related rules

S6483 detects incompatible use of numeric and character padding specifiers.
