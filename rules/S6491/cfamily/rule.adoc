== Why is this an issue?

`std::format` and the related formatting functions provide two different options to pad numerical values up to a specific width:

* Custom character padding: it applies to many types and can align the text to the left, the center, or the right. +
  For example, `std::format("{:*>5}", num)` aligns `num` to the right (`>`) by inserting as many `*` characters as necessary to reach a width of 5.

* Numeric padding with `0`: it applies to most arithmetic types by adding `0` before the width specifier. +
  For example, `std::format("{:05}", num)` adds enough `0` before `num` to align it to the right to reach a width of 5.

`0` can also be used as a custom character padding.
Not only is the syntax confusing but the results are also surprising when aligning native values to the right:

[source,cpp]
----
// Noncompliant: the use of character padding results in "00-10"
std::format("{:0>5}", -10) // "0" is a custom character padding here.

// Compliant: use numeric padding to produce "-0010"
std::format("{:05}", -10) // The ">" was removed; "0" now means numeric padding.
----

== How to fix it

This rule raises an issue when a format specification uses `0` as a custom padding character to right-align a value instead of using the numeric padding.

=== Code examples

Numeric padding also works as expected with other specifiers to change the type representation, set the precision, apply locale-specific formatting, etc.

The following example illustrates the difference in padding behaviors when a sign specifier (such as `{plus}`) and the alternative form (`#`) are used to format the floating-point variable `num`.

==== Noncompliant code example

[source,cpp,diff-id=1,diff-type=noncompliant]
----
auto stringify(float num) {
  return std::format("{:0>+#5", num); // Custom character padding with "0"
}
----

==== Compliant solution

A compliant solution is to remove the alignment specifier (`>`) and move the `0` right before the width specifier (`5`) to change its semantics:

[source,cpp,diff-id=1,diff-type=compliant]
----
auto stringify(float num) {
  return std::format("{:+#05}", num); // Numeric padding.
}
----

Here are some examples of outputs for these two code snippets:

[cols="1,1,1"]
|===
| Value of `num` | Noncompliant output | Compliant output

| `10`
| `"0+10."`
| `"+010."`

| `-10`
| `"0-10."`
| `"-010."`

| `NAN`
| `"0+nan"`
| `" +nan"`

| `-INFINITY`
| `"0-inf"`
| `" -inf"`

|===

== Resources

=== Related rules

S6483 detects incompatible use of numeric and character padding specifiers.
