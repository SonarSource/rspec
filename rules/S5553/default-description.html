<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">
<div class="paragraph">
<p>References and pointers to temporary objects become dangling after these objects are destroyed.
Barring lifetime extension, this happens at the end of a full expression.</p>
</div>
<div class="paragraph">
<p>Lifetime extension allows even after the end of a full expression the use  of
the temporaries that are bound to <code>const</code> references but only if they are bound directly.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You can create a temporary object as part of the evaluation of an expression.</p>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">int getOffset(int i) {
  int x = std::vector{10, 20, 30}[i] / (i + 1);
  return x +std::stoi("15");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The code above contains two full expressions (declaration of <code>i</code> and <code>return</code>), each contains a temporary:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>std::vector{10, 20, 30}</code> is a temporary vector created in-place, and accessed directly.</p>
</li>
<li>
<p><code>"15"</code> is implicitly converted to temporary <code>std::string{"15"}</code> because <code>std::stoi</code> accepts <code>std::string const&amp;</code> as an argument.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A temporary object remains valid throughout the single full expression where it was created.
It is reclaimed and destroyed (for nontrivial objects) at the end of it.</p>
</div>
<div class="paragraph">
<p>If after the end of a full expression, some references or pointers still refer to a temporary object
they immediately become dangling, unless the lifetime of the temporary object is extended (see <a href="#exceptions">Exceptions</a>).</p>
</div>
<div class="paragraph">
<p>Dereferencing and even copying such dangling pointers or references causes <strong>undefined behavior</strong>.</p>
</div>
<div class="sect2">
<h3 id="exceptions">Exceptions</h3>
<div class="paragraph">
<p>A reference-to-<code>const</code> directly bound to a temporary object extends the lifetime of this object.
The object enjoys the same lifetime as the reference it is bound to.</p>
</div>
<div class="paragraph">
<p>However, lifetime extension is not transitive.
If the definition of the temporary relies on another temporary,
this second temporary will still be destroyed at the end of the full expression,
creating an immediately dangling reference.</p>
</div>
</div>
<div class="sect2">
<h3 id="_what_is_the_potential_impact">What is the potential impact?</h3>
<div class="paragraph">
<p>Accessing a dangling reference or pointer causes undefined behavior.
This means the compiler is not bound by the language standard anymore and your program has no meaning assigned to it.</p>
</div>
<div class="paragraph">
<p>Practically this has a wide range of effects.
In many cases, the access works by accident and succeeds at writing or reading a value.
However, it can start misbehaving at any time.
If compilation flags, compiler, platform, or runtime environment change,
the same code can crash the application, corrupt memory, or leak a secret.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_fix_it">How to fix it</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You can either copy the temporary object immediately,
allocate it on the stack (as a local variable),
on the heap, or as a static object.</p>
</div>
<div class="sect2">
<h3 id="_code_examples">Code examples</h3>
<div class="sect3">
<h4 id="_noncompliant_code_example">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#include &lt;vector&gt;
#include &lt;optional&gt;

int f(int i) {
  // r-value references can also be dangling
  int &amp;&amp;rval = *std::optional&lt;int&gt;(i);  // Noncompliant: rval is an immediately dangling reference
  return rval; // dereferencing a dangling reference
}

int main() {
    //The vector is a temporary object,
    // and binding a reference to its first element will not extend the vector lifetime
    auto const &amp;val = std::vector{1, 2, 3}[0]; // Noncompliant: val is an immediately dangling reference
    return f(val);
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#include &lt;vector&gt;
#include &lt;optional&gt;

int f(int i) {
  int rval = *std::optional&lt;int&gt;(i);  // Compliant, rval copies the temporary
  return rval;
}

auto const commonIndexValues = std::vector{1, 2, 3};

int main() {
    auto const &amp;val = commonIndexValues[0]; // Compliant, commonIndexValues is a global constant
    return f(val);
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_noncompliant_code_example_2">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#include &lt;vector&gt;

class Stats {
    std::vector&lt;int&gt; playerScores;
  public:
    std::vector&lt;int&gt; const&amp; getPlayerScores() const {
      return playerScores;
    }
};

Stats getStats();

int getTotalScore() {
  int sum = 0;
  // getStats() returns a temporary that is reclaimed before the loop begins
  // Even though internally the range-based for loop takes a const reference to a subobject of a temporary,
  // it is not lifetime-extended, because the subobject reference is obtained indirectly
  for (auto score : getStats().getPlayerScores()) { // Noncompliant
    sum += score;
  }
  return sum;
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution_2">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#include &lt;vector&gt;

class Stats {
    std::vector&lt;int&gt; playerScores;
  public:
    std::vector&lt;int&gt; const&amp; getPlayerScores() const {
      return playerScores;
    }
};

Stats getStats();

int getTotalScore() {
  int sum = 0;
  // stats is not a temporary and it is alive throughout the loop
  for (auto stats = getStats(); auto score : stats.getPlayerScores()) { // Compliant
    sum += score;
  }
  return sum;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively, you can rely on lifetime-extension, if you are accessing the field directly:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#include &lt;vector&gt;

class Stats {
  public:
    std::vector&lt;int&gt; playerScores;
};

Stats getStats();

int getTotalScore() {
  int sum = 0;
  //The temporary Stats is lifetime extended for the duration of the loop
  // because a hidden const reference is bound to its field Stats::playerScores
  for (auto score : getStats().playerScores) { // Compliant
    sum += score;
  }
  return sum;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Another option is to overload the <code>getPlayerScores</code> member function to
"consume" the temporary and return an independent temporary with its own
lifetime that can be extended:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#include &lt;vector&gt;

class Stats {
    std::vector&lt;int&gt; playerScores;
  public:
    std::vector&lt;int&gt; const&amp; getPlayerScores() const {
      return playerScores;
    }
    std::vector&lt;int&gt; getPlayerScores() &amp;&amp; { // Note the &amp;&amp;
      return std::move(playerScores);
    }
};

Stats getStats();

int getTotalScore() {
  int sum = 0;
  // Now, the second overload of getPlayerScores() is used, and it
  // returns another temporary that can be lifetime extended.
  for (auto score : getStats().getPlayerScores()) { // Compliant
    sum += score;
  }
  return sum;
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_noncompliant_code_example_3">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#include &lt;string&gt;
#include &lt;memory&gt;
struct MyStrRef {
  std::shared_ptr&lt;std::string const&gt; target;
  MyStrRef(std::string const&amp; target):target (&amp;target) {}
};

void f(Wrapper const&amp; w) {
  MyStrRef x(std::string{"string"}); // Noncompliant
  std::cout &lt;&lt;*x.target; // Dereferencing a dangling pointer
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution_3">Compliant solution</h4>
<div class="paragraph">
<p>You can store the temporary as a global, static, or local variable, or on the heap.
For the completeness sake, let us put the string on the heap:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#include &lt;string&gt;
#include &lt;memory&gt;
struct MyStrRef {
  std::shared_ptr&lt;std::string const&gt; target;
  MyStrRef(std::shared_ptr&lt;std::string const&gt; target):target (&amp;target) {}
};

void f(Wrapper const&amp; w) {
  auto s = std::make_shared&lt;std::string&gt;("string");
  MyStrRef x(s); // Compliant
  std::cout &lt;&lt;*x.target;
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_noncompliant_code_example_4">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#include &lt;string&gt;
class Wrapper {
    std::string contents;
  public:
    std::string const&amp; getOr(std::string const&amp; backup) const {
      return contents.empty() ? backup : contents;
    }
};

void f(Wrapper const&amp; w) {
  // If w.contents is empty, c will be a dangling reference to the former std::string{"&lt;empty&gt;"}
  auto const&amp; c = w.getOr("&lt;empty&gt;"); // Noncompliant
  std::cout &lt;&lt;c &lt;&lt;std::endl;
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution_4">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#include &lt;string&gt;
class Wrapper {
    std::string contents;
  public:
    std::string const&amp; getOr(std::string const&amp; backup) const {
      return contents.empty() ? backup : contents;
    }
};

void f(Wrapper const&amp; w) {
  std::string c = w.getOr("&lt;empty&gt;"); // Compliant, c is an independent copy
  std::cout &lt;&lt;c &lt;&lt;std::endl;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_going_the_extra_mile">Going the extra mile</h3>
<div class="paragraph">
<p>The interface of <code>Wrapper::getOr</code> from the example above is dangerous,
since it is bound to create subtle bugs.
Instead of fixing every call, it is better to make the interface less error-prone.</p>
</div>
<div class="paragraph">
<p>For example, always return the <code>std::string</code> by value.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">  std::string Wrapper::getOr(std::string backup) const {
    return contents.empty() ? backup : contents;
  }</code></pre>
</div>
</div>
<div class="paragraph">
<p>There is no reference involved, so no risk of having it dangling.</p>
</div>
<div class="paragraph">
<p>This safer solution does involve some performance overhead of potentially unnecessarily
copying <code>w.contents</code> string but in many cases it is acceptable.</p>
</div>
<div class="paragraph">
<p>Alternatively, using <code>std::string_view</code> does not escape this flaw in all cases (see below)
but it avoids the performance impact of <code>std::string</code> creation.</p>
</div>
<div class="paragraph">
<p>Here is a possible implementation using <code>std::string_view</code>
(or its equivalent before C&#43;&#43;17):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">  std::string_view Wrapper::getOr(std::string_view backup) const {
    return contents.empty() ? backup : contents;
  }</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case, <code>w.getOr("str")</code> creates and passes <code>std::string_view</code> by value,
and the temporary <code>std::string_view</code> stores a pointer to the string literal <code>"str"</code>.
When <code>getOr</code> returns <code>contents</code> it copies the <code>backup</code> value, which is fast,
and the result is copied to a variable in the caller&#8217;s stack frame.</p>
</div>
<div class="paragraph">
<p>Yet, the following code would still create a dangling pointer
because it creates a temporary <code>std::string</code>
and the <code>std::string_view</code> refers to this temporary object
that gets destroyed at the end of the full expression:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">std::string_view c = w.getOr(std::string{"str"}); // Noncompliant
std::cout &lt;&lt;c &lt;&lt;std::endl; // c refers to the memory formerly occupied by a temporary string</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_documentation">Documentation</h3>
<div class="ulist">
<ul>
<li>
<p>C&#43;&#43; reference - <a href="https://en.cppreference.com/w/cpp/language/lifetime">Lifetime</a></p>
</li>
<li>
<p>C&#43;&#43; reference - <a href="https://en.cppreference.com/w/cpp/language/range-for">Range-based for loop / Temporary range expression</a></p>
</li>
<li>
<p>C&#43;&#43; reference - <a href="https://en.cppreference.com/w/cpp/header/string_view">string_view</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_articles_blog_posts">Articles &amp; blog posts</h3>
<div class="ulist">
<ul>
<li>
<p>Abseil - <a href="https://abseil.io/tips/107">Tip of the Week #107: Reference Lifetime Extension</a></p>
</li>
</ul>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_comments_and_links">Comments And Links</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_on_13_dec_2019_185941_loïc_joly_wrote">on 13 Dec 2019, 18:59:41 Loïc Joly wrote:</h3>
<div class="paragraph">
<p>\[~amelie.renard]: From the example, you seem to want to report at the place the immediately dangling reference is used, not at the place it is created. I think this is significantly more complex, for little added value (anyways, the place to correct is probably the creation place). I changed it. One consequence is the possibility of "true" false positives, if the reference is created, but never used. But this is probably an uncommon pattern, and at least a pitfall.</p>
</div>
<div class="paragraph">
<p>I also changed some wording, can you review?</p>
</div>
</div>
<div class="sect2">
<h3 id="_on_16_dec_2019_093146_amélie_renard_wrote">on 16 Dec 2019, 09:31:46 Amélie Renard wrote:</h3>
<div class="paragraph">
<p>\[~loic.joly] Seems good to me, thanks.</p>
</div>
</div>
</div>
</div>