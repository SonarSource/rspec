This rule raises an issue when a variable is declared at script level without the `def` keyword, creating a binding variable that is shared across all loaded scripts.

== Why is this an issue?

In Jenkins Groovy scripts, variables declared without the `def` keyword become binding variables. These variables are stored in a shared binding context that is accessible across all loaded scripts in the same Jenkins execution.

This creates several problems:

**Security Risk**: Binding variables can be accessed and modified by any script loaded in the same Jenkins execution. This means sensitive data like credentials, API keys, or configuration values could be accidentally exposed to other scripts.

**Maintainability Issues**: When multiple scripts can access the same variables, it becomes difficult to track where variables are defined and modified. This makes debugging harder and increases the risk of unexpected behavior.

**Namespace Pollution**: Binding variables pollute the global namespace, making it more likely that variable names will conflict between different scripts.

The `@Field` annotation provides a better alternative. Variables annotated with `@Field` are accessible throughout the script but remain encapsulated within that specific script, preventing cross-script access.

=== What is the potential impact?

Binding variables can lead to security vulnerabilities through unintended data exposure between scripts. They also make code harder to maintain and debug due to unclear variable scoping and potential naming conflicts.

== How to fix it

Use the @Field annotation to declare script-level variables. Import the Field annotation and add it before variable declarations that need to be accessible across methods within the same script.

=== Code examples

==== Noncompliant code example

[source,groovy,diff-id=1,diff-type=noncompliant]
----
// Creates a binding variable accessible across all scripts
some_var = "some value" // Noncompliant

def pr() {
    def another_var = "another " + some_var
    echo "${another_var}"
}
----

==== Compliant solution

[source,groovy,diff-id=1,diff-type=compliant]
----
// Uses @Field annotation for script-level variable
import groovy.transform.Field

@Field
def some_var = "some value"

def pr() {
    def another_var = "another " + some_var
    echo "${another_var}"
}
----

== Resources

=== Documentation

 * Groovy @Field Annotation Documentation - https://docs.groovy-lang.org/latest/html/gapi/groovy/transform/Field.html[Official documentation for the @Field annotation in Groovy]

 * Jenkins Pipeline Groovy Best Practices - https://www.jenkins.io/doc/book/pipeline/shared-libraries/#defining-global-variables[Jenkins documentation on best practices for variable scoping in pipeline scripts]

=== Standards

 * CWE 200 - https://cwe.mitre.org/data/definitions/200.html[Information Exposure - unintended exposure of sensitive information]
