<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This rule raises an issue when a mutex is destroyed (either implicitly by going out of scope or explicitly through operations like <code>reset()</code>) while it is in a locked state.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A mutex (mutual exclusion object) is a synchronization primitive used to protect shared data from concurrent access. When a thread locks a mutex, it gains exclusive access to the protected resource. The mutex must be unlocked before it can be destroyed.</p>
</div>
<div class="paragraph">
<p>Destroying a locked mutex violates the fundamental contract of mutex ownership and results in undefined behavior according to the C++ standard. This can occur in two ways:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Implicit destruction</strong>: When a mutex object goes out of scope while still locked</p>
</li>
<li>
<p><strong>Explicit destruction</strong>: When explicitly destroying a mutex (such as calling <code>reset()</code> on an <code>std::optional&lt;std::mutex&gt;</code>) while it is locked</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The undefined behavior can manifest in various ways:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The program may crash immediately or at a later point</p>
</li>
<li>
<p>Other threads waiting on the mutex may deadlock indefinitely</p>
</li>
<li>
<p>Memory corruption may occur</p>
</li>
<li>
<p>The behavior may appear to work in some environments but fail in others</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The C++ standard library provides RAII (Resource Acquisition Is Initialization) wrappers like <code>std::lock_guard</code> and <code>std::scoped_lock</code> that automatically unlock mutexes when they go out of scope, helping prevent this issue. However, manual locking with <code>lock()</code> requires careful attention to ensure <code>unlock()</code> is called before the mutex is destroyed.</p>
</div>
<div class="sect2">
<h3 id="_what_is_the_potential_impact">What is the potential impact?</h3>
<div class="paragraph">
<p>Destroying a locked mutex causes undefined behavior, which can lead to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Program crashes</strong>: The application may terminate unexpectedly</p>
</li>
<li>
<p><strong>Deadlocks</strong>: Other threads waiting to acquire the mutex may hang indefinitely</p>
</li>
<li>
<p><strong>Data corruption</strong>: The undefined behavior may corrupt program state or memory</p>
</li>
<li>
<p><strong>Unpredictable behavior</strong>: The program may appear to work in some scenarios but fail in others, making bugs difficult to reproduce and diagnose</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_fix_it">How to fix it</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Ensure the mutex is unlocked before it goes out of scope. When using manual locking with <code>lock()</code>, always call <code>unlock()</code> before the mutex is destroyed.</p>
</div>
<div class="sect2">
<h3 id="_code_examples">Code examples</h3>
<div class="sect3">
<h4 id="_noncompliant_code_example">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">void processData() {
  std::mutex m;
  m.lock();
  // ... perform operations ...
} // Noncompliant: mutex destroyed while locked</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">void processData() {
  std::mutex m;
  m.lock();
  // ... perform operations ...
  m.unlock();
} // mutex unlocked before destruction</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_documentation">Documentation</h3>
<div class="ulist">
<ul>
<li>
<p>C++ Reference - std::mutex - <a href="https://en.cppreference.com/w/cpp/thread/mutex">Documentation for std::mutex including lifecycle requirements</a></p>
</li>
<li>
<p>C++ Reference - std::lock_guard - <a href="https://en.cppreference.com/w/cpp/thread/lock_guard">RAII wrapper for mutex management</a></p>
</li>
<li>
<p>C++ Reference - std::scoped_lock - <a href="https://en.cppreference.com/w/cpp/thread/scoped_lock">RAII wrapper that can lock multiple mutexes</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_standards">Standards</h3>
<div class="ulist">
<ul>
<li>
<p>CWE 667 - <a href="https://cwe.mitre.org/data/definitions/667.html">CWE-667: Improper Locking</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_related_rules">Related rules</h3>
<div class="ulist">
<ul>
<li>
<p><a data-rspec-id="S5487" class="rspec-auto-link">S5487</a> - Related rule for C/C++ mutex handling</p>
</li>
</ul>
</div>
</div>
</div>
</div>