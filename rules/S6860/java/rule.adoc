Spring's `@Bean` annotation allows developers to specify callback methods that will be invoked at the creation and destruction of the bean using the `initMethod` and `destroyMethod` identifiers.
However, because these methods are referred to using their names as strings rather than references, it is easy to introduce typos that break the link.

== Why is this an issue?
Referencing a non-existing init or destroy method will make your application fail at startup.

== How to fix it
Reference a method in the type hierarchy of the bean type.

=== Code examples

==== Noncompliant code example

[source,java,diff-id=1,diff-type=noncompliant]
----
@Component
public class ParentBean {
    public void open() {
        /* Do something */
    }
}

@Component
public class MyBean extends ParentBean {
    public void close() {
        /* Do something */
    }
}

@Component
public class SomeComponent {
  @Bean(
    initMethod="aupen",   // Noncompliant, the initMethod parameter does not match an existing method
    destroyMethod="klose" // Noncompliant, the destroyMethod parameter does not match an existing method
  )
  public MyBean getMeABean() {
    return new MyBean();
  }
}
----

==== Compliant solution

[source,java,diff-id=1,diff-type=compliant]
----
@Component
public class ParentBean {
    public void open() {
        /* Do something */
    }
}

@Component
public class MyBean extends ParentBean {
    public void close() {
        /* Do something */
    }
}

@Component
public class SomeComponent {
  @Bean(
    initMethod="open",    // Compliant
    destroyMethod="close" // Compliant
  )
  public MyBean getMeABean() {
    return new MyBean();
  }
}
----

=== Pitfalls

Eligible init/destroy methods must be parameter-free.


== Resources
=== Documentation
- https://docs.spring.io/spring-framework/reference/core/beans/java/bean-annotation.html[Using the @Bean annotation :: Spring Framework]
