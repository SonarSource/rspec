<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The improper storage of passwords poses a significant security risk to software
applications. This vulnerability arises when passwords are stored in plaintext
or with a fast hashing algorithm. To exploit this vulnerability, an attacker
typically requires access to the stored passwords.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Attackers who would get access to the stored passwords could reuse them without
further attacks or with little additional effort.<br>
Obtaining the plaintext passwords, they could then gain unauthorized access to
user accounts, potentially leading to various malicious activities.</p>
</div>
<div class="sect2">
<h3 id="_what_is_the_potential_impact">What is the potential impact?</h3>
<div class="paragraph">
<p>Plaintext or weakly hashed password storage poses a significant security risk
to software applications.</p>
</div>
<div class="sect3">
<h4 id="_unauthorized_access">Unauthorized Access</h4>
<div class="paragraph">
<p>When passwords are stored in plaintext or with weak hashing algorithms, an
attacker who gains access to the password database can easily retrieve and use
the passwords to gain unauthorized access to user accounts. This can lead to
various malicious activities, such as unauthorized data access, identity theft,
or even financial fraud.</p>
</div>
</div>
<div class="sect3">
<h4 id="_credential_reuse">Credential Reuse</h4>
<div class="paragraph">
<p>Many users tend to reuse passwords across multiple platforms. If an attacker
obtains plaintext or weakly hashed passwords, they can potentially use these
credentials to gain unauthorized access to other accounts held by the same
user. This can have far-reaching consequences, as sensitive personal
information or critical systems may be compromised.</p>
</div>
</div>
<div class="sect3">
<h4 id="_regulatory_compliance">Regulatory Compliance</h4>
<div class="paragraph">
<p>Many industries and jurisdictions have specific regulations and standards to
protect user data and ensure its confidentiality. Storing passwords in
plaintext or with weak hashing algorithms can lead to non-compliance with
these regulations, potentially resulting in legal consequences, financial
penalties, and damage to the reputation of the software application and its
developers.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_fix_it_in_asp_net_core">How to fix it in ASP.NET Core</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_code_examples">Code examples</h3>
<div class="sect3">
<h4 id="_noncompliant_code_example">Noncompliant code example</h4>
<div class="paragraph">
<p>Using <code>Microsoft.AspNetCore.Cryptography.KeyDerivation</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-csharp" data-lang="csharp">using Microsoft.AspNetCore.Cryptography.KeyDerivation;
using System.Security.Cryptography;

string password = Request.Query["password"];
byte[] salt = RandomNumberGenerator.GetBytes(128 / 8);

string hashed = Convert.ToBase64String(KeyDerivation.Pbkdf2(
    password: password!,
    salt: salt,
    prf: KeyDerivationPrf.HMACSHA256,
    iterationCount: 1, // Noncompliant
    numBytesRequested: 256 / 8));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using <code>System.Security.Cryptography</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-csharp" data-lang="csharp">using System.Security.Cryptography;

string password = Request.Query["password"];
byte[] salt = RandomNumberGenerator.GetBytes(128 / 8);
Rfc2898DeriveBytes kdf = new Rfc2898DeriveBytes(password, 128/8); // Noncompliant
string hashed = Convert.ToBase64String(kdf.GetBytes(256 / 8));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using <code>Microsoft.AspNetCore.Identity</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-csharp" data-lang="csharp">using Microsoft.AspNetCore.Identity;
using Microsoft.Extensions.Options;

string password = Request.Query["password"];
IOptions&lt;PasswordHasherOptions&gt; options = Options.Create(new PasswordHasherOptions() {
    IterationCount = 1 // Noncompliant
});
PasswordHasher&lt;User&gt; hasher = new PasswordHasher&lt;User&gt;(options);
string hash = hasher.HashPassword(new User("test"), password);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution">Compliant solution</h4>
<div class="paragraph">
<p>Using <code>Microsoft.AspNetCore.Cryptography.KeyDerivation</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-csharp" data-lang="csharp">using Microsoft.AspNetCore.Cryptography.KeyDerivation;
using System.Security.Cryptography;

string password = Request.Query["password"];
byte[] salt = RandomNumberGenerator.GetBytes(128 / 8);

string hashed = Convert.ToBase64String(KeyDerivation.Pbkdf2(
    password: password!,
    salt: salt,
    prf: KeyDerivationPrf.HMACSHA256,
    iterationCount: 100_000,
    numBytesRequested: 256 / 8));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using <code>System.Security.Cryptography</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-csharp" data-lang="csharp">using System.Security.Cryptography;

string password = Request.Query["password"];
byte[] salt = RandomNumberGenerator.GetBytes(128 / 8);
Rfc2898DeriveBytes kdf = new Rfc2898DeriveBytes(password, salt, 100_000, HashAlgorithmName.SHA256);
string hashed = Convert.ToBase64String(kdf.GetBytes(256 / 8));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using <code>Microsoft.AspNetCore.Identity</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-csharp" data-lang="csharp">using Microsoft.AspNetCore.Identity;
using Microsoft.Extensions.Options;

string password = Request.Query["password"];
PasswordHasher&lt;User&gt; hasher = new PasswordHasher&lt;User&gt;();
string hash = hasher.HashPassword(new User("test"), password);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_how_does_this_work">How does this work?</h3>
<div class="sect3">
<h4 id="_select_the_correct_pbkdf2_parameters">Select the correct PBKDF2 parameters</h4>
<div class="paragraph">
<p>If PBKDF2 must be used, be aware that default values might not be considered
secure.<br>
Depending on the algorithm used, the number of iterations should be adjusted to
ensure that the derived key is secure. The following are the recommended number
of iterations for PBKDF2:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>PBKDF2-HMAC-SHA1: 1,300,000 iterations</p>
</li>
<li>
<p>PBKDF2-HMAC-SHA256: 600,000 iterations</p>
</li>
<li>
<p>PBKDF2-HMAC-SHA512: 210,000 iterations</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Note that PBKDF2-HMAC-SHA256 is recommended by NIST.<br>
Iterations are also called "rounds" depending on the library used.</p>
</div>
<div class="paragraph">
<p>When recommended cost factors are too high in the context of the application or
if the performance cost is unacceptable, a cost factor reduction might be
considered. In that case, it should not be chosen under 100,000.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_going_the_extra_mile">Going the extra mile</h3>
<div class="sect3">
<h4 id="_pepper">Pepper</h4>
<div class="paragraph">
<p>In a defense-in-depth security approach, <strong>peppering</strong> can also be used. This is
a security technique where an external secret value is added to a password
before it is hashed.<br>
This makes it more difficult for an attacker to crack the hashed passwords, as
they would need to know the secret value to generate the correct hash.<br>
<a href="https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html#peppering">Learn more here</a>.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_fix_it_in_asp_net">How to fix it in ASP.NET</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_code_examples_2">Code examples</h3>
<div class="sect3">
<h4 id="_noncompliant_code_example_2">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-csharp" data-lang="csharp">using System.Security.Cryptography;

RNGCryptoServiceProvider rngCsp = new RNGCryptoServiceProvider();
byte[] salt = new byte[32];
rngCsp.GetBytes(salt);
Rfc2898DeriveBytes kdf = new Rfc2898DeriveBytes(password, salt, 100, HashAlgorithmName.SHA256); // Noncompliant
string hashed = Convert.ToBase64String(kdf.GetBytes(256 / 8));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using <code>using Microsoft.AspNet.Identity</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-csharp" data-lang="csharp">using Microsoft.AspNet.Identity;

string password = "NotSoSecure";
PasswordHasher hasher = new PasswordHasher();
string hash = hasher.HashPassword(password); // Noncompliant</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution_2">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-csharp" data-lang="csharp">using System.Security.Cryptography;

RNGCryptoServiceProvider rngCsp = new RNGCryptoServiceProvider();
byte[] salt = new byte[32];
rngCsp.GetBytes(salt);
Rfc2898DeriveBytes kdf = new Rfc2898DeriveBytes(password, salt, 100_000, HashAlgorithmName.SHA256); // Compliant
string hashed = Convert.ToBase64String(kdf.GetBytes(256 / 8));</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_how_does_this_work_2">How does this work?</h3>
<div class="sect3">
<h4 id="_select_the_correct_pbkdf2_parameters_2">Select the correct PBKDF2 parameters</h4>
<div class="paragraph">
<p>If PBKDF2 must be used, be aware that default values might not be considered
secure.<br>
Depending on the algorithm used, the number of iterations should be adjusted to
ensure that the derived key is secure. The following are the recommended number
of iterations for PBKDF2:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>PBKDF2-HMAC-SHA1: 1,300,000 iterations</p>
</li>
<li>
<p>PBKDF2-HMAC-SHA256: 600,000 iterations</p>
</li>
<li>
<p>PBKDF2-HMAC-SHA512: 210,000 iterations</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Note that PBKDF2-HMAC-SHA256 is recommended by NIST.<br>
Iterations are also called "rounds" depending on the library used.</p>
</div>
<div class="paragraph">
<p>When recommended cost factors are too high in the context of the application or
if the performance cost is unacceptable, a cost factor reduction might be
considered. In that case, it should not be chosen under 100,000.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_going_the_extra_mile_2">Going the extra mile</h3>
<div class="sect3">
<h4 id="_pepper_2">Pepper</h4>
<div class="paragraph">
<p>In a defense-in-depth security approach, <strong>peppering</strong> can also be used. This is
a security technique where an external secret value is added to a password
before it is hashed.<br>
This makes it more difficult for an attacker to crack the hashed passwords, as
they would need to know the secret value to generate the correct hash.<br>
<a href="https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html#peppering">Learn more here</a>.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_fix_it_in_bouncycastle">How to fix it in BouncyCastle</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_code_examples_3">Code examples</h3>
<div class="sect3">
<h4 id="_noncompliant_code_example_3">Noncompliant code example</h4>
<div class="paragraph">
<p>Using SCrypt:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-csharp" data-lang="csharp">using Org.BouncyCastle.Crypto.Generators;

string password = Request.Query["password"];
byte[] salt = RandomNumberGenerator.GetBytes(128 / 8); // divide by 8 to convert bits to bytes

string hashed = Convert.ToBase64String(SCrypt.Generate(Encoding.Unicode.GetBytes(password), salt, 4, 2, 1, 32));  // Noncompliant</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using BCrypt:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-csharp" data-lang="csharp">using Org.BouncyCastle.Crypto.Generators;
using Org.BouncyCastle.Crypto.Parameters;

string password = Request.Query["password"];
byte[] salt = RandomNumberGenerator.GetBytes(128 / 8);

string hashed = OpenBsdBCrypt.Generate(password.ToCharArray(), salt, 4); // Noncompliant</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using PBKDF2:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-csharp" data-lang="csharp">using Org.BouncyCastle.Crypto.Generators;
using Org.BouncyCastle.Crypto.Parameters;
using System.Security.Cryptography;

string password = Request.Query["password"];
byte[] salt = RandomNumberGenerator.GetBytes(128 / 8);
Pkcs5S2ParametersGenerator gen = new Pkcs5S2ParametersGenerator();
gen.Init(Encoding.Unicode.GetBytes(password), salt, 100);  // Noncompliant
KeyParameter keyParam = (KeyParameter) gen.GenerateDerivedMacParameters(256);
string hashed = Convert.ToBase64String(keyParam.GetKey());</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution_3">Compliant solution</h4>
<div class="paragraph">
<p>Using SCrypt:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-csharp" data-lang="csharp">using Org.BouncyCastle.Crypto.Generators;

string password = Request.Query["password"];
byte[] salt = RandomNumberGenerator.GetBytes(128 / 8); // divide by 8 to convert bits to bytes

string hashed = Convert.ToBase64String(SCrypt.Generate(Encoding.Unicode.GetBytes(password), salt, 1&lt;&lt;12, 8, 1, 32));  // Noncompliant</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using BCrypt:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-csharp" data-lang="csharp">using Org.BouncyCastle.Crypto.Generators;
using Org.BouncyCastle.Crypto.Parameters;

string password = Request.Query["password"];
byte[] salt = RandomNumberGenerator.GetBytes(128 / 8);

string hashed = OpenBsdBCrypt.Generate(password.ToCharArray(), salt, 14); // Noncompliant</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using PBKDF2:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-csharp" data-lang="csharp">using Org.BouncyCastle.Crypto.Generators;
using Org.BouncyCastle.Crypto.Parameters;
using System.Security.Cryptography;

string password = Request.Query["password"];
byte[] salt = RandomNumberGenerator.GetBytes(128 / 8);
Pkcs5S2ParametersGenerator gen = new Pkcs5S2ParametersGenerator();
gen.Init(Encoding.Unicode.GetBytes(password), salt, 100_000);  // Noncompliant
KeyParameter keyParam = (KeyParameter) gen.GenerateDerivedMacParameters(256);
string hashed = Convert.ToBase64String(keyParam.GetKey());</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_how_does_this_work_3">How does this work?</h3>
<div class="sect3">
<h4 id="_select_the_correct_bcrypt_parameters">Select the correct Bcrypt parameters</h4>
<div class="paragraph">
<p>When bcrypt&#8217;s hashing function is used, it is important to select a round count
that is high enough to make the function slow enough to prevent brute force:
More than 12 rounds.</p>
</div>
<div class="paragraph">
<p>For bcrypt&#8217;s key derivation function, the number of rounds should likewise be
high enough to make the function slow enough to prevent brute force: More than
4096 rounds <code>(2^12)</code>.<br>
This number is not the same coefficient as the first one because it uses
a different algorithm.</p>
</div>
</div>
<div class="sect3">
<h4 id="_select_the_correct_scrypt_parameters">Select the correct Scrypt parameters</h4>
<div class="paragraph">
<p>If scrypt must be used, the default values of scrypt are considered secure.</p>
</div>
<div class="paragraph">
<p>Like Argon2id, scrypt has three different parameters that can be configured. N is the CPU/memory cost parameter and must be a power of two. r is the block size and p is the parallelization factor.</p>
</div>
<div class="paragraph">
<p>All three parameters affect the memory and CPU usage of the algorithm.
Higher values of N, r and p result in safer hashes, but come at the cost of higher resource usage.</p>
</div>
<div class="paragraph">
<p>For scrypt, OWASP recommends to have a hash length of at least 64 bytes, and to set N, p and r to the values of one of the following rows:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">N (cost parameter)</th>
<th class="tableblock halign-left valign-top">p (parallelization factor)</th>
<th class="tableblock halign-left valign-top">r (block size)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>2<sup>17</sup> (<code>1 &lt;&lt; 17</code>)</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>1</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>8</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>2<sup>16</sup> (<code>1 &lt;&lt; 16</code>)</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>2</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>8</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>2<sup>15</sup> (<code>1 &lt;&lt; 15</code>)</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>3</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>8</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>2<sup>14</sup> (<code>1 &lt;&lt; 14</code>)</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>5</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>8</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>2<sup>13</sup> (<code>1 &lt;&lt; 13</code>)</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>10</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>8</p>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Every row provides the same level of defense. They only differ in the amount of CPU and RAM used: the top row has low CPU usage and high memory usage, while the bottom row has high CPU usage and low memory usage.</p>
</div>
</div>
<div class="sect3">
<h4 id="_select_the_correct_pbkdf2_parameters_3">Select the correct PBKDF2 parameters</h4>
<div class="paragraph">
<p>If PBKDF2 must be used, be aware that default values might not be considered
secure.<br>
Depending on the algorithm used, the number of iterations should be adjusted to
ensure that the derived key is secure. The following are the recommended number
of iterations for PBKDF2:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>PBKDF2-HMAC-SHA1: 1,300,000 iterations</p>
</li>
<li>
<p>PBKDF2-HMAC-SHA256: 600,000 iterations</p>
</li>
<li>
<p>PBKDF2-HMAC-SHA512: 210,000 iterations</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Note that PBKDF2-HMAC-SHA256 is recommended by NIST.<br>
Iterations are also called "rounds" depending on the library used.</p>
</div>
<div class="paragraph">
<p>When recommended cost factors are too high in the context of the application or
if the performance cost is unacceptable, a cost factor reduction might be
considered. In that case, it should not be chosen under 100,000.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_going_the_extra_mile_3">Going the extra mile</h3>
<div class="sect3">
<h4 id="_pepper_3">Pepper</h4>
<div class="paragraph">
<p>In a defense-in-depth security approach, <strong>peppering</strong> can also be used. This is
a security technique where an external secret value is added to a password
before it is hashed.<br>
This makes it more difficult for an attacker to crack the hashed passwords, as
they would need to know the secret value to generate the correct hash.<br>
<a href="https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html#peppering">Learn more here</a>.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_documentation">Documentation</h3>
<div class="ulist">
<ul>
<li>
<p>OWASP CheatSheet - <a href="https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html">Password Storage Cheat Sheet</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_standards">Standards</h3>
<div class="ulist">
<ul>
<li>
<p>OWASP - <a href="https://owasp.org/Top10/A02_2021-Cryptographic_Failures/">Top 10 2021 Category A2 - Cryptographic Failures</a></p>
</li>
<li>
<p>OWASP - <a href="https://owasp.org/Top10/A04_2021-Insecure_Design/">Top 10 2021 Category A4 - Insecure Design</a></p>
</li>
<li>
<p>OWASP - <a href="https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure">Top 10 2017 Category A3 - Sensitive Data Exposure</a></p>
</li>
<li>
<p>CWE - <a href="https://cwe.mitre.org/data/definitions/256">CWE-256 - Plaintext Storage of a Password</a></p>
</li>
<li>
<p>CWE - <a href="https://cwe.mitre.org/data/definitions/916">CWE-916 - Use of Password Hash With Insufficient Computational Effort</a></p>
</li>
<li>
<p>STIG Viewer - <a href="https://stigviewer.com/stigs/application_security_and_development/2024-12-06/finding/V-222542">Application Security and Development: V-222542</a> - The application must only store cryptographic representations of passwords.</p>
</li>
</ul>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_implementation_specification">Implementation Specification</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_message">Message</h3>
<div class="sect3">
<h4 id="_net_core">.NET Core</h4>
<div class="paragraph">
<p>For <code>Microsoft.AspNetCore.Identity</code>:
When <code>PasswordHasherOptions.IterationCount</code> is &lt; 100,000:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Use at least 10 000 iterations here.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>When <code>PasswordHasherOptions.CompatibilityMode</code> is set to <code>PasswordHasherCompatibilityMode.IdentityV2</code>:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Identity v2 uses only 1000 iterations. Considers changing to identity V3.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>For <code>Microsoft.AspNetCore.Cryptography.KeyDerivation</code>:
When <code>KeyDerivation.Pbkdf2</code> is called with <code>iterationCount</code> &lt; 100,000:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Use at least 100,000 iterations here.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>For <code>System.Security.Cryptography</code>:</p>
</div>
<div class="paragraph">
<p>When Rfc2898DeriveBytes is instantiated with an <code>iterations</code> parameter &lt; 100,000.
When Rfc2898DeriveBytes.Pbkdf2 is called with an <code>iterations</code> parameter &lt; 100,000.</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Use at least 100,000 iterations here.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>When Rfc2898DeriveBytes is instantiated without a <code>hashAlgorithm</code> parameter.</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Use at least 100,000 iterations and a state-of-the-art digest algorithm here.</p>
</div>
</blockquote>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_net_framework">.NET framework</h3>
<div class="paragraph">
<p>For <code>Microsoft.AspNet.Identity</code>:
When a <code>PasswordHasher</code> is instantiated.</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>PasswordHasher does not support state-of-the-art parameters. Use Rfc2898DeriveBytes instead.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>When Rfc2898DeriveBytes is instantiated with an <code>iterations</code> parameter &lt; 100,000.</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Use at least 100,000 iterations here.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>When Rfc2898DeriveBytes is instantiated without a <code>hashAlgorithm</code> parameter.</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Use at least 100,000 iterations and a state-of-the-art digest algorithm here.</p>
</div>
</blockquote>
</div>
</div>
<div class="sect2">
<h3 id="_bouncycastle">BouncyCastle</h3>
<div class="paragraph">
<p>For <code>Org.BouncyCastle.Crypto.Generators.OpenBsdBCrypt</code>, or <code>Org.BouncyCastle.Crypto.Generators.BCrypt</code>:
When <code>Generate</code> is called with cost &lt; 12:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Use a cost factor of at least 12 here.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>For <code>Org.BouncyCastle.Crypto.PbeParametersGenerator</code>:
When <code>Init</code> is called with <code>iterationCount</code> &lt; 100,000:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Use at least 100,000 iterations here.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>For <code>Org.BouncyCastle.Crypto.Generators.SCrypt</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When <code>Generate</code> is called with N &lt; 2^12:</p>
</li>
</ul>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Use a cost factor of at least 2^12 for N here.</p>
</div>
</blockquote>
</div>
<div class="ulist">
<ul>
<li>
<p>When <code>Generate</code> is called with r &lt; 8:</p>
</li>
</ul>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Use a memory factor of at least 8 for r here.</p>
</div>
</blockquote>
</div>
<div class="ulist">
<ul>
<li>
<p>When <code>Generate</code> is called with dkLen &lt; 32:</p>
</li>
</ul>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Use an output length of at least 32 for dkLen here.</p>
</div>
</blockquote>
</div>
</div>
<div class="sect2">
<h3 id="_highlighting">Highlighting</h3>
<div class="sect3">
<h4 id="_net_core_2">.NET Core</h4>
<div class="paragraph">
<p>For <code>Microsoft.AspNetCore.Identity</code>:
When <code>PasswordHasherOptions.IterationCount</code> is &lt; 100,000, highlight the IterationCount attribute.
When <code>PasswordHasherOptions.CompatibilityMode</code> is set to <code>PasswordHasherCompatibilityMode.IdentityV2</code>, highlight the
corresponding attribute.</p>
</div>
<div class="paragraph">
<p>For <code>Microsoft.AspNetCore.Cryptography.KeyDerivation</code>:
When <code>KeyDerivation.Pbkdf2</code> is called with <code>iterationCount</code> &lt; 100,000, highlight the iterationCount parameter.</p>
</div>
<div class="paragraph">
<p>For <code>System.Security.Cryptography</code>:
When Rfc2898DeriveBytes is instantiated with an <code>iterations</code> parameter &lt; 100,000, highlight the iterations parameter.
When Rfc2898DeriveBytes is instantiated without a <code>hashAlgorithm</code> parameter highlight the whole constructor call.</p>
</div>
</div>
<div class="sect3">
<h4 id="_net_framework_2">.NET framework</h4>
<div class="paragraph">
<p>For <code>Microsoft.AspNet.Identity</code>:
When a <code>PasswordHasher</code> is instantiated highlight the constructor.</p>
</div>
<div class="paragraph">
<p>For <code>System.Security.Cryptography</code>:
When Rfc2898DeriveBytes is instantiated with an <code>iterations</code> parameter &lt; 100,000 or
when Rfc2898DeriveBytes.Pbkdf2 is called with an <code>iterations</code> parameter &lt; 100,000, highlight the iterations parameter.
When Rfc2898DeriveBytes is instantiated without a <code>hashAlgorithm</code> parameter highlight the whole constructor call.</p>
</div>
</div>
<div class="sect3">
<h4 id="_bouncycastle_2">BouncyCastle</h4>
<div class="paragraph">
<p>For <code>Org.BouncyCastle.Crypto.Generators.OpenBsdBCrypt</code>, or <code>Org.BouncyCastle.Crypto.Generators.BCrypt</code>:
When <code>Generate</code> is called with cost &lt; 12, highlight the cost parameter.</p>
</div>
<div class="paragraph">
<p>For <code>Org.BouncyCastle.Crypto.PbeParametersGenerator</code>:
When <code>Init</code> is called with <code>iterationCount</code> &lt; 100,000, highlight the iteration count parameter.</p>
</div>
<div class="paragraph">
<p>For <code>Org.BouncyCastle.Crypto.Generators.SCrypt</code>:
When <code>Generate</code> is called with N &lt; 2^12, r &lt; 8, or dklen &lt; 32, highlight the weak parameter.</p>
</div>
</div>
</div>
</div>
</div>