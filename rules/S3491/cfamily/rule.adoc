By contract, chaining the 'Address of' operator ``++&++`` with the 'Indirection' operator ``++*++`` results in a return to the initial value. Thus, such combinations are confusing at best, and bugs at worst.


== Noncompliant Code Example

----
int *ptr = ...;
int *result1 = &(*ptr); //Noncompliant
int *result2 = &*ptr; //Noncompliant

int value = 4;
int result3 = *(&value); //Noncompliant
int result4 = *&value; //Noncompliant
----


== Compliant Solution

----
int *ptr = ...;
int *result1 = ptr;
int *result2 = ptr;

int value = 4;
int result3 = value;
int result4 = value;
----


== Exceptions

No issue is raised when the ``++*++`` or ``++&++`` operators are overloaded or when both operators are not located in the same piece of code (one being generated by a macro expansion and the other one located in the main source code for instance).


ifdef::env-github,rspecator-view[]

'''
== Implementation Specification
(visible only on this page)

include::message.adoc[]

include::highlighting.adoc[]

'''
== Comments And Links
(visible only on this page)

include::comments-and-links.adoc[]
endif::env-github,rspecator-view[]
