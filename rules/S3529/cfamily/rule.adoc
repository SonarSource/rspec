Accessing a block of the memory that was already freed has undefined behavior.
This rule flag access via pointer or references to released heap memory.

== Why is this an issue?

A program may allocate an additional block of memory, using the `malloc` function.
When no longer needed such blocks of memory are released using the `free` function.
Reading or writing to a heap allocator memory after it was released leads to undefined behavior.

[source,c]
----
char *cp = malloc(sizeof(char)*10); // memory is allocated
// all bytes in cp can be used here
free(cp); // memory is released
cp[9] = 0; // Noncompliant: memory is used after it was released
----

In addition to the `malloc` and `free` pair, in `C++` a heap memory may be acquired by use of the operator `new`,
and later released using the operator `delete`.

[source,cpp]
----
int *intArray = new int[20]; // memory is allocated
// elements of intArray can be written or read here
delete[] intArray; // memory is released
intArray[3] = 10; // Noncompliant: memory is used after it was released
----

Releasing a memory block by invoking `free` or operator `delete`,
indicates the memory management system that the given block is no longer used by the program.
Depending on the state and load of the program, such block can be then:
 * reused, i.e., the same pointer is returned by allocation function,
 * released to the operating system, making it inaccessible to the program.

=== What is the potential impact?

Accessing a released memory causes undefined behavior.
This means the compiler is not bound by the language standard anymore and your program has no meaning assigned to it.

Practically this has a wide range of effects:

* The program may crash due to the memory no longer being accessible,
  or due to unexpected value being read or written via the pointer.
* Reading from the released memory may produce a garbage value,
  or in the case when such memory was already reused to store sensitive data, such as passwords,
  may lead to a vulnerability that uses such a defect to extract information from an instance of the program.
* Writing to released memory, may change the value of the unrelated object in a remote part of the code if the memory was reused by it.
  As different objects may reuse same block of memory between runs, this leads to unintuitive and hard diagnose bugs in programs.


== How to fix it

In most situations, the use of an uninitialized object is a strong indication of a defect in the code,
and fixing it requires a review of the object allocation and deallocation strategies.
Generally, fixing the issues requires adjusting the allocation code, so either:

* Moving accesses to memory before the deallocation
* Moving the deallocation so it happens after all the uses

If possible, it is desired to remove manual memory allocations,
and replace them with stack-allocated object, or in case of {cpp},
a stack object that manages memory (that uses RAII idiom).

=== Noncompliant code example

[source,c,diff-id=1,diff-type=noncompliant]
----
int *intArray = malloc(sizeof(int)*10);
// ...
free(intArray);
intArray[9] = 0;  // Noncompliant
----

=== Compliant solution

Releasing memory after all of its uses.

[source,c,diff-id=1,diff-type=compliant]
----
int *intArray = malloc(sizeof(int)*10);
// ...
intArray[9] = 0;  // Compliant
free(intArray);
----

Alternatively, if the size of the array is known at compile-time:

[source,c]
----
int intArray[10];
// ...
intArray[9] = 0;  // Compliant
----

In {cpp}, `std::vector` can be used with an arbitrally number of elements:

[source,cpp]
----
std::vector<int> intArray;
// ...
intArray[9] = 0;  // Compliant
----

=== Going the extra mile

In {cpp}, using manually allocating and deallocating memory is considered a code smell.
It is recommended to follow an _RAII_ idiom and create a class, that manages the memory by allocating it in the constructor and freeing it in the destructor.
Such an object can be then passed between the functions (either as an argument or by being returned) instead of raw pointers.
Passing such object by value guarantees that the heap memory remains accessible when accessed via the object.

[source,cpp]
----
std::vector<int> intArray; // manages array on heap
std::unique_ptr<Class> objPtr = std::make_unique<Class>(); // manages object on heap

intArray[5]; // OK
objPtr->foo(); // OK
----

However, any raw pointers or references to memory held by such object may still lead to a use after free:
[source,cpp]
----
int* p1 = &intArray[0];    // becomes dangling when intArray is destroyed
int* p2 = intArray.data(); // same as above
Class* p3 = objPtr.get();  // becomes dangling, when objPtr releases the pointer
----

== Resources

=== Documentation

- C++ reference - https://en.cppreference.com/w/cpp/language/raii[RAII]
- C++ reference - https://en.cppreference.com/w/cpp/memory/unique_ptr[std::unique_ptr]
- C++ reference - https://en.cppreference.com/w/cpp/memory/shared_ptr[std::shared_ptr]

=== Standards

* CWE - https://cwe.mitre.org/data/definitions/416[416 - Use After Free]
* CERT - https://wiki.sei.cmu.edu/confluence/x/GdYxBQ[MEM30-C - Do not access freed memory]
* CERT - https://wiki.sei.cmu.edu/confluence/x/onw-BQ[MEM50-CPP - Do not access freed memory]
* CERT - https://wiki.sei.cmu.edu/confluence/x/OXw-BQ[EXP54-CPP - Do not access an object outside of its lifetime]

=== Related rules

* S5025 recommends avoiding manual memory management

ifdef::env-github,rspecator-view[]

'''
== Implementation Specification
(visible only on this page)

=== Message

Review this memory access; the memory has already been released.


=== Highlighting

* Primary: xxx
* Secondary: ``++free++`` call


endif::env-github,rspecator-view[]
