<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Server-Side Request Forgery (SSRF) occurs when attackers can coerce a server to
perform arbitrary requests on their behalf.<br></p>
</div>
<div class="paragraph">
<p>An SSRF vulnerability can either be basic or blind, depending on whether the
server&#8217;s fetched data is directly returned in the web application&#8217;s response.<br>
The absence of the corresponding response for the coerced request on the
application is not a barrier to exploitation and thus must be treated in the
same way as basic SSRF.</p>
</div>
<div class="sect2">
<h3 id="_what_is_the_potential_impact">What is the potential impact?</h3>
<div class="paragraph">
<p>SSRF usually results in unauthorized actions or data disclosure in the
vulnerable application or on a different system it can reach. Conditional to
what is reachable, remote command execution can be achieved, although it often
requires chaining with further exploitations.</p>
</div>
<div class="paragraph">
<p>Information disclosure is SSRF&#8217;s core outcome. Depending on the extracted data,
an attacker can perform a variety of different actions that can range from low
to critical severity.</p>
</div>
<div class="paragraph">
<p>Below are some real-world scenarios that illustrate some impacts of an attacker
exploiting the vulnerability.</p>
</div>
<div class="sect3">
<h4 id="_local_file_read_to_host_takeover">Local file read to host takeover</h4>
<div class="paragraph">
<p>An attacker manipulates an application into performing a local request for a
sensitive file, such as <code>~/.ssh/id_rsa</code>, by using the File URI scheme
<code>file://</code>.<br>
Once in possession of the SSH keys, the attacker establishes a remote
connection to the system hosting the web application.</p>
</div>
</div>
<div class="sect3">
<h4 id="_internal_network_reconnaissance">Internal Network Reconnaissance</h4>
<div class="paragraph">
<p>An attacker enumerates internal accessible ports from the affected server or
others to which the server can communicate by iterating over the port field in
the URL <code>http://127.0.0.1:{port}</code>.<br>
Taking advantage of other supported URL schemas (dependent on the affected
system), for example, <code>gopher://127.0.0.1:3306</code>, an attacker would be able to
connect to a database service and perform queries on it.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_fix_it_in_go_standard_library">How to fix it in Go Standard Library</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_code_examples">Code examples</h3>
<div class="paragraph">
<p>The following code is vulnerable to SSRF as it performs an HTTP request to a
URL defined by untrusted data.</p>
</div>
<div class="sect3">
<h4 id="_noncompliant_code_example">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-go" data-lang="go">import (
	"fmt"
	"io"
	"net/http"
)

func Example(w http.ResponseWriter, req *http.Request) {
	url := req.FormValue("url")
	resp, err := http.Get(url) // Noncompliant
	if err != nil {
		fmt.Fprintf(w, "Error when reading response: %s\n", err.Error())
		return
	}
	defer resp.Body.Close()
	respBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		fmt.Fprintf(w, "Error when reading response body: %s\n", err.Error())
		return
	}
	fmt.Fprintf(w, "Response: %s", string(respBytes))
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-go" data-lang="go">import (
	"fmt"
	"io"
	"net/http"
	"strings"
)

func Example(w http.ResponseWriter, req *http.Request) {
	url := req.FormValue("url")
	if !strings.HasPrefix(url, "https://example.com/") {
		fmt.Fprintln(w, "Specified host is not allowed")
		return
	}
	resp, err := http.Get(url)
	if err != nil {
		fmt.Fprintf(w, "Error when reading response: %s\n", err.Error())
		return
	}
	defer resp.Body.Close()
	respBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		fmt.Fprintf(w, "Error when reading response body: %s\n", err.Error())
		return
	}
	fmt.Fprintf(w, "Response: %s", string(respBytes))
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_how_does_this_work">How does this work?</h3>
<div class="sect3">
<h4 id="_pre_approved_urls">Pre-Approved URLs</h4>
<div class="paragraph">
<p>Create a list of authorized and secure URLs that you want the application
to be able to request.<br>
If a user input does not match an entry in this list, it should be rejected
because it is considered unsafe.</p>
</div>
<div class="paragraph">
<p><strong>Important note</strong>: The application must do validation on the server side. Not on
client-side front-ends.</p>
</div>
<div class="paragraph">
<p>The compliant code example uses such an approach.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_pitfalls">Pitfalls</h3>
<div class="sect3">
<h4 id="_the_trap_of_hasprefix_and_equivalents">The trap of 'HasPrefix' and equivalents</h4>
<div class="paragraph">
<p>When validating untrusted URLs by checking if they start with a trusted scheme
and authority pair <code>scheme://authority</code>, <strong>ensure that the validation string
contains a path separator <code>/</code> as the last character</strong>.<br></p>
</div>
<div class="paragraph">
<p>If the validation string does not contain a terminating path separator, the
SSRF vulnerability remains; only the exploitation technique changes.</p>
</div>
<div class="paragraph">
<p>Thus, a validation like <code>HasPrefix("https://example.com")</code> or an equivalent
with the regex <code>^https://example\.com.*</code> can be exploited with the following
URL <code><a href="https://example.com.malicous.example.com" class="bare">https://example.com.malicous.example.com</a></code>.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_fix_it_in_fiber">How to fix it in Fiber</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_code_examples_2">Code examples</h3>
<div class="paragraph">
<p>The following code is vulnerable to SSRF as it performs an HTTP request to a
URL defined by untrusted data.</p>
</div>
<div class="sect3">
<h4 id="_noncompliant_code_example_2">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-go" data-lang="go">import (
	"github.com/gofiber/fiber/v2"
)

func Example(c *fiber.Ctx) error {
	url := c.Query("url")
	agent := fiber.Get(url) // Noncompliant
	statusCode, body, errs := agent.String()
	if len(errs) &gt; 0 {
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"errs": errs,
		})
	}
	return c.Status(statusCode).SendString(body)
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution_2">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-go" data-lang="go">import (
	"strings"

	"github.com/gofiber/fiber/v2"
)

func Example(c *fiber.Ctx) error {
	url := c.Query("url")
	if !strings.HasPrefix(url, "https://example.com/") {
		return c.SendString("Specified url is not allowed")
	}
	agent := fiber.Get(url)
	statusCode, body, errs := agent.String()
	if len(errs) &gt; 0 {
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"errs": errs,
		})
	}
	return c.Status(statusCode).SendString(body)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_how_does_this_work_2">How does this work?</h3>
<div class="sect3">
<h4 id="_pre_approved_urls_2">Pre-Approved URLs</h4>
<div class="paragraph">
<p>Create a list of authorized and secure URLs that you want the application
to be able to request.<br>
If a user input does not match an entry in this list, it should be rejected
because it is considered unsafe.</p>
</div>
<div class="paragraph">
<p><strong>Important note</strong>: The application must do validation on the server side. Not on
client-side front-ends.</p>
</div>
<div class="paragraph">
<p>The compliant code example uses such an approach.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_pitfalls_2">Pitfalls</h3>
<div class="sect3">
<h4 id="_the_trap_of_hasprefix_and_equivalents_2">The trap of 'HasPrefix' and equivalents</h4>
<div class="paragraph">
<p>When validating untrusted URLs by checking if they start with a trusted scheme
and authority pair <code>scheme://authority</code>, <strong>ensure that the validation string
contains a path separator <code>/</code> as the last character</strong>.<br></p>
</div>
<div class="paragraph">
<p>If the validation string does not contain a terminating path separator, the
SSRF vulnerability remains; only the exploitation technique changes.</p>
</div>
<div class="paragraph">
<p>Thus, a validation like <code>HasPrefix("https://example.com")</code> or an equivalent
with the regex <code>^https://example\.com.*</code> can be exploited with the following
URL <code><a href="https://example.com.malicous.example.com" class="bare">https://example.com.malicous.example.com</a></code>.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_fix_it_in_fasthttp">How to fix it in fasthttp</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_code_examples_3">Code examples</h3>
<div class="paragraph">
<p>The following code is vulnerable to SSRF as it performs an HTTP request to a
URL defined by untrusted data.</p>
</div>
<div class="sect3">
<h4 id="_noncompliant_code_example_3">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-go" data-lang="go">import (
	"fmt"

	"github.com/valyala/fasthttp"
)

func Example(ctx *fasthttp.RequestCtx) {
	urlBytes := ctx.FormValue("url")
	url := string(urlBytes)

	statusCode, body, err := fasthttp.Get(nil, url) // Noncompliant
	if err != nil {
		fmt.Fprintf(ctx, "Error when making request: %s\n", err.Error())
		ctx.SetStatusCode(fasthttp.StatusInternalServerError)
		return
	}

	if statusCode != fasthttp.StatusOK {
		fmt.Fprintf(ctx, "Request failed with status code: %d\n", statusCode)
		ctx.SetStatusCode(statusCode)
		return
	}

	fmt.Fprintf(ctx, "Response: %s", string(body))
	ctx.SetStatusCode(fasthttp.StatusOK)
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution_3">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-go" data-lang="go">import (
	"fmt"
	"strings"

	"github.com/valyala/fasthttp"
)

func Example(ctx *fasthttp.RequestCtx) {
	urlBytes := ctx.FormValue("url")
	url := string(urlBytes)
	if !strings.HasPrefix(url, "https://example.com/") {
		fmt.Fprint(ctx, "Specified url is not allowed")
		ctx.SetStatusCode(fasthttp.StatusBadRequest)
		return
	}

	statusCode, body, err := fasthttp.Get(nil, url)
	if err != nil {
		fmt.Fprintf(ctx, "Error when making request: %s\n", err.Error())
		ctx.SetStatusCode(fasthttp.StatusInternalServerError)
		return
	}

	if statusCode != fasthttp.StatusOK {
		fmt.Fprintf(ctx, "Request failed with status code: %d\n", statusCode)
		ctx.SetStatusCode(statusCode)
		return
	}

	fmt.Fprintf(ctx, "Response: %s", string(body))
	ctx.SetStatusCode(fasthttp.StatusOK)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_how_does_this_work_3">How does this work?</h3>
<div class="sect3">
<h4 id="_pre_approved_urls_3">Pre-Approved URLs</h4>
<div class="paragraph">
<p>Create a list of authorized and secure URLs that you want the application
to be able to request.<br>
If a user input does not match an entry in this list, it should be rejected
because it is considered unsafe.</p>
</div>
<div class="paragraph">
<p><strong>Important note</strong>: The application must do validation on the server side. Not on
client-side front-ends.</p>
</div>
<div class="paragraph">
<p>The compliant code example uses such an approach.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_pitfalls_3">Pitfalls</h3>
<div class="sect3">
<h4 id="_the_trap_of_hasprefix_and_equivalents_3">The trap of 'HasPrefix' and equivalents</h4>
<div class="paragraph">
<p>When validating untrusted URLs by checking if they start with a trusted scheme
and authority pair <code>scheme://authority</code>, <strong>ensure that the validation string
contains a path separator <code>/</code> as the last character</strong>.<br></p>
</div>
<div class="paragraph">
<p>If the validation string does not contain a terminating path separator, the
SSRF vulnerability remains; only the exploitation technique changes.</p>
</div>
<div class="paragraph">
<p>Thus, a validation like <code>HasPrefix("https://example.com")</code> or an equivalent
with the regex <code>^https://example\.com.*</code> can be exploited with the following
URL <code><a href="https://example.com.malicous.example.com" class="bare">https://example.com.malicous.example.com</a></code>.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_standards">Standards</h3>
<div class="ulist">
<ul>
<li>
<p>OWASP - <a href="https://owasp.org/Top10/A10_2021-Server-Side_Request_Forgery_%28SSRF%29/">Top 10 2021 Category A10 - Server-Side Request Forgery (SSRF)</a></p>
</li>
<li>
<p>OWASP - <a href="https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control">Top 10 2017 Category A5 - Broken Access Control</a></p>
</li>
<li>
<p>CWE - <a href="https://cwe.mitre.org/data/definitions/20">CWE-20 - Improper Input Validation</a></p>
</li>
<li>
<p>CWE - <a href="https://cwe.mitre.org/data/definitions/918">CWE-918 - Server-Side Request Forgery (SSRF)</a></p>
</li>
<li>
<p>STIG Viewer - <a href="https://stigviewer.com/stigs/application_security_and_development/2024-12-06/finding/V-222609">Application Security and Development: V-222609</a> - The application must not be subject to input handling vulnerabilities.</p>
</li>
</ul>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_implementation_specification">Implementation Specification</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_message">Message</h3>
<div class="paragraph">
<p>Change this code to not construct the request from user-controlled data.</p>
</div>
</div>
<div class="sect2">
<h3 id="_highlighting">Highlighting</h3>
<div class="paragraph">
<p>"[varname]" is tainted (assignments and parameters)</p>
</div>
<div class="paragraph">
<p>this argument is tainted (method invocations)</p>
</div>
<div class="paragraph">
<p>the returned value is tainted (returns &amp; method invocations results)</p>
</div>
<hr>
</div>
</div>
</div>