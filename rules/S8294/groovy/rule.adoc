This rule raises an issue when a Grails domain class contains a field that references a service class.

== Why is this an issue?

Grails domain classes should focus on data representation and basic validation logic. They should not contain references to service classes because this violates the separation of concerns principle.

When domain classes have service dependencies, it creates tight coupling between the data layer and the business logic layer. This makes the code harder to test, maintain, and understand. Domain objects become dependent on external services, which can lead to complex initialization requirements and circular dependencies.

The proper Grails architecture separates concerns clearly:

* Domain classes handle data representation, constraints, and basic validation
* Service classes contain business logic and coordinate between different components
* Controllers handle web requests and delegate to services

By injecting services into domain classes, you blur these boundaries and create an architecture that is harder to reason about and maintain.

=== What is the potential impact?

This architectural violation can lead to several problems:

* **Tight coupling**: Domain objects become dependent on service implementations, making them harder to test in isolation
* **Circular dependencies**: Services often work with domain objects, creating potential circular reference issues
* **Complex initialization**: Domain objects may require service dependencies to be properly initialized, complicating object creation
* **Reduced testability**: Unit testing domain logic becomes more complex when services are involved
* **Architectural confusion**: The clear separation between data and business logic layers becomes blurred

== How to fix it

Remove the service reference from the domain class. Move any business logic that uses the service to an appropriate service class instead.

=== Code examples

==== Noncompliant code example

[source,groovy,diff-id=1,diff-type=noncompliant]
----
class Person {
    String firstName
    String lastName
    
    PersonService personService // Noncompliant
    
    def getFullName() {
        return personService.formatName(firstName, lastName)
    }
}
----

==== Compliant solution

[source,groovy,diff-id=1,diff-type=compliant]
----
class Person {
    String firstName
    String lastName
    
    // No service injection - keep domain class focused on data
    def getFullName() {
        return "${firstName} ${lastName}"
    }
}

// Business logic stays in service classes
class PersonService {
    def formatName(String firstName, String lastName) {
        return "${firstName} ${lastName}"
    }
}
----

== Resources

=== Documentation

 * Grails Domain Classes Guide - https://docs.grails.org/latest/guide/GORM.html#domainClasses[Official Grails documentation on domain classes and their proper usage]

 * Grails Services Guide - https://docs.grails.org/latest/guide/services.html[Official Grails documentation on service classes and dependency injection]

=== Standards

 * Separation of Concerns - https://en.wikipedia.org/wiki/Separation_of_concerns[Fundamental software engineering principle for organizing code responsibilities]

=== Related rules

 * RSPEC-1258 - https://rules.sonarsource.com/java/RSPEC-1258[Classes should not be coupled to too many other classes]
