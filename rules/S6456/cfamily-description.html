<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A <em>requires-expression</em> is a list of requirements that can be of different natures. <em>Simple-requirements</em> are expressions that do not start with the keyword <code>requires</code> and <em>compound-requirements</em> are expressions surrounded by curly brackets potentially followed by a <code>noexcept</code> specification and return type requirements.</p>
</div>
<div class="paragraph">
<p>In both cases, the expressions are not evaluated. They will only be checked for validity, and if the expression is invalid, the <em>requires-expression</em> evaluates to <code>false</code>.</p>
</div>
<div class="paragraph">
<p>When we write a concept check or a type predicate, the intent is usually to evaluate them, therefore, they donâ€™t really belong in a <em>simple-requirement</em> or a <em>compound-requirement</em>. Instead, they should either be used directly in a concept definition (outside of a <em>requires-expression</em>) or, less often, as a <em>nested-requirement</em> (a requirement introduced by the <code>requires</code> keyword within the <em>requires-expression</em>).</p>
</div>
<div class="paragraph">
<p>This rule detects concept checks and standard type predicates (from the header <code>&lt;type_traits&gt;</code>) in single and compound requirements of <em>requires-expressions</em>.</p>
</div>
<div class="sect2">
<h3 id="_noncompliant_code_example">Noncompliant code example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">template&lt;typename T&gt;
concept TriviallyCopyable = requires {
   std::copyable&lt;T&gt;;  // Noncompliant
   {std::is_trivally_copy_constructible_v&lt;T&gt;}; // Noncompliant
   std::is_trivally_move_constructible&lt;T&gt;::value; // Noncompliant
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>This concept is always <code>true</code>, for every type <code>T</code>, because expressions such as <code>std::copyable&lt;T&gt;</code> are always well-formed.</p>
</div>
</div>
<div class="sect2">
<h3 id="_compliant_solution">Compliant solution</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">template&lt;typename T&gt;
concept TriviallyCopyable =
    std::copyable&lt;T&gt; &amp;&amp;
    std::is_trivially_copy_constructible_v&lt;T&gt; &amp;&amp;
    std::is_trivially_move_constructible&lt;T&gt;::value;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">template&lt;typename T&gt;
concept TriviallyCopyable = requires {
   requires std::copyable&lt;T&gt;;
   requires std::is_trivially_copy_constructible_v&lt;T&gt; &amp;&amp;
       std::is_trivially_move_constructible&lt;T&gt;::value;
};</code></pre>
</div>
</div>
</div>
</div>
</div>