This rule raises an issue when there are statements after a `break` statement within the same block scope in a loop.

== Why is this an issue?

The `break` statement immediately exits the current loop, transferring control to the statement following the loop. Any code that appears after a `break` statement in the same block will never be executed.

This unreachable code creates several problems:

* **Dead code**: The statements will never run, making them useless and potentially confusing
* **Maintenance burden**: Developers might waste time trying to understand or modify code that never executes
* **Logic errors**: The presence of unreachable code often indicates a misunderstanding of control flow or a copy-paste error
* **Code bloat**: Unreachable code increases the size of your program without adding any functionality

In Go, the `break` statement works the same way as in many other languages - it immediately terminates the innermost loop and continues execution after the loop block. Understanding this behavior is crucial for writing correct control flow logic.

=== What is the potential impact?

While unreachable code doesn't cause runtime errors, it can lead to confusion during code reviews and maintenance. It may also indicate logical errors in the program's control flow that could mask intended functionality.

== How to fix it

Remove the unreachable code after the break statement. If the code was intended to execute, move it to an appropriate location before the break or restructure the logic.

=== Code examples

==== Noncompliant code example

[source,go,diff-id=1,diff-type=noncompliant]
----
for i := 1; i <= 5; i++ {
    fmt.Println(i)
    if i == 3 {
        break
        fmt.Println("This will never execute") // Noncompliant
        processData(i) // Noncompliant
    }
}
----

==== Compliant solution

[source,go,diff-id=1,diff-type=compliant]
----
for i := 1; i <= 5; i++ {
    fmt.Println(i)
    if i == 3 {
        break
    }
    // Code here is reachable in other iterations
}
----

== Resources

=== Documentation

 * Go Language Specification - Break statements - https://go.dev/ref/spec#Break_statements[Official Go specification explaining break statement behavior]

 * Effective Go - Control structures - https://go.dev/doc/effective_go#control-structures[Best practices for using control structures in Go]

=== Standards

 * CWE-561: Dead Code - https://cwe.mitre.org/data/definitions/561.html[Code that can never be executed and should be removed]

=== Related rules

 * RSPEC-1763 - https://rules.sonarsource.com/javascript/RSPEC-1763/[Jump statements should not be followed by other statements (JavaScript)]
