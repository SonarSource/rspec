== Why is this an issue?

Because ``++reinterpret_cast++`` does not perform any type safety validations, it can perform dangerous conversions between unrelated types, often leading to undefined behavior.

In some cases, ``++reinterpret_cast++`` can be simply replaced by a more focused cast, such as ``++static_cast++`` or ``++dynamic_cast++``.

If the goal is to access the binary representation of an object, ``++reinterpret_cast++`` leads to undefined behavior. Since {cpp}20, the best option is to use ``++std::bit_cast++``: it allows reinterpreting a value as being of a different type of the same length, preserving its binary representation. Before {cpp}20, `std::memcpy` must be used. See S6181 for more details.

S5275 covers specific scenarios with ``++reinterpret_cast++`` that lead to undefined behavior.

This rule raises an issue when ``++reinterpret_cast++`` is used.

=== Noncompliant code example

[source,cpp]
----
  class A { public: virtual ~A(){} };
  class B : public A { public: void doSomething(){} };

  void example(A *a, float f) {
    B* b = reinterpret_cast<B*>(a) // Noncompliant, another cast is more appropriate
    b->doSomething();

    static_assert(sizeof(float) == sizeof(uint32_t));
    uint32_t x = reinterpret_cast<uint32_t&>(f); // Noncompliant and undefined behavior
  }
----


=== Compliant solution

[source,cpp]
----
  class A { public: virtual ~A(){} };
  class B : public A { public: void doSomething(){} };

  void example(A *a, float f) {
    if (B* b = dynamic_cast<B*>(a)) {
      b->doSomething();
    }

    static_assert(sizeof(float) == sizeof(uint32_t));
    uint32_t x = std::bit_cast<uint32_t>(f);
    // Or, before C++20
    uint32_t y;
    std::memcpy(&y, &f, sizeof(float));
  }
----

== Resources

=== Documentation

* {cpp} reference - https://en.cppreference.com/w/cpp/language/reinterpret_cast[``++reinterpret_cast++`` conversion]

=== External coding guidelines

* {cpp} Core Guidelines - https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#prosafety-type-safety-profile[Type.1: Avoid casts]

=== Related rules

* S5275 - "reinterpret_cast" should be used carefully
* S6181 - "std::bit_cast" should be used to reinterpret binary representation instead of "std::memcpy"


ifdef::env-github,rspecator-view[]

'''
== Implementation Specification
(visible only on this page)

=== Message

Replace "reinterpret_cast" with a safer cast or refactor the code to avoid such an unsafe cast.


=== Highlighting

``++reinterpret_cast++`` keyword


'''
== Comments And Links
(visible only on this page)

include::../comments-and-links.adoc[]

endif::env-github,rspecator-view[]
