<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>If you invoked a method with arguments of the wrong type, you would typically expect an error at compile time (if not in the IDE). However, when the expected parameter is a class with a single-argument constructor, the compiler will implicitly pass the method argument to that constructor to implicitly create an object of the correct type for the method invocation. Alternately, if the wrong type has a conversion operator to the correct type, the operator will be called to create an object of the needed type.</p>
</div>
<div class="paragraph">
<p>But just because you <em>can</em> do something, that doesn&#8217;t mean you <em>should</em>, and using implicit conversions makes the execution flow difficult to understand. Readers may not notice that a conversion occurs, and if they do notice, it will raise a lot of questions: Is the source type able to convert to the destination type? Is the destination type able to construct an instance from the source? Is it both? And if so, which method is called by the compiler?</p>
</div>
<div class="paragraph">
<p>Moreover, implicit promotions can lead to unexpected behavior, so they should be prevented by using the <code>explicit</code> keyword on single-argument constructors and (C&#43;&#43;11) conversion operators. Doing so will prevent the compiler from performing implicit conversions.</p>
</div>
<div class="sect2">
<h3 id="_noncompliant_code_example">Noncompliant code example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">struct Bar {
};

struct Foo {
  Foo(Bar&amp; bar); // Noncompliant; allow implicit conversion from 'Bar' to 'Foo'
};

struct Baz {
  operator Foo(); // Noncompliant; allow implicit conversion from 'Baz' to 'Foo'
};

void func(const Foo&amp; b); // this function needs a 'Foo' not a 'Bar' nor a 'Baz'

int test(Bar&amp; bar, Baz&amp; baz) {
  func(bar); // implicit conversion using Foo::Foo(Bar&amp; bar)
  func(baz); // implicit conversion using Baz::operator Foo()
  func(baz);
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_compliant_solution">Compliant solution</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">struct Bar {
};

struct Foo {
  explicit Foo(Bar&amp; bar); // Compliant, using "explicit" keyword
};

struct Baz {
  Foo asFoo();             // Compliant, explicit function
  explicit operator Foo(); // Compliant, using C++11 "explicit" keyword for conversion function
};

void func(const Foo&amp; b); // this function needs a 'Foo' not a 'Bar' nor a 'Baz'

int test(Bar&amp; bar, Baz&amp; baz) {
  func(Foo(bar));              // explicit conversion using Foo::Foo(Bar&amp; bar)
  func(baz.asFoo());           // explicit conversion using Baz::asFoo()
  func(static_cast&lt;Foo&gt;(baz)); // explicit conversion using Baz::operator Foo()
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_exceptions">Exceptions</h3>
<div class="paragraph">
<p>The issue is not raised for constructors that have a single parameter of type <code>std::initializer_list</code> -
such constructors have special meaning and allow objects to be constructed from brace delimited list of initializers.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">struct Container {
  Container(std::initializer_list&lt;int&gt; elems); // Compliant
};

void handle(Container const&amp; c);

int test(Bar&amp; bar, Baz&amp; baz) {
  Container c1{1, 2, 3};      // OK whether the constructor is explicit or not
  Container c2 = {1, 2, 3};   // Ill-formed if constructor would be explicit
  handle({1, 2, 3});          // Ill-formed if constructor would be explicit
  handle(Container{1, 2, 3}); // OK whether the constructor is explicit or not
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>C&#43;&#43;20 introduced conditional <code>explicit(expr)</code> that allows developers to make a constructor or conversion operator conditionally explicit depending on the value of <code>expr</code>.
The new syntax allows a constructor or conversion operator declared with an <code>explicit(expr)</code> specifier to be implicit when <code>expr</code> evaluates to <code>false</code>.
The issue is not raised in such situation.</p>
</div>
<div class="paragraph">
<p>Additionally, developers can use <code>explicit(false)</code> to mark constructors or conversion operators as intentionally implicit.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>MISRA C&#43;&#43;:2008, 12-1-3 - All constructors that are callable with a single argument of fundamental type shall be declared <code>explicit</code>.</p>
</li>
<li>
<p>C++ Core Guidelines - <a href="https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c46-by-default-declare-single-argument-constructors-explicit">C.46: By default, declare single-argument constructors explicit</a></p>
</li>
<li>
<p>C++ Core Guidelines - <a href="https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c164-avoid-implicit-conversion-operators">C.164: Avoid implicit conversion operators</a></p>
</li>
</ul>
</div>
<hr>
</div>
</div>
<div class="sect1">
<h2 id="_implementation_specification">Implementation Specification</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_message">Message</h3>
<div class="ulist">
<ul>
<li>
<p>Add the "explicit" keyword to this constructor.</p>
</li>
<li>
<p>Replace this conversion operator with a function or (C&#43;&#43;11) add the "explicit" keyword.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_highlighting">Highlighting</h3>
<div class="paragraph">
<p>constructor or conversion operator id</p>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_comments_and_links">Comments And Links</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_is_duplicated_by_s1021">is duplicated by: <a data-rspec-id="S1021" class="rspec-auto-link">S1021</a></h3>

</div>
</div>
</div>