<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The address of an automatic object should not be persisted beyond the object&#8217;s lifetime.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>An automatic object is an object whose lifetime is automatically managed.
The storage for an automatic object, e.g. a local variable, is allocated at the beginning of the enclosing code block and is deallocated at the end.
This is commonly referred to as "allocated on the stack".</p>
</div>
<div class="paragraph">
<p>If the address of an automatic object is assigned to another automatic object of larger scope, a static or extern object, or if it is returned from a function (using <code>return</code> or an output parameter), then there will be a point where the address will point to an object that ceased to exist.
In that case, the address becomes invalid, and attempts to dereference the invalid address&#8201;&#8212;&#8201;trying to access the object that ceased to exist&#8201;&#8212;&#8201;result in undefined behavior.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">int *global = nullptr;

int* bar(int **out) {
  int local = 42;
  int *ptr;
  global = &amp;local; // Noncompliant: assigning the address of an object allocated on the stack to a global variable
  {
    int i = 9001;
    ptr = &amp;i; // Noncompliant: assigning the address of a stack-allocated object to an object that outlives it
  }
  *out = &amp;local; // Noncompliant: returning the address of an object allocated on the stack (via output parameter)
  return &amp;local; // Noncompliant: returning the address of an object allocated on the stack
}</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_what_is_the_potential_impact">What is the potential impact?</h3>
<div class="paragraph">
<p>Persisting addresses of objects with automatic storage past their lifetime is dangerous as it creates invalid addresses.
Attempts to access objects that no longer exist through such invalid addresses result in undefined behavior.</p>
</div>
<div class="paragraph">
<p>For programs that exercise undefined behavior, the compiler is no longer bound by the language specification.
The application may crash or, even worse, the application may appear to execute correctly while losing data or producing incorrect results.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_fix_it">How to fix it</h2>
<div class="sectionbody">
<div class="paragraph">
<p>There are multiple approaches to avoid persisting addresses of objects with automatic storage after their lifetime ended:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Make a full copy of the object instead of using its address.</p>
</li>
<li>
<p>Allocate the object on the heap (free-store) and deallocate it once done.</p>
</li>
<li>
<p>Create the automatic object in a larger scope where it outlives all accesses through its address.</p>
</li>
<li>
<p>Reduce the scope of objects that store the address of the original automatic object.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_code_examples">Code examples</h3>
<div class="sect3">
<h4 id="_noncompliant_code_example">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">int* bar(void) {
  int local_auto = 42;
  return &amp;local_auto; // Noncompliant: returns the address of a stack-allocated object
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">int foo() {
  int local_auto = 42;
  return local_auto; // Compliant: returns a value rather than an address
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">int* foo() {
  int *local_auto = new int(42);
  return local_auto; // Compliant: returns the address of a heap-allocated object
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_noncompliant_code_example_2">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">const char *str_ptr = nullptr;

void bar() {
  const char str[] = "This will change";
  str_ptr = str; // Noncompliant: address of `str` becomes invalid when `str` goes out of scope
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution_2">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">void bar() {
  const char str[] = "This will change";
  const char *str_ptr = str; // Compliant: `str_ptr` has the same storage duration as `str`
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#include &lt;string&gt;

std::string bar() {
  std::string str = "This will change";
  return str; // Compliant: `str` will be moved to the caller (using C++ move semantics)
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_noncompliant_code_example_3">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#include &lt;array&gt;
#include &lt;cstddef&gt;

int *buz() {
  int buf[256];
  for (size_t i = 0; i &lt; std::size(buf); ++i) {
    buf[i] = i;
  }
  return buf; // Noncompliant: returns address of stack-allocated object
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution_3">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#include &lt;array&gt;
#include &lt;cstddef&gt;
#include &lt;numeric&gt;

void buz(int *buf, size_t length) {
  std::iota(&amp;buf[0], &amp;buf[length], 0);
}

void caller() {
  int buf[256];
  buz(buf, std::size(buf));
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#include &lt;array&gt;

std::array&lt;int, 3&gt; buz() {
  std::array&lt;int, 3&gt; buf = {1, 2, 3};
  return buf; // Compliant: `buf` will by copied to the caller; return-value optimization (RVO) might be invoked
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#include &lt;numeric&gt;
#include &lt;vector&gt;

std::vector&lt;int&gt; buz() {
  std::vector&lt;int&gt; buf;
  std::iota(buf.begin(), buf.end(), 0);
  return buf; // Compliant: `buf` will be moved to the caller (using C++ move semantics)
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_noncompliant_code_example_4">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#include &lt;algorithm&gt;
#include &lt;array&gt;

void fun(char **out) {
  char buffer[64];
  std::fill(std::begin(buffer), std::end(buffer), 42);
  *out = buffer; // Noncompliant: `buffer`'s address becomes invalid once it goes out of scope
}

void caller() {
  char *p;
  fun(&amp;p);
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution_4">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#include &lt;algorithm&gt;
#include &lt;array&gt;

char buffer[64];

void fun(char **out) {
  std::fill(std::begin(buffer), std::end(buffer), 42);
  *out = buffer; // Compliant: `buffer`'s lifetime is the program's lifetime
}

void caller() {
  char *p;
  fun(&amp;p);
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#include &lt;vector&gt;

std::vector&lt;int&gt; fun() {
  std::vector&lt;int&gt; buf(/* count */ 64, /* initial value */ 42);
  return buf;
}

void caller() {
  auto buf = fun();
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_conference_presentations">Conference presentations</h3>
<div class="ulist">
<ul>
<li>
<p>CppCon 2018 - <a href="https://www.youtube.com/watch?v=uQyT-5iWUow&amp;ab_channel=CppCon">Surprises in Object Lifetime</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_standards">Standards</h3>
<div class="ulist">
<ul>
<li>
<p>CERT - <a href="https://wiki.sei.cmu.edu/confluence/x/UtcxBQ">DCL30-C. Declare objects with appropriate storage durations</a></p>
</li>
<li>
<p>CERT - <a href="https://wiki.sei.cmu.edu/confluence/x/OXw-BQ">EXP54-CPP. Do not access an object outside of its lifetime</a></p>
</li>
<li>
<p>CERT - <a href="https://wiki.sei.cmu.edu/confluence/x/6NUxBQ">MSC00-C. Compile cleanly at high warning levels</a></p>
</li>
<li>
<p>MISRA C:2004, 17.6 - The address of an object with automatic storage shall not be assigned to another object that may persist after the first object has ceased to exist</p>
</li>
<li>
<p>MISRA C&#43;&#43;:2008, 7-5-2 - The address of an object with automatic storage shall not be assigned to another object that may persist after the first object has ceased to exist</p>
</li>
<li>
<p>MISRA C:2012, 18.6 - The address of an object with automatic storage shall not be copied to another object that persists after the first object has ceased to exist</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_related_rules_but_not_implemented">Related rules but not implemented</h3>
<div class="ulist">
<ul>
<li>
<p><a data-rspec-id="S837" class="rspec-auto-link">S837</a> detects attempts to return addresses of automatic variables</p>
</li>
<li>
<p><a data-rspec-id="S839" class="rspec-auto-link">S839</a> ensures that functions do not return references or pointers to parameters that are passed by reference</p>
</li>
</ul>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_implementation_specification">Implementation Specification</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_message">Message</h3>
<div class="paragraph">
<p>The address of 'xxx' is invalid once the function returns.</p>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_comments_and_links">Comments And Links</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_is_duplicated_by_s838">is duplicated by: <a data-rspec-id="S838" class="rspec-auto-link">S838</a></h3>

</div>
<div class="sect2">
<h3 id="_is_related_to_s837">is related to: <a data-rspec-id="S837" class="rspec-auto-link">S837</a></h3>

</div>
<div class="sect2">
<h3 id="_is_related_to_s839">is related to: <a data-rspec-id="S839" class="rspec-auto-link">S839</a></h3>

</div>
</div>
</div>