The address of an automatic object should not be persisted beyond the object's lifetime.

== Why is this an issue?

An automatic object is an object whose lifetime is automatically managed.
The storage for an automatic object, e.g. a local variable, is allocated at the beginning of the enclosing code block and is deallocated at the end.

If the address of an automatic object is assigned to another automatic object of larger scope, a static or extern object, or if it is returned from a function (using `return` or an output parameter), then there will be a point where the address will point to an object that ceased to exist.
In that case, the address becomes invalid and attempts to dereference the invalid address result in undefined behavior.

[source,cpp]
----
int *global = nullptr;

int* bar(int **out) {
  int local = 42;
  int *ptr;
  global = &local; // Noncompliant: assigning the address of an object allocated on the stack to a global variable
  {
    int i = 9001;
    ptr = &i; // Noncompliant: assigning the address of a stack-allocated object to an object that outlives it
  }
  *out = &local; // Noncompliant: returning the address of an object allocated on the stack (via output parameter)
  return &local; // Noncompliant: returning the address of an object allocated on the stack
}
----


== What is the potential impact?

Persisting addresses of objects with automatic storage past their lifetime is dangerous as it may create invalid addresses.
Attempts to access such invalidated addresses result in undefined behavior.

For programs that exercise undefined behavior, the compiler is no longer bound by the language specification.
The application may crash or, even worse, the application may appear to execute correctly while losing data or producing incorrect results.


== How to fix it

There are multiple approaches to avoid persisting addresses of objects with automatic storage after their lifetime ended:

* Make a full copy of the object instead of using an address.
* Allocate the address on the heap and deallocate it once done.
* Create the automatic object in a larger scope where it outlives all storages of its address.
* Reduce the scope of objects that store the address of the original automatic object.


=== Code examples

==== Noncompliant code example

[source,cpp,diff-id=1,diff-type=noncompliant]
----
int* bar(void) {
  int local_auto = 42;
  return &local_auto; // Noncompliant: returns the address of a stack-allocated object
}
----

==== Compliant solution

[source,cpp,diff-id=1,diff-type=compliant]
----
int foo() {
  int local_auto = 42;
  return local_auto; // Compliant: returns a value rather than an address
}
----

[source,cpp,diff-id=1,diff-type=compliant]
----
int* foo() {
  int *local_auto = new int(42);
  return local_auto; // Compliant: returns the address of a heap-allocated object
}
----

==== Noncompliant code example

[source,cpp,diff-id=2,diff-type=noncompliant]
----
const char *str_ptr = nullptr;

void bar() {
  const char str[] = "This will change";
  str_ptr = str; // Noncompliant: address of `str` becomes invalid when `str` goes out of scope
}
----

==== Compliant solution

[source,cpp,diff-id=2,diff-type=compliant]
----
void bar() {
  const char str[] = "This will change";
  const char *str_ptr = str; // Compliant: `str_ptr` has the same storage duration as `str`
}
----

==== Noncompliant code example

[source,cpp,diff-id=3,diff-type=noncompliant]
----
int *buz() {
  int array[256];
  for (size_t i = 0; i < std::size(array); ++i) {
    array[i] = i;
  }
  return array; // Noncompliant: returns address of stack-allocated object
}
----

==== Compliant solution

[source,cpp,diff-id=3,diff-type=compliant]
----
void buz(int *array, size_t length) {
  for (size_t i = 0; i < length; ++i) {
    array[i] = i;
  }
}

void caller() {
  int array[256];
  buz(array, std::size(array));
}
----

==== Noncompliant code example

[source,cpp,diff-id=4,diff-type=noncompliant]
----
void fun(char **out) {
  char buffer[64];
  std::fill(std::begin(buffer), std::end(buffer), 42);
  *out = buffer; // Noncompliant: `buffer`'s address becomes invalid once it goes out of scope
}

void caller() {
  char *p;
  fun(&p);
}
----

==== Compliant solution

[source,cpp,diff-id=4,diff-type=compliant]
----
char buffer[64];

void fun(char **out) {
  std::fill(std::begin(buffer), std::end(buffer), 42);
  *out = buffer; // Compliant: `buffer`'s lifetime is the program's lifetime
}

void caller() {
  char *p;
  fun(&p);
}
----


== Resources

=== Conference presentations

* CppCon 2018 - https://www.youtube.com/watch?v=uQyT-5iWUow&ab_channel=CppCon[Surprises in Object Lifetime]

=== Standards

* CERT - https://wiki.sei.cmu.edu/confluence/x/UtcxBQ[DCL30-C. Declare objects with appropriate storage durations]
* CERT - https://wiki.sei.cmu.edu/confluence/display/cplusplus/EXP54-CPP.+Do+not+access+an+object+outside+of+its+lifetime[EXP54-CPP. Do not access an object outside of its lifetime]
* CERT - https://wiki.sei.cmu.edu/confluence/display/c/MSC00-C.+Compile+cleanly+at+high+warning+levels[MSC00-C. Compile cleanly at high warning levels]
* MISRA C:2004, 17.6 - The address of an object with automatic storage shall not be assigned to another object that may persist after the first object has ceased to exist
* MISRA {cpp}:2008, 7-5-2 - The address of an object with automatic storage shall not be assigned to another object that may persist after the first object has ceased to exist
* MISRA C:2012, 18.6 - The address of an object with automatic storage shall not be copied to another object that persists after the first object has ceased to exist


ifdef::env-github,rspecator-view[]

'''
== Implementation Specification
(visible only on this page)

=== Message

The address of 'xxx' is invalid once the function returns.


'''
== Comments And Links
(visible only on this page)

=== is duplicated by: S838

=== is related to: S837

=== is related to: S839

endif::env-github,rspecator-view[]
