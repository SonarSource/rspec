This rule raises an issue when populating a NumPy array with the Python `range` function.

== Why is this an issue?

Python lists and NumPy arrays have a fundamental difference. 
Python lists can hold different types of element as NumPy arrays are homogeneous, meaning all elements have the same type. 
This difference allows NumPy arrays for better memory management as it can store data in contiguous memory location. 
It also allows for optimization of certain operations, for example with the help of parallelization.


Creating a NumPy array by first generating a Python list with the `range` function removes the benefits cited above.
Instead, try using `np.arange` which allows for better readability and yield better performance in terms of memory and speed of execution.

== How to fix it

To fix this issue use the `np.arange` function to create a new NumPy array, instead of the builtin `range` function.

=== Code examples

==== Noncompliant code example

[source,python,diff-id=1,diff-type=noncompliant]
----
import numpy as np

arr = []
for i in range(10):
    arr.append(i)

arr = np.array(arr) # Noncompliant

arr = np.array([*range(10)]) # Noncompliant

----

==== Compliant solution

[source,python,diff-id=1,diff-type=compliant]
----
import numpy as np

arr = np.arange(10) # Compliant
----


== Resources

=== Documentation

NumPy Documentation - https://numpy.org/doc/stable/user/basics.creation.html#intrinsic-numpy-array-creation-functions[Intrisinc NumPy array creation functions]

=== Articles & blog posts

Medium Blog - https://medium.com/@24littledino/range-python-vs-arange-numpy-3dc2953b9467[Range(Python) vs. Arange(NumPy)]

