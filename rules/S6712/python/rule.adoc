This rule raises an issue when populating a NumPy array with the Python `range` function.

== Why is this an issue?

Python lists and NumPy arrays have a fundamental difference: Python lists can hold different types of elements, 
while NumPy arrays are homogeneous, meaning all elements have the same type. 
This difference allows for NumPy arrays for better memory management, as they can store data in contiguous memory locations. 
It also allows for optimization of certain operations, for example with the help of parallelization.


These benefits are lost when a NumPy array is created by first generating a Python list by using the range function.
Using `np.arange` instead allows for improved readability and yields better performance in terms of memory and speed of execution.

== How to fix it

To fix this issue use the `np.arange` function to create a new NumPy array, instead of the builtin `range` function.

=== Code examples

==== Noncompliant code example

[source,python,diff-id=1,diff-type=noncompliant]
----
import numpy as np

arr = []
for i in range(10):
    arr.append(i)

arr = np.array(arr) # Noncompliant

arr = np.array([*range(10)]) # Noncompliant

----

==== Compliant solution

[source,python,diff-id=1,diff-type=compliant]
----
import numpy as np

arr = np.arange(10) # Compliant
----


== Resources

=== Documentation

* NumPy Documentation - https://numpy.org/doc/stable/user/basics.creation.html#intrinsic-numpy-array-creation-functions[Intrinsinc NumPy array creation functions]

=== Articles & blog posts

* Medium Blog - https://medium.com/@24littledino/range-python-vs-arange-numpy-3dc2953b9467[Range(Python) vs. Arange(NumPy)]

