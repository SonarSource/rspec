<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This rule raises an issue when function parameters use concrete types (like structs or specific implementations) instead of interface types that could abstract the required functionality.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Using concrete types in function parameters creates tight coupling between your function and specific implementations. This makes your code less flexible and harder to maintain.</p>
</div>
<div class="paragraph">
<p>When you depend on concrete types, you cannot easily substitute different implementations. This becomes problematic when you need to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Write unit tests with mock objects</p>
</li>
<li>
<p>Support multiple data formats or protocols</p>
</li>
<li>
<p>Extend functionality without changing existing code</p>
</li>
<li>
<p>Follow dependency injection patterns</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Interfaces in Go are implicit and lightweight. They define behavior contracts without specifying implementation details. By accepting interfaces instead of concrete types, your functions become more generic and reusable.</p>
</div>
<div class="paragraph">
<p>This principle aligns with Go&#8217;s composition-oriented design philosophy. Instead of inheritance hierarchies, Go encourages small, focused interfaces that can be easily implemented and combined.</p>
</div>
<div class="sect2">
<h3 id="_what_is_the_potential_impact">What is the potential impact?</h3>
<div class="paragraph">
<p>Using concrete types in function parameters can lead to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Reduced testability</strong>: Difficult to create mock objects for unit testing</p>
</li>
<li>
<p><strong>Tight coupling</strong>: Functions become dependent on specific implementations</p>
</li>
<li>
<p><strong>Limited extensibility</strong>: Adding new implementations requires changing function signatures</p>
</li>
<li>
<p><strong>Maintenance burden</strong>: Code becomes harder to refactor and evolve</p>
</li>
<li>
<p><strong>Reduced reusability</strong>: Functions cannot work with alternative implementations</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_fix_it">How to fix it</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Define an interface that captures the required behavior and use it as the parameter type instead of the concrete type. This allows any type implementing the interface to be passed to the function.</p>
</div>
<div class="sect2">
<h3 id="_code_examples">Code examples</h3>
<div class="sect3">
<h4 id="_noncompliant_code_example">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-go" data-lang="go">func sendResponse(sending *sync.Mutex, req *Request,
    reply interface{}, enc *gob.Encoder, errmsg string) { // Noncompliant
    // Function is tightly coupled to gob.Encoder
    enc.Encode(reply)
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-go" data-lang="go">type ServerCodec interface {
    ReadRequestHeader(*Request) error
    ReadRequestBody(interface{}) error
    WriteResponse(*Response, interface{}) error
    Close() error
}

func sendResponse(sending *sync.Mutex, req *Request,
    reply interface{}, enc ServerCodec, errmsg string) {
    // Function can work with any ServerCodec implementation
    enc.WriteResponse(response, reply)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_documentation">Documentation</h3>
<div class="ulist">
<ul>
<li>
<p>Effective Go - Interfaces - <a href="https://go.dev/doc/effective_go#interfaces_and_types">Official Go documentation on interfaces and their effective use</a></p>
</li>
<li>
<p>JSON-RPC: a tale of interfaces - <a href="https://go.dev/blog/json-rpc-tale-of-interfaces">Go blog post demonstrating interface refactoring in the RPC package</a></p>
</li>
<li>
<p>Go Interfaces - <a href="https://go.dev/tour/methods/9">Go Tour section on interfaces and their implementation</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_standards">Standards</h3>
<div class="ulist">
<ul>
<li>
<p>SOLID Principles - Dependency Inversion Principle - <a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle">High-level modules should not depend on low-level modules; both should depend on abstractions</a></p>
</li>
<li>
<p>SOLID Principles - Interface Segregation Principle - <a href="https://en.wikipedia.org/wiki/Interface_segregation_principle">Clients should not be forced to depend upon interfaces they do not use</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>