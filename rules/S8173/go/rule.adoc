This rule raises an issue when function parameters use concrete types (like structs or specific implementations) instead of interface types that could abstract the required functionality.

== Why is this an issue?

Using concrete types in function parameters creates tight coupling between your function and specific implementations. This makes your code less flexible and harder to maintain.

When you depend on concrete types, you cannot easily substitute different implementations. This becomes problematic when you need to:

* Write unit tests with mock objects
* Support multiple data formats or protocols
* Extend functionality without changing existing code
* Follow dependency injection patterns

Interfaces in Go are implicit and lightweight. They define behavior contracts without specifying implementation details. By accepting interfaces instead of concrete types, your functions become more generic and reusable.

This principle aligns with Go's composition-oriented design philosophy. Instead of inheritance hierarchies, Go encourages small, focused interfaces that can be easily implemented and combined.

=== What is the potential impact?

Using concrete types in function parameters can lead to:

* **Reduced testability**: Difficult to create mock objects for unit testing
* **Tight coupling**: Functions become dependent on specific implementations
* **Limited extensibility**: Adding new implementations requires changing function signatures
* **Maintenance burden**: Code becomes harder to refactor and evolve
* **Reduced reusability**: Functions cannot work with alternative implementations

== How to fix it

Define an interface that captures the required behavior and use it as the parameter type instead of the concrete type. This allows any type implementing the interface to be passed to the function.

=== Code examples

==== Noncompliant code example

[source,go,diff-id=1,diff-type=noncompliant]
----
func sendResponse(sending *sync.Mutex, req *Request,
    reply interface{}, enc *gob.Encoder, errmsg string) { // Noncompliant
    // Function is tightly coupled to gob.Encoder
    enc.Encode(reply)
}
----

==== Compliant solution

[source,go,diff-id=1,diff-type=compliant]
----
type ServerCodec interface {
    ReadRequestHeader(*Request) error
    ReadRequestBody(interface{}) error
    WriteResponse(*Response, interface{}) error
    Close() error
}

func sendResponse(sending *sync.Mutex, req *Request,
    reply interface{}, enc ServerCodec, errmsg string) {
    // Function can work with any ServerCodec implementation
    enc.WriteResponse(response, reply)
}
----

== Resources

=== Documentation

 * Effective Go - Interfaces - https://go.dev/doc/effective_go#interfaces_and_types[Official Go documentation on interfaces and their effective use]

 * JSON-RPC: a tale of interfaces - https://go.dev/blog/json-rpc-tale-of-interfaces[Go blog post demonstrating interface refactoring in the RPC package]

 * Go Interfaces - https://go.dev/tour/methods/9[Go Tour section on interfaces and their implementation]

=== Standards

 * SOLID Principles - Dependency Inversion Principle - https://en.wikipedia.org/wiki/Dependency_inversion_principle[High-level modules should not depend on low-level modules; both should depend on abstractions]

 * SOLID Principles - Interface Segregation Principle - https://en.wikipedia.org/wiki/Interface_segregation_principle[Clients should not be forced to depend upon interfaces they do not use]
