This rule raises an issue when a method's main logic is wrapped inside conditional blocks (`if`, `unless`) that could be replaced with guard clauses (early returns).

== Why is this an issue?

Guard clauses are a coding pattern that handles preconditions and edge cases at the beginning of a method using early returns. This approach offers several advantages over nested conditional blocks.

When the main logic of a method is wrapped in conditional statements, it creates unnecessary nesting. This nesting makes code harder to read and understand, especially as conditions become more complex or multiple validations are needed.

Guard clauses flip this pattern by checking for invalid conditions first and returning early when they're met. This leaves the main logic at the top level of the method, making it more prominent and easier to follow.

The benefits include:

* *Reduced cognitive load*: Readers can quickly identify and dismiss edge cases, then focus on the main functionality
* *Flatter code structure*: Less indentation makes code easier to scan and understand
* *Clearer intent*: Guard clauses explicitly show what conditions must be met for the method to proceed
* *Easier maintenance*: Adding new preconditions doesn't increase nesting levels

=== What is the potential impact?

While this issue doesn't affect functionality, it impacts code maintainability and readability. Deeply nested conditional blocks increase cognitive complexity, making code harder to understand, debug, and modify. This can slow down development and increase the likelihood of introducing bugs during maintenance.

== How to fix it

Replace the conditional block with a guard clause that returns early when the condition is not met. Move the main logic to the top level of the method.

=== Code examples

==== Noncompliant code example

[source,ruby,diff-id=1,diff-type=noncompliant]
----
def authenticate_user
  # Main logic wrapped in conditional
  if @user&.authenticate(password)
    create_session
    render_success
  else
    render_error('Invalid username or password')
  end
end
----

==== Compliant solution

[source,ruby,diff-id=1,diff-type=compliant]
----
def authenticate_user
  # Guard clause - early return for invalid conditions
  return render_error('Invalid username or password') unless @user&.authenticate(password)
  
  # Main logic at top level
  create_session
  render_success
end
----

== Resources

=== Documentation

 * Ruby Style Guide - Guard Clauses - https://rubystyle.guide/#no-nested-conditionals[Official Ruby style guide recommendation for avoiding nested conditionals]

 * Refactoring Guru - Replace Nested Conditional with Guard Clauses - https://refactoring.guru/replace-nested-conditional-with-guard-clauses[Detailed explanation of the guard clause refactoring pattern]
