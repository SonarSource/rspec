<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This rule raises an issue when a goroutine is started with an infinite loop or channel range operation without a clear termination mechanism like a done channel or context cancellation.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Goroutines are lightweight threads in Go that allow concurrent execution. However, when goroutines run indefinitely without a way to stop them, they become goroutine leaks.</p>
</div>
<div class="paragraph">
<p>A goroutine leak occurs when a goroutine continues to run even after it&#8217;s no longer needed. This happens commonly with patterns like:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Infinite <code>for</code> loops with channel operations</p>
</li>
<li>
<p><code>for range</code> loops over channels like ticker channels</p>
</li>
<li>
<p>Long-running background tasks without termination signals</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These leaked goroutines consume memory and system resources. In applications that frequently create such goroutines, the accumulated leaks can lead to memory exhaustion and degraded performance.</p>
</div>
<div class="paragraph">
<p>The problem is particularly common with tickers, timers, and other periodic operations where developers focus on the main functionality but forget to implement a clean shutdown mechanism.</p>
</div>
<div class="paragraph">
<p>Proper goroutine management requires implementing termination signals, typically through:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A dedicated <code>done</code> channel that can be closed to signal termination</p>
</li>
<li>
<p>Context cancellation using <code>context.Context</code></p>
</li>
<li>
<p>Other synchronization mechanisms that allow graceful shutdown</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_what_is_the_potential_impact">What is the potential impact?</h3>
<div class="paragraph">
<p>Goroutine leaks can cause serious resource exhaustion issues:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Memory leaks</strong>: Each leaked goroutine consumes memory for its stack and any referenced variables</p>
</li>
<li>
<p><strong>Performance degradation</strong>: Too many goroutines can overwhelm the Go scheduler</p>
</li>
<li>
<p><strong>Resource exhaustion</strong>: In long-running applications, accumulated leaks can cause the application to run out of memory</p>
</li>
<li>
<p><strong>Difficult debugging</strong>: Goroutine leaks are often hard to detect until they cause visible problems</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_fix_it">How to fix it</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Add a done channel to signal goroutine termination. Use a select statement to listen for both the main operation and the termination signal.</p>
</div>
<div class="sect2">
<h3 id="_code_examples">Code examples</h3>
<div class="sect3">
<h4 id="_noncompliant_code_example">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-go" data-lang="go">type RateLimiter struct {
    tokens chan struct{}
    ticker *time.Ticker
}

func (rl *RateLimiter) Start() {
    go func() {
        for range rl.ticker.C { // Noncompliant
            select {
            case rl.tokens &lt;- struct{}{}:
            default:
            }
        }
    }()
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-go" data-lang="go">type RateLimiter struct {
    tokens chan struct{}
    ticker *time.Ticker
    done   chan struct{}
}

func (rl *RateLimiter) Start() {
    go func() {
        for {
            select {
            case &lt;-rl.ticker.C:
                select {
                case rl.tokens &lt;- struct{}{}:
                default:
                }
            case &lt;-rl.done:
                return
            }
        }
    }()
}

func (rl *RateLimiter) Stop() {
    close(rl.done)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_documentation">Documentation</h3>
<div class="ulist">
<ul>
<li>
<p>Go Concurrency Patterns - <a href="https://go.dev/blog/pipelines">Official Go blog post about concurrency patterns and proper goroutine management</a></p>
</li>
<li>
<p>Effective Go - Goroutines - <a href="https://go.dev/doc/effective_go#goroutines">Official documentation on goroutines and concurrent programming in Go</a></p>
</li>
<li>
<p>Context Package - <a href="https://pkg.go.dev/context">Documentation for the context package, which provides cancellation and timeout functionality</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_standards">Standards</h3>
<div class="ulist">
<ul>
<li>
<p>CWE-401: Missing Release of Memory after Effective Lifetime - <a href="https://cwe.mitre.org/data/definitions/401.html">Covers memory leaks including those caused by unreleased resources like goroutines</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>