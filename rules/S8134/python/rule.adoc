This rule reports when there is an Architecture Directive to remove a specific usage of a file or folder from a given location.

== Why is this an issue?

This issue is being raised because there is a dependency in the code, and an Architecture Directive has been created to remove it.

Architecture Directives are defined in the “Architecture” section of the project by an authorized user.

=== What is the potential impact?

Flaws in the architecture constitute unnecessary complexity which affects developer productivity. Removing this flaw makes future development easier by favoring local changes in the code.

== How to fix it

Remove or refactor the problematic dependency. This may involve replacing the dependency with an allowed one, moving code to appropriate files or folders, or introducing new abstractions. The exact solution depends on your project’s specific situation.

=== Code examples

==== Noncompliant code example

This example shows a circular dependency between modules `order.py` and `customer.py`:

[source,python,diff-id=1,diff-type=noncompliant]
----
# order.py
from customer import Customer # Noncompliant
class Order:
    def __init__(self, customer: Customer):
        self.customer = customer

# customer.py
from order import Order # Noncompliant
class Customer:
    def __init__(self, order: Order):
        self.order = order
----

==== Compliant solution

The issue can be resolved by refactoring the code structure.
Instead of `Customer` and `Order` referencing each other, customers by order and orders by customer can be aggregated using an addition class `CustomerOrder`.

[source,python,diff-id=1,diff-type=compliant]
----
# order.py
class Order:
    def __init__(self):
        ...

# customer.py
class Customer:
    def __init__(self):
        ...

# customer_order.py
from customer import Customer
from order import Order
class CustomerOrder:
    def __init__(self, customer: Customer, order: Order):
        self.customer = customer
        self.order = order
----
