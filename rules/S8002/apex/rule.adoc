This rule raises an issue when Apex classes or methods lack explicit access modifiers (`private`, `public`, or `global`).

== Why is this an issue?

In Apex, classes and methods without explicit access modifiers default to package-private visibility. This implicit behavior can lead to several problems:

**Security concerns**: Without explicit modifiers, you might unintentionally expose sensitive functionality or data to other classes in the same package. This creates potential security vulnerabilities where unauthorized code could access methods that should be private.

**Unclear intent**: When access modifiers are missing, it's unclear whether the developer intended the default visibility or simply forgot to specify it. This ambiguity makes code harder to understand and maintain.

**Maintenance difficulties**: As your codebase grows, implicit access levels make it harder to understand the intended API boundaries. This can lead to tight coupling between classes and make refactoring more difficult.

**Code review challenges**: Without explicit modifiers, reviewers cannot easily verify that the access level matches the intended design, potentially allowing inappropriate access patterns to slip through.

Explicit access modifiers serve as documentation of your design intent and help enforce proper encapsulation principles.

=== What is the potential impact?

Missing access modifiers can lead to unintended exposure of sensitive methods or data, creating security vulnerabilities. It also reduces code maintainability and makes it harder for teams to understand and modify the codebase safely.

== How to fix it

Add explicit access modifiers to classes and methods based on their intended usage. Use `private` for internal implementation details, `public` for methods that should be accessible within the same package, and `global` only when cross-namespace access is required.

=== Code examples

==== Noncompliant code example

[source,apex,diff-id=1,diff-type=noncompliant]
----
class AccountHelper {
    void updateAccountStatus(Id accountId) { // Noncompliant
        Account acc = [SELECT Id, Status__c FROM Account WHERE Id = :accountId];
        acc.Status__c = 'Active';
        update acc;
    }
    
    String formatAccountName(String name) { // Noncompliant
        return name.toUpperCase();
    }
}
----

==== Compliant solution

[source,apex,diff-id=1,diff-type=compliant]
----
public class AccountHelper {
    public static void updateAccountStatus(Id accountId) {
        Account acc = [SELECT Id, Status__c FROM Account WHERE Id = :accountId];
        acc.Status__c = 'Active';
        update acc;
    }
    
    private static String formatAccountName(String name) {
        return name.toUpperCase();
    }
}
----

== Resources

=== Documentation

 * Apex Access Modifiers - https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/apex_classes_access_modifiers.htm[Official Salesforce documentation on Apex access modifiers and their usage]

=== Standards

 * CWE-668: Exposure of Resource to Wrong Sphere - https://cwe.mitre.org/data/definitions/668.html[Weakness related to exposing resources to unintended spheres of access]

=== Related rules

 * S1784
