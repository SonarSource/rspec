<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A base class and its derived class often differ in size.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Accessing an array of a derived class through a pointer to the base class leads to wrong pointer arithmetic and can then corrupt memory.</pre>
</div>
</div>
<div class="sect2">
<h3 id="_noncompliant_code_example">Noncompliant code example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">struct Base { /*...*/};
struct Derived : public Base { /*...*/};
void f(Base const &amp;b);

int main() {
  const size_t size = 4;
  Derived derivedArray[size];
  Base* basePointer = derivedArray; // Noncompliant
  f(basePointer[2]); // The arithmetic will use the size of Base, not the size of Derived, and point to a random byte in the array
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you need to do a cast from derived to base in an array, do it element by element.</p>
</div>
</div>
<div class="sect2">
<h3 id="_compliant_solution">Compliant solution</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#include&lt;iostream&gt;

using namespace std;

struct Base {
  int iBase = 0;
};

struct Derived : public Base {
  int iDerived = 0;
};

int main() {
  const size_t size = 4;
  Derived derivedArray[size];
  for(int i=0; i&lt;size; ++i) {
    derivedArray[i].iBase = i;                                           // store : 0 1 2 3
    derivedArray[i].iDerived = i*1000;
  }
  for(int i=0; i&lt;size; ++i) {
    cout&lt;&lt;"derivedArray["&lt;&lt;i&lt;&lt;"].iBase="&lt;&lt;derivedArray[i].iBase&lt;&lt;endl;   // display : 0 1 2 3
    cout&lt;&lt;"base of derivedArray["&lt;&lt;i&lt;&lt;"].iBase="&lt;&lt;static_cast&lt;Base*&gt;(derivedArray+i)-&gt;iBase&lt;&lt;endl;     // display : 0 1 2 3
  }
  return 0;
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>C++ Core Guidelines - <a href="https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c152-never-assign-a-pointer-to-an-array-of-derived-class-objects-to-a-pointer-to-its-base">C.152: Never assign a pointer to an array of derived class objects to a pointer to its base</a></p>
</li>
</ul>
</div>
<hr>
</div>
</div>
<div class="sect1">
<h2 id="_comments_and_links">Comments And Links</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_relates_to_s5410">relates to: <a data-rspec-id="S5410" class="rspec-auto-link">S5410</a></h3>

</div>
<div class="sect2">
<h3 id="_on_25_oct_2019_162729_geoffray_adde_wrote">on 25 Oct 2019, 16:27:29 Geoffray Adde wrote:</h3>
<div class="paragraph">
<p>First, we try a much stronger, constraining and simpler version of the rule: no array (C-style, std::array and std::vector) of publicly derived class.</p>
</div>
</div>
<div class="sect2">
<h3 id="_on_18_dec_2019_175505_loïc_joly_wrote">on 18 Dec 2019, 17:55:05 Loïc Joly wrote:</h3>
<div class="paragraph">
<p>If you want to try the stronger version, why not directly document it? I think it might have value on its own, as a code smell&#8230;&#8203; And I would also prevent arrays of base classes.</p>
</div>
</div>
</div>
</div>