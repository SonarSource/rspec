The type system in Kotlin is designed to eliminate the risk of null pointer references by distinguishing between references that can be null and references that cannot be null. 

== Why is this an issue?

Using the non-null assertion operator in Kotlin, denoted by the exclamation mark (!) can lead to unexpected runtime errors if the value turns out to be null. It's easy to misuse the operator, and it's not always clear whether a variable is guaranteed to be non-null or not. If a null value is passed to a function that expects a non-null value, it can lead to a crash or unexpected behavior.

=== What is the potential impact?

== How to fix it

Avoid using the non-null assertion operator.

=== Code examples

==== Noncompliant code example

This example will cause an error because the variable is actually nullable. 

[source,kotlin]
----
val l = mapOf(1 to "one", 2 to "two", 3 to "five")
l.get(123)!! // Noncompliant
l[123]!! // Noncompliant
----

==== Compliant solution

By removing the non-null assertion operator the compiler is able to return nullable when necessary.

[source,kotlin]
----
val l = mapOf(1 to "one", 2 to "two", 3 to "five")
l.get(123) // Compliant, returns nullable
l[123] // Compliant, returns nullable
l.getValue(123) // Compliant, throws NoSuchElemnException
l.getOrElse(123 ) { "empty" } // Compliant, has default
l.getOrDefault(123, "empty") // Compliant, has default
l[123] ?: "empty" // Compliant, has default
----

== Resources

=== Documentation

* https://kotlinlang.org/docs/null-safety.html[Null safety]
* https://kotlinlang.org/docs/map-operations.html[Map-specific operations]

=== Articles & blog posts

* https://medium.com/@igorwojda/kotlin-combating-non-null-assertions-5282d7b97205[Kotlin â€” combating non-null assertions (!!)]
