The type system in Kotlin is designed to eliminate the risk of null pointer references by distinguishing between references that can be null and references that cannot be null. 

== Why is this an issue?

It's not always clear whether a variable is guaranteed to be non-null or not so it's easy to misuse this operator. If a null value is passed to a function that expects a non-null value, it can lead to a crash or unexpected behavior.

== How to fix it

Avoid using the non-null assertion operator.

=== Code examples

==== Noncompliant code example

This example will cause an error because the variable is actually nullable. 

[source,kotlin]
----
val l = mapOf(1 to "one", 2 to "two", 3 to "five")
l.get(123)!! // Noncompliant
l[123]!! // Noncompliant
----

==== Compliant solution

By removing the non-null assertion operator the compiler is able to return nullable when necessary.

[source,kotlin]
----
val l = mapOf(1 to "one", 2 to "two", 3 to "five")
l.get(123) // Compliant, returns nullable
l[123] // Compliant, returns nullable
l.getValue(123) // Compliant, throws NoSuchElementException
l.getOrElse(123 ) { "empty" } // Compliant, has default
l.getOrDefault(123, "empty") // Compliant, has default
l[123] ?: "empty" // Compliant, has default
----

== Resources

=== Documentation

* https://kotlinlang.org/docs/null-safety.html[Null safety]
* https://kotlinlang.org/docs/map-operations.html[Map-specific operations]

=== Articles & blog posts

* https://medium.com/@igorwojda/kotlin-combating-non-null-assertions-5282d7b97205[Kotlin â€” combating non-null assertions (!!)]
