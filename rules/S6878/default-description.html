<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Java 21 enhances Pattern Matching, introduced in Java 16, with a <em>record pattern</em> that decomposes records into local variables.
This form should be used when all fields of a record are accessed within a block for improved readability.
Nested record patterns are also allowed and should be used when a record field is another record, and all its fields are accessed.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_exceptions">Exceptions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This rule does not apply when not all record fields are accessed.
This prevents the creation of unused local variables in the decomposed record structure.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_fix_it">How to fix it</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Replace the instance check or simple pattern matching with a record pattern.</p>
</div>
<div class="sect2">
<h3 id="_code_examples">Code examples</h3>
<div class="sect3">
<h4 id="_noncompliant_code_example">Noncompliant code example</h4>
<div class="paragraph">
<p>This example uses pattern matching but not a record pattern, even though all fields of the record are accessed in the block.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">record Point(Float x, Float y, Float z) {}

void print(Object obj) {
    if (obj instanceof Point p) { // Noncompliant, because all three fields x, y, z are accessed
        Float x = p.x;
        Float y = p.y();
        System.out.println(x + y + p.z);
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution">Compliant solution</h4>
<div class="paragraph">
<p>The compliant example uses a record pattern to decompose the record structure.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">record Point(Float x, Float y, Float z) {}

void print(Object obj) {
    if (obj instanceof Point(Float x, Float y, Float z)) { // Compliant
        System.out.println(x + y + z);
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_noncompliant_code_example_2">Noncompliant code example</h4>
<div class="paragraph">
<p>This example does not use pattern matching or a record pattern.
Rule <em><a href="https://sonarsource.github.io/rspec/#/rspec/S6201">S6201 - Pattern matching or "instanceOf" operator should be used</a></em> would report first.
When fixed using simple pattern matching instead of a record pattern, this rule (<a data-rspec-id="S6878" class="rspec-auto-link">S6878</a>) will report.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">void print(Object obj) {
    if (obj instanceof Point) { // Noncompliant
        Point p = (Point) obj;
        Float x = p.x;
        Float y = p.y();
        System.out.println(x + y + p.z);
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution_2">Compliant solution</h4>
<div class="paragraph">
<p>The solution compliant with both rules, <a data-rspec-id="S6201" class="rspec-auto-link">S6201</a> and <a data-rspec-id="S6878" class="rspec-auto-link">S6878</a>, uses pattern matching and decomposes the record structure using a record pattern.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">void print(Object obj) {
    if (obj instanceof Point(Float x, Float y, Float z)) { // Compliant
        System.out.println(x + y + z);
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_noncompliant_code_example_3">Noncompliant code example</h4>
<div class="paragraph">
<p>This example is noncompliant because a nested record pattern could have been used.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">record Plane(Point normal, Float d) {}

void print(Object obj) {
    // Noncompliant, because all field of "normal" are accessed
    if (obj instanceof Plane(Point normal, Float d)) {
        System.out.println(normal.x + normal.y + normal.z);
        System.out.println(d);
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution_3">Compliant solution</h4>
<div class="paragraph">
<p>This is the same example using a nested record pattern.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">void print(Object obj) {
    if (obj instanceof Plane(Point(Float x, Float y, Float z), Float d)) { // Compliant
        System.out.println(x + y + z);
        System.out.println(d);
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution_4">Compliant solution</h4>
<div class="paragraph">
<p>This example uses <code>var</code> instead of replicating the field types in the record pattern, which is less verbose and keeps the code more readable, especially in the case of longer type names.
Also, it uses variable names that do not match the original field names.
The reason for this can be to avoid name collisions with fields or other local variables.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">void print(Object obj) {
    if (obj instanceof Point(var px, var py, var pz)) { // Compliant
        System.out.println(px + py + pz);
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution_5">Compliant solution</h4>
<div class="paragraph">
<p>This example is compliant without using a record pattern, as it does not access all fields.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">void print(Object obj) {
    if (obj instanceof Point p) { // Compliant, because z is never accessed
        Float x = p.x;
        Float y = p.y();
        System.out.println(x + y);
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a href="https://openjdk.org/jeps/440">JEP 440: Record Patterns</a></p>
</li>
</ul>
</div>
</div>
</div>