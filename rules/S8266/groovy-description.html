<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This rule raises an issue when boolean variables are used for check-and-set operations in code that may run concurrently, creating potential race conditions.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In multi-threaded applications, using regular boolean variables for check-and-set patterns creates race conditions. When one thread checks a boolean value and then sets it based on that check, another thread might perform the same operations simultaneously.</p>
</div>
<div class="paragraph">
<p>For example, consider an initialization flag. Thread A checks <code>if (!initialized)</code> and finds it false. Before Thread A can set <code>initialized = true</code>, Thread B also checks the flag and also finds it false. Now both threads think they need to perform initialization, leading to duplicate work or corrupted state.</p>
</div>
<div class="paragraph">
<p>This happens because the check and set operations are separate, non-atomic operations. Between these two operations, other threads can interfere and see inconsistent state.</p>
</div>
<div class="paragraph">
<p>The <code>AtomicBoolean</code> class provides atomic operations like <code>compareAndSet(expectedValue, newValue)</code> and <code>getAndSet(newValue)</code> that perform check-and-set operations atomically. This eliminates the race condition window entirely, ensuring that only one thread can successfully perform the state transition.</p>
</div>
<div class="sect2">
<h3 id="_what_is_the_potential_impact">What is the potential impact?</h3>
<div class="paragraph">
<p>Race conditions from non-atomic check-and-set operations can lead to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Duplicate initialization</strong>: Multiple threads may initialize the same resource, wasting CPU and memory</p>
</li>
<li>
<p><strong>Inconsistent application state</strong>: Operations that should run only once may execute multiple times</p>
</li>
<li>
<p><strong>Data corruption</strong>: Concurrent modifications without proper synchronization can corrupt shared data</p>
</li>
<li>
<p><strong>Resource leaks</strong>: Duplicate resource allocation without proper cleanup</p>
</li>
<li>
<p><strong>Unpredictable behavior</strong>: The application may work correctly in testing but fail intermittently in production under load</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_fix_it">How to fix it</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Replace the boolean variable with AtomicBoolean and use compareAndSet() for atomic check-and-set operations. This ensures that only one thread can successfully transition from false to true.</p>
</div>
<div class="sect2">
<h3 id="_code_examples">Code examples</h3>
<div class="sect3">
<h4 id="_noncompliant_code_example">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">class StateManager {
    private boolean initialized = false

    void initialize() {
        if (!initialized) { // Noncompliant
            initialized = true
            doInitialization()
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">import java.util.concurrent.atomic.AtomicBoolean

class StateManager {
    private AtomicBoolean initialized = new AtomicBoolean(false)

    void initialize() {
        if (initialized.compareAndSet(false, true)) {
            doInitialization()
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_documentation">Documentation</h3>
<div class="ulist">
<ul>
<li>
<p>AtomicBoolean (Java Platform SE 8) - <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicBoolean.html">Official Java documentation for AtomicBoolean class and its atomic operations</a></p>
</li>
<li>
<p>Java Concurrency in Practice - Atomic Variables - <a href="https://jcip.net/">Comprehensive guide to Java concurrency patterns and atomic operations</a></p>
</li>
<li>
<p>Groovy Documentation - Working with Collections - <a href="https://groovy-lang.org/working-with-collections.html">Groovy documentation covering concurrent programming patterns</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_standards">Standards</h3>
<div class="ulist">
<ul>
<li>
<p>CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization - <a href="https://cwe.mitre.org/data/definitions/362.html">Race conditions that occur when multiple threads access shared resources without proper synchronization</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_related_rules">Related rules</h3>
<div class="ulist">
<ul>
<li>
<p><a data-rspec-id="S2204" class="rspec-auto-link">RSPEC-2204</a> - <a href="https://rules.sonarsource.com/java/RSPEC-2204/">Java rule for using AtomicBoolean instead of synchronized blocks for simple boolean operations</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>