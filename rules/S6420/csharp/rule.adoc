To avoid holding more connections than necessary when using `HttpClient`, `DocumentClient` or Azure Storage clients, consider:

* Creating a single, static client that every Azure Function invocation can use. Provide it in a shared class when different Azure Functions need it.
* Use the client with dependency injection as a Singleton.

// If you want to factorize the description uncomment the following line and create the file.
//include::../description.adoc[]

== Noncompliant Code Example

[source,csharp]
----
    public class HttpExample
    {

        [FunctionName("HttpExample")]
        public async Task<IActionResult> Run([HttpTrigger(AuthorizationLevel.Anonymous, "get", Route = null)] HttpRequest request)
        {
            HttpClient httpClient = new HttpClient(); // Noncompliant

            var response = await httpClient.GetAsync("https://example.com");
            // rest of the function
        }
    }
----

== Compliant Solution

[source,csharp]
----
    public class HttpExample
    {
        // Create a single, static HttpClient
        private static HttpClient httpClient = new HttpClient();

        [FunctionName("HttpExample")]
        public async Task<IActionResult> Run([HttpTrigger(AuthorizationLevel.Anonymous, "get", Route = null)] HttpRequest request)
        {
            var response = await httpClient.GetAsync("https://example.com");
            // rest of the function
        }
    }
----

== See

* https://docs.microsoft.com/en-us/azure/azure-functions/manage-connections?tabs=csharp#static-clients[Manage connections in Azure Functions: Static Clients]
* https://docs.microsoft.com/en-us/azure/azure-functions/functions-dotnet-dependency-injection#service-lifetimes[Azure Functions - Dependency Injection: Service Lifetimes]