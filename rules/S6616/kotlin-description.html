<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In Kotlin, lambdas with a single parameter have an implicit parameter name <code>it</code>. Thatâ€™s why using <code>it</code> as a parameter name in lambdas is actually duplicating the compiler work and thus is a code smell.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_fix_it">How to fix it</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The simplest solution will be to just remove the parameter declaration and the arrow. This way, you can still refer to the parameter with <code>it</code>.
Another possible solution could be to give your lambda parameter another meaningful name. This will also increase the readability.</p>
</div>
<div class="sect2">
<h3 id="_code_examples">Code examples</h3>
<div class="sect3">
<h4 id="_noncompliant_code_example">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">listOf(1, 2, 3).forEach { it -&gt; it.and(6) } // Noncompliant
listOf(1, 2, 3).forEach { it: Int -&gt; it.and(6) } // Noncompliant</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">listOf(1, 2, 3).forEach { it.and(6) }
listOf(1, 2, 3).forEach { item -&gt; item.and(6) }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The only exception to this rule is the situation when the compiler is not able to dermine the type of the lambda parameter, so you have to specify it explicitly like here <code>val lambda = { it: Int &#8594; it + 5 }</code>.</p>
</div>
</div>
</div>
</div>
</div>