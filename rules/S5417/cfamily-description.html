<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>std::forward</code> and <code>std::move</code> have different purposes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>std::move</code> takes an object and casts it as an <code>rvalue</code> reference, which indicates that resources can be "stolen" from this object.</p>
</li>
<li>
<p><code>std::forward</code> has a single use-case: to cast a templated function parameter of type <em>forwarding reference</em> (<code>T&amp;&amp;</code>) to the value category (<code>lvalue</code> or <code>rvalue</code>) the caller used to pass it. This allows <code>rvalue</code> arguments to be passed on as <code>rvalues</code>, and <code>lvalues</code> to be passed on as <code>lvalues</code>. This scheme is known as <em>perfect forwarding</em>. Note that the standard states that <em>"a forwarding reference is an rvalue reference to a cv-unqualified template parameter that does NOT represent a template parameter of a class template"</em>. Refer to the last noncompliant code example.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Since both rvalue references and forwarding references use the same notation (<code>&amp;&amp;</code>), an unwary developer might confuse them. If that happens, and a parameter is moved instead of forwarded, the original object can be emptied, probably crashing the software if the user tries to use the original object normally after the function call. An error in the other direction has less dire consequences and might even work as intended if the right template argument is used, but the code would be clumsy and not clearly express the intent.</p>
</div>
<div class="paragraph">
<p>This rule raises an issue when <code>std::forward</code> is used with a parameter not passed as a forwarding reference or when <code>std::move</code> is used on a parameter passed as a forwarding reference.</p>
</div>
<div class="sect2">
<h3 id="_noncompliant_code_example">Noncompliant code example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#include &lt;utility&gt;

class S {};

template&lt;typename T&gt; void g(const T&amp; t);
template&lt;typename T&gt; void g(T&amp;&amp; t);

template&lt;typename T&gt; void gt(T&amp;&amp; t) {
  g(std::move(t)); // Noncompliant : std::move applied to a forwarding reference
}

void use_g() {
  S s;
  g(s);
  g(std::forward&lt;S&gt;(s)); // Noncompliant : S isn't a forwarding reference.
}

template &lt;typename T&gt;
void foo(std::vector&lt;T&gt;&amp;&amp; t) {
  std::forward&lt;T&gt;(t); // Noncompliant : std::vector&lt;T&gt;&amp;&amp; isn't a forwarding reference.
}

template&lt;typename T&gt;
struct C {
  // In class template argument deduction, template parameter of a class template is never a forwarding reference.
  C(T&amp;&amp; t) {
    g(std::forward&lt;T&gt;(t)); // Noncompliant : T&amp;&amp; isn't a forwarding reference. It is an r-value reference.
  }
};</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_compliant_solution">Compliant solution</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#include &lt;utility&gt;

class S {};

template&lt;typename T&gt; void g(const T&amp; t);
template&lt;typename T&gt; void g(T&amp;&amp; t);

template&lt;typename T&gt; void gt(T&amp;&amp; t) {
  g(std::forward(t));
}

void use_g() {
  S s;
  g(s);
  g(std::move(s));
}

template &lt;typename T&gt;
void (std::vector&lt;T&gt;&amp;&amp; t){
  std::move(t);
}

template&lt;typename T&gt;
struct C {
  C(T&amp;&amp; t) {
    g(std::move(t));
  }
};</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>C&#43;&#43; reference - <a href="https://en.cppreference.com/w/cpp/utility/move">std::move</a></p>
</li>
<li>
<p>C&#43;&#43; reference - <a href="https://en.cppreference.com/w/cpp/utility/forward">std::forward</a></p>
</li>
<li>
<p>C&#43;&#43; reference - <a href="https://en.cppreference.com/w/cpp/language/reference#Forwarding_references">Forwarding references</a></p>
</li>
<li>
<p>C&#43;&#43; Core Guidelines - <a href="https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f18-for-will-move-from-parameters-pass-by-x-and-stdmove-the-parameter">F.18: For "will-move-from" parameters, pass by <code>X&amp;&amp;</code> and <code>std::move</code> the parameter</a></p>
</li>
<li>
<p>C&#43;&#43; Core Guidelines - <a href="https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f19-for-forward-parameters-pass-by-tp-and-only-stdforward-the-parameter">F.19: For "forward" parameters, pass by <code>TP&amp;&amp;</code> and only <code>std::forward</code> the parameter</a></p>
</li>
</ul>
</div>
<hr>
</div>
</div>
<div class="sect1">
<h2 id="_comments_and_links">Comments And Links</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_on_4_jul_2019_105535_geoffray_adde_wrote">on 4 Jul 2019, 10:55:35 Geoffray Adde wrote:</h3>
<div class="paragraph">
<p><code>Lambda functions</code> with <code>auto</code> parameters are also template in disguise. <code>auto&amp;&amp;</code> arguments should be treated as forwarding references.</p>
</div>
</div>
<div class="sect2">
<h3 id="_on_26_aug_2019_220813_lo誰c_joly_wrote">on 26 Aug 2019, 22:08:13 Lo誰c Joly wrote:</h3>
<div class="paragraph">
<p>Can you please review my changes?</p>
</div>
</div>
<div class="sect2">
<h3 id="_on_9_sep_2019_173547_ann_campbell_wrote">on 9 Sep 2019, 17:35:47 Ann Campbell wrote:</h3>
<div class="paragraph">
<p>\[~geoffray.adde] in SonarSource we&#8217;ve standardized on a (non-standard) spelling: Noncompliant. And in the compliant solution there&#8217;s no need to explicitly mark anything compliant because by its nature everything in it is. I&#8217;ve corrected those things in this RSPEC, but for future reference&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>Also, Geoffray and [~loic.joly], this RSPEC has no message.</p>
</div>
<div class="paragraph">
<p>For the references gentlemen, are you confident that these pages on en.cppreference.com will still be around 5 years from now?</p>
</div>
<div class="paragraph">
<p>And finally, it&#8217;s not clear to me what Bad Thing will happen if you break this rule. Maybe that&#8217;s because I&#8217;m not conversant in C&#43;&#43;. Maybe it&#8217;s in there implicitly. But remember that we write rule descriptions not for language wizards but for the ones who still have something (a lot?) to learn. :-)</p>
</div>
</div>
<div class="sect2">
<h3 id="_on_9_sep_2019_193228_lo誰c_joly_wrote">on 9 Sep 2019, 19:32:28 Lo誰c Joly wrote:</h3>
<div class="paragraph">
<p>This website is already several years old, is well maintained and updated regularly. Is as become a de facto standard for C&#43;&#43;, so even is predictions are hard to make, especially the ones about the future :), we are as confident as can be&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>For the message part, I don&#8217;t think it is displayed anywhere in the rule description, and as such, is can only be used to communicated between the RSPECator and the guy who implements the rule, and is not necessary if they work closely together. Please correct me if I&#8217;m wrong. I&#8217;m reluctant to write the message, because quite often, when implementing the rule we discover special cases that require a message change.</p>
</div>
<div class="paragraph">
<p>Thank you for the bad things that can happen, I&#8217;ll update the rspec.</p>
</div>
</div>
<div class="sect2">
<h3 id="_on_3_oct_2019_234148_abbas_sabra_wrote">on 3 Oct 2019, 23:41:48 Abbas Sabra wrote:</h3>
<div class="paragraph">
<p>According to the C&#43;&#43;17 standard, there is a way to define class type deduction guide to make the constructor argument a forwarding reference. We should keep an eye on such example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>template &lt;typename T&gt;
struct A {
A(T&amp;&amp;); // Here T&amp;&amp; is forwarding reference because of the deduction guide defined belowe
};
template &lt;typename T&gt; A(T&amp;&amp;) -&gt; A;</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_on_10_oct_2019_160056_geoffray_adde_wrote">on 10 Oct 2019, 16:00:56 Geoffray Adde wrote:</h3>
<div class="paragraph">
<p>\[~loic.joly], all changes are fine by me.</p>
</div>
</div>
</div>
</div>