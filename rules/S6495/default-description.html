<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>C&#43;&#43;20 introduces a new text formatting API with the <code>&lt;format&gt;</code> header, in addition to the <code>printf</code> function family&#8201;&#8212;&#8201;inherited from C&#8201;&#8212;&#8201;and <code>iostreams</code>.
<code>std::format</code> combines the convenience of <code>printf</code>, separating formatting and arguments, with the type-safety of <code>iostreams</code>.
C&#43;&#43;23 adds the <code>&lt;print&gt;</code> header, which provides similar features that output to a stream instead of generating a string.</p>
</div>
<div class="paragraph">
<p>Before C&#43;&#43;20, if you wanted to format an output stream, you had to use standard manipulators that control the output streams.
This approach is very verbose, is often stateful, and is not thread-safe. That is why we recommend replacing them with <code>std::print</code> or <code>std::format</code> when possible.</p>
</div>
<div class="paragraph">
<p>Some manipulators will have a temporary effect on the output. For example, <code>std::setw</code>. This is due to the resetting of the width property of the stream when most of the <code>operator&lt;&lt;</code> is called.
Other manipulators will have a lasting effect on the output. For example, <code>std::boolalpha</code>. It will set the <code>boolalpha</code> flag of the output stream without resetting it.</p>
</div>
<div class="paragraph">
<p>This rule raises an issue when an output stream is used with standard manipulators to output a formattable type in a way that can be replaced by <code>std::print</code> or <code>std::format</code>.
You should be careful to avoid undesirable side effects when replacing a manipulator with lasting effects.</p>
</div>
<div class="sect2">
<h3 id="_noncompliant_code_example">Noncompliant code example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">void printBool(bool b) {
  std::cout &lt;&lt; std::boolalpha &lt;&lt; b; // Noncompliant
}

void printInt(int b) {
  std::cout &lt;&lt; std::setfill('*') &lt;&lt; std::setw(5) &lt;&lt; b; // Noncompliant
}

int main() {
  printInt(10);
  printBool(true);
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_compliant_solution">Compliant solution</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">void printBool(bool b) {
  // Compliant, be aware of the side effect of not setting the boolalpha flag
  std::print("{}", b);
  // Or, in C++20
  std::cout &lt;&lt; std::format("{}", b);
}

void printInt(int b) {
  // Compliant, no side effect because setw has a temporary effect
  std::print("{:*&gt;5}", b);
}

void setFlags() {
  // Compliant, the intention is to set the flags and not to output
  std::cout &lt;&lt; std::boolalpha &lt;&lt; std::showbase;
}

int main() {
  printInt(10);
  printBool(true);
  setFlags();
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_exceptions">Exceptions</h3>
<div class="paragraph">
<p>Manipulators that don&#8217;t have a direct equivalent in the format library like <code>std::quoted</code>, <code>std::put_money</code>, etc.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">void printQuoted(std::string_view s) {
  // Compliant by exception: no simple format-based alternative
  std::cout &lt;&lt; std::quoted(s, '$', '-');
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_documentation">Documentation</h3>
<div class="ulist">
<ul>
<li>
<p>C&#43;&#43; reference - <a href="https://en.cppreference.com/w/cpp/utility/format/format"><code>std::format</code></a></p>
</li>
<li>
<p>C&#43;&#43; reference - <a href="https://en.cppreference.com/w/cpp/header/iomanip"><code>&lt;iomanip&gt;</code></a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_articles_blog_posts">Articles &amp; blog posts</h3>
<div class="ulist">
<ul>
<li>
<p>C&#43;&#43; Stories - <a href="https://www.cppstories.com/2022/custom-stdformat-cpp20/">Formatting Custom types with std::format from C&#43;&#43;20</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_related_rules">Related rules</h3>
<div class="ulist">
<ul>
<li>
<p><a data-rspec-id="S6185" class="rspec-auto-link">S6185</a> - "std::format" should be used instead of string concatenation and "std::to_string"</p>
</li>
<li>
<p><a data-rspec-id="S6484" class="rspec-auto-link">S6484</a> - Concatenated "std::format" outputs should be replaced by a single invocation</p>
</li>
<li>
<p><a data-rspec-id="S6494" class="rspec-auto-link">S6494</a> - C&#43;&#43; formatting functions should be used instead of C printf-like functions</p>
</li>
</ul>
</div>
</div>
</div>
</div>