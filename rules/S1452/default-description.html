<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A return type containing wildcards cannot be narrowed down in any context.
This indicates that the developer&#8217;s intention was likely something else.</p>
</div>
<div class="paragraph">
<p>The core problem lies in type variance.
Expressions at an input position, such as arguments passed to a method,
can have a more specific type than the type expected by the method, which is called <em>covariance</em>.
Expressions at an output position, such as a variable that receives the return result from a method,
can have a more general type than the method&#8217;s return type, which is called <em>contravariance</em>.
This can be traced back to the Liskov substitution principle.</p>
</div>
<div class="paragraph">
<p>In Java, type parameters of a generic type are invariant by default
due to their potential occurrence in both input and output positions at the same time.
A classic example of this is the methods <code>T get()</code> (output position) and <code>add(T element)</code> (input position)
in interface <code>java.util.List</code>.
We could construct cases with invalid typing in <code>List</code> if <code>T</code> were not invariant.</p>
</div>
<div class="paragraph">
<p>Wildcards can be employed to achieve covariance or contravariance in situations
where the type parameter appears in one position only:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>&lt;? extends Foo&gt;</code> for covariance (input positions)</p>
</li>
<li>
<p><code>&lt;? super Foo&gt;</code> for contravariance (output positions)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>However, covariance is ineffective for the return type of a method since it is not an input position.
Making it contravariant also has no effect since it is the receiver of the return value
which must be contravariant (use-site variance in Java).
Consequently, a return type containing wildcards is generally a mistake.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_fix_it">How to fix it</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The solution to this problem depends on the original intention of the developer. Given the examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">List&lt;? extends Animal&gt; getAnimals() { ... } // Noncompliant, wildcard with no use
List&lt;? super Plant&gt; getLifeforms() { ... }  // Noncompliant, wildcard with no use</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can remove the wildcards to make the types invariant:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">List&lt;Animal&gt; getAnimals() { ... }           // Compliant, using invariant type instead
List&lt;Plant&gt; getLifeforms() { ... }          // Compliant, using invariant type instead</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or replace them with a super- or subtypes (still invariant):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">List&lt;Dog&gt; getAnimals() { ... }              // Compliant, using subtype instead
List&lt;Lifeform&gt; getLifeforms() { ... }       // Compliant, using supertype instead</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_documentation">Documentation</h3>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.oracle.com/javase/tutorial/extra/generics/wildcards.html">The Javaâ„¢ Tutorials - Wildcards</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_articles_blog_posts">Articles &amp; blog posts</h3>
<div class="ulist">
<ul>
<li>
<p><a href="https://medium.com/javarevisited/variance-in-java-and-scala-63af925d21dc">Sinisa Louc - A Complete Guide to Variance in Java and Scala</a></p>
</li>
<li>
<p><a href="https://web.archive.org/web/20240206045705/https://kotlinexpertise.com/kotlin-generics-and-variance-vs-java/">Kotlin Expertise Blog - Kotlin Generics and Variance (Compared to Java)</a></p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)">Wikipedia - Covariance and contravariance (computer science)</a></p>
</li>
<li>
<p><a href="https://schneide.blog/2015/05/11/declaration-site-and-use-site-variance-explained/">Schneide Blog - Declaration-site and use-site variance explained</a></p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle">Wikipedia - Liskov substitution principle</a></p>
</li>
</ul>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_implementation_specification">Implementation Specification</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_message">Message</h3>
<div class="paragraph">
<p>Remove usage of generic wildcard type</p>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_comments_and_links">Comments And Links</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_on_1_nov_2013_192211_freddy_mallet_wrote">on 1 Nov 2013, 19:22:11 Freddy Mallet wrote:</h3>
<div class="paragraph">
<p>Is implemented by https://jira.sonarsource.com/browse/SONARJAVA-374</p>
</div>
</div>
</div>
</div>