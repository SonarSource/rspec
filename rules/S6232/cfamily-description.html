<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>union</code> is unsuitable for type-punning in C&#43;&#43; code, leading to undefined behavior.
There are well-defined safe alternatives that are just as fast.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In some performance-oriented algorithms, a solution to certain slow operations is reinterpreting a value as a different type of the same length while preserving its binary representation.</p>
</div>
<div class="paragraph">
<p>One of the superseded solutions, known as "union type-punning", is to use a <code>union</code> with two members with types corresponding to the source and the target types of the cast.
The operation is performed by saving the value in the member of the source type and then reading the value from the member of the target type.
Despite being allowed in C, this operation has undefined behavior according to C&#43;&#43; standard and should be replaced by <code>std::memcpy</code> (or <code>std::bit_cast</code> in C&#43;&#43;20).</p>
</div>
<div class="paragraph">
<p>Note: <code>std::memcpy</code> has no performance impact on modern compilers when used in type-punning and is optimized during compilation.</p>
</div>
<div class="paragraph">
<p>Sometimes <code>union</code> type-punning is used to remove <code>const</code>. This can create readability issues and should be replaced with <code>const_cast</code>.</p>
</div>
<div class="paragraph">
<p>This rule raises an issue on any use of a <code>union</code> that should be replaced with <code>std::memcpy</code>, <code>std::bit_cast</code>, or <code>const_cast</code>.</p>
</div>
<div class="sect2">
<h3 id="_what_is_the_potential_impact">What is the potential impact?</h3>
<div class="paragraph">
<p>The C&#43;&#43; standard states that only one <code>union</code> member can be "active" at any time.
A member becomes active once assigned a value, making the other <code>union</code> members "inactive".
The standard also states that reading from an "inactive" member is undefined behavior.</p>
</div>
<div class="paragraph">
<p>Since <code>union</code> type-punning relies on reading the "inactive" member, code using it exercises undefined behavior.
Such code can be unintentionally removed in aggressive levels of optimization.</p>
</div>
<div class="paragraph">
<p>Further problems could also arise from using <code>union</code>-based type punning in cross-platform solutions.
Since this method is mainly used with Built-in Types, which vary in size depending on the underlying architecture, it could hide a portability issue.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_fix_it">How to fix it</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Replace any "<code>union</code>-based type punning" solution with a standard-compliant solution.</p>
</div>
<div class="sect2">
<h3 id="_code_examples">Code examples</h3>
<div class="sect3">
<h4 id="_noncompliant_code_example">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">float fastInvSqrt(float number)
  constexpr float threehalfs = 1.5F;
  const float x2 = number * 0.5F;

  union {
     float f;
     uint32_t i;
  } conv;
  conv.f = number
  conv.i = 0x5f3759df - (conv.i &gt;&gt; 1);  // Noncompliant: undefined behavior
  conv.f *= threehalfs - (x2 * conv.f * conv.f); // Noncompliant: undefined behavior
  return conv.f;
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution">Compliant solution</h4>
<div class="paragraph">
<p>Solution before C&#43;&#43;20:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">float fastInvSqrt(float number) {
  constexpr float threehalfs = 1.5F;
  const float x2 = number * 0.5F;

  std::uint32_t i;
  static_assert(sizeof(i) == sizeof(number), "Use equal-size types to achieve safe type-punning");
  std::memcpy(&amp;i, &amp;number, sizeof(float)); // Compliant
  i  = 0x5f3759df - (i &gt;&gt; 1);

  float result;
  static_assert(sizeof(result) == sizeof(i), "Use equal-size types to achieve safe type-punning");
  std::memcpy(&amp;result, &amp;i, sizeof(float)); // Compliant
  result  *= threehalfs - (x2 * result * result);
  return result;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>C&#43;&#43;20 and after:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">float fastInvSqrt(float number) {
  constexpr float threehalfs = 1.5F;
  const float x2 = number * 0.5F;

  auto i = std::bit_cast&lt;std::uint32_t&gt;(number); // Compliant
  i  = 0x5f3759df - (i &gt;&gt; 1);
  auto result = std::bit_cast&lt;float&gt;(i); // Compliant
  result  *= threehalfs - (x2 * result * result);
  return result;
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_conference_presentations">Conference presentations</h3>
<div class="ulist">
<ul>
<li>
<p>CppCon 2019 - <a href="https://www.youtube.com/watch?v=_qzMpk-22cc">Type punning in modern C&#43;&#43;, Timur Doumler</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_related_rules">Related rules</h3>
<div class="ulist">
<ul>
<li>
<p><a data-rspec-id="S6181" class="rspec-auto-link">S6181</a> - replacing <code>std::memcpy</code> with <code>std::bit_cast</code>.</p>
</li>
</ul>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_comments_and_links">Comments And Links</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_relates_to_s6181">relates to: <a data-rspec-id="S6181" class="rspec-auto-link">S6181</a></h3>

</div>
</div>
</div>