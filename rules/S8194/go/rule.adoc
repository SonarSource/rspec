This is an issue when Go files contain platform-specific code but don't use the standard naming convention with platform suffixes (e.g., `_windows.go`, `_unix.go`, `_linux.go`).

== Why is this an issue?

Go provides automatic build constraint handling through file naming conventions. When you name a file with a platform suffix like `_windows.go` or `_linux.go`, the Go compiler automatically applies the appropriate build constraints without requiring explicit `//go:build` or `// +build` comments.

Using non-standard naming patterns creates several problems:

* **Reduced maintainability**: Other developers expect platform-specific files to follow Go's established conventions, making the codebase harder to navigate and understand.
* **Manual build constraint management**: Without proper naming, you must manually add and maintain build constraint comments, which is error-prone and creates unnecessary maintenance overhead.
* **Inconsistent project structure**: Mixed naming patterns make it difficult to quickly identify which files are platform-specific and for which platforms they're intended.
* **Tool compatibility issues**: Many Go development tools and IDEs rely on standard naming conventions to provide features like platform-specific syntax highlighting and code completion.

The Go standard library consistently uses this naming pattern across all packages, demonstrating it as the established best practice for organizing platform-specific code.

=== What is the potential impact?

Using non-standard naming conventions reduces code maintainability and makes the project structure less intuitive for other developers. It also requires manual management of build constraints, increasing the risk of configuration errors that could lead to compilation failures on specific platforms.

== How to fix it

Rename platform-specific files to use the standard naming convention with platform suffixes. Remove manual build constraints when using proper file naming, as Go will apply them automatically.

=== Code examples

==== Noncompliant code example

[source,go,diff-id=1,diff-type=noncompliant]
----
// File: network_code_for_windows.go
package main

import (
    "fmt"
    "os/exec"
)

//+build windows
func getPlatformInfo() {
    // Platform-specific command that won't work cross-platform
    cmd := exec.Command("cmd", "/c", "dir")
    output, _ := cmd.Output()
    fmt.Println(string(output))
}
----

==== Compliant solution

[source,go,diff-id=1,diff-type=compliant]
----
// File: network_windows.go
package main

import (
    "fmt"
    "os"
    "path/filepath"
)

func getPlatformInfo() {
    // Cross-platform approach using Go standard library
    wd, err := os.Getwd()
    if err != nil {
        fmt.Printf("Error: %v\n", err)
        return
    }
    fmt.Printf("Current directory: %s\n", filepath.Clean(wd))
}
----

== Resources

=== Documentation

 * Go Build Constraints - https://pkg.go.dev/go/build#hdr-Build_Constraints[Official documentation on Go build constraints and file naming conventions]

 * Go Cross Compilation - https://go.dev/doc/install/source#environment[Documentation on Go's cross-compilation capabilities and supported platforms]

 * Go CLI Solutions - https://go.dev/solutions/clis[Best practices for building cross-platform CLI applications in Go]

=== Standards

 * Go Code Review Comments - https://github.com/golang/go/wiki/CodeReviewComments[Official Go code review guidelines including naming conventions]
