The Kotlin coroutines API provides `async` and `launch` as a way to launch asynchronous work. The difference being that `async` provides an `await()` function, which blocks until the asynchronous task is complete and returns the result of the execution. `launch` is not designed to return a result, i.e. follows the idea of "fire and forget".

Accordingly, whenever `async` is used, the result of the execution is expected to be used at some point. If `async` is used in a "fire and forget" manner, `launch` is the more appropriate interface to use.

This rule raises an issue when `async` is used without the result of the operation being retrieved.

== Noncompliant Code Example

----
suspend fun doSomething() {
    coroutineScope {
        async {
            // Do some work
            "result"
        }
    }
}
----

== Compliant Solution

Using `launch`:
----
suspend fun doSomething() {
    coroutineScope {
        launch {
            // Do some work
        }
    }
}
----

Using `await` to retrieve the result of the asynchronous operation:
----
suspend fun doSomething(): String {
    return coroutineScope {
        val asyncTask = async {
            // Do some work
            "result"
        }
        // Return the result, possibly with some other processing before
        asyncTask.await()
    }
}
----

== See

* https://kotlinlang.org/docs/composing-suspending-functions.html#concurrent-using-async[Concurrent using async]
