Coroutines should be launched with an appropriate dispatcher, depending on a coroutine's task. Dispatchers determine which threads a coroutine ends up running on. As different threads and thread groups are designed for varying purposes, using inappropriate dispatchers can cause performance issues.

An example of when an explicit change in dispatcher is appropriate includes the execution of long-running blocking I/O functions within a suspending function, which is otherwise executed on the main thread. It would be undesirable to execute the I/O portion of the work on the main thread as well, as it could lead to a blocked main thread for significant amounts of time. Instead, the `IO` dispatcher could be used, which is able to start and shutdown threads dynamically.

Coroutine builders such as `launch` and `async` accept an optional `CoroutineContext`, which can be used to specify which dispatcher to use. `withContext` also allows developers to specify a dispatcher to use.

== Noncompliant Code Example

----
class ExampleClass(
    private val client: HttpClient,
    private val request: HttpRequest
) {
    suspend fun doSomething() = coroutineScope {
        launch {
            client.send(request, HttpResponse.BodyHandlers.discarding())
        }
    }
}
----

== Compliant Solution

----
class ExampleClass(
    private val client: HttpClient,
    private val request: HttpRequest,
    private val ioDispatcher: CoroutineDispatcher = Dispatchers.IO
) {
    suspend fun doSomething() = coroutineScope {
        launch(ioDispatcher) {
            client.send(request, HttpResponse.BodyHandlers.discarding())
        }
    }
}
----

== See

* https://kotlinlang.org/docs/coroutine-context-and-dispatchers.html[Coroutine context and dispatchers]
