<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This rule raises an issue when a custom type intended to be used as an error either lacks an Error() method implementation or implements it in a way that causes infinite loops.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In Go, the <code>error</code> type is a built-in interface that requires a single method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-go" data-lang="go">type error interface {
    Error() string
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When you create a custom type to represent errors, you must implement this <code>Error()</code> method to satisfy the interface. Without it, your type cannot be used as an error, leading to compilation errors or runtime panics.</p>
</div>
<div class="paragraph">
<p>A common mistake when implementing the <code>Error()</code> method is calling formatting functions like <code>fmt.Sprint()</code>, <code>fmt.Sprintf()</code>, or <code>fmt.Print()</code> directly on the receiver. This creates an infinite loop because these formatting functions automatically call the <code>Error()</code> method when they encounter a type that implements the error interface.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s what happens in the infinite loop:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Your <code>Error()</code> method calls <code>fmt.Sprint(e)</code></p>
</li>
<li>
<p><code>fmt.Sprint()</code> sees that <code>e</code> implements the error interface</p>
</li>
<li>
<p><code>fmt.Sprint()</code> calls <code>e.Error()</code> to get the string representation</p>
</li>
<li>
<p>This calls your <code>Error()</code> method again, creating an endless cycle</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This infinite recursion will cause a stack overflow and crash your program.</p>
</div>
<div class="sect2">
<h3 id="_what_is_the_potential_impact">What is the potential impact?</h3>
<div class="paragraph">
<p>Missing or incorrectly implemented <code>Error()</code> methods can cause:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Compilation failures</strong> when trying to use the custom type as an error</p>
</li>
<li>
<p><strong>Runtime panics</strong> due to stack overflow from infinite recursion</p>
</li>
<li>
<p><strong>Application crashes</strong> that are difficult to debug</p>
</li>
<li>
<p><strong>Poor error handling</strong> that makes troubleshooting harder for users and developers</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_fix_it">How to fix it</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_code_examples">Code examples</h3>
<div class="paragraph">
<p>Add the missing Error() method that returns a meaningful error message string.</p>
</div>
<div class="sect3">
<h4 id="_noncompliant_code_example">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-go" data-lang="go">type MyError struct {
    When time.Time
    What string
}
// Missing Error() method - this type cannot be used as an error</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-go" data-lang="go">type MyError struct {
    When time.Time
    What string
}

func (e *MyError) Error() string {
    return fmt.Sprintf("at %v, %s", e.When, e.What)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Update the Error() method to avoid calling formatting functions on the receiver itself.</p>
</div>
</div>
<div class="sect3">
<h4 id="_noncompliant_code_example_2">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-go" data-lang="go">type ValueReceiver struct {
	Info string
}

func (e ValueReceiver) Error() string {
	return fmt.Sprint(e) // Noncompliant: fmt.Sprint calls e.Error() again, causing infinite recursion
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution_2">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-go" data-lang="go">type ValueReceiver struct {
	Info string
}

func (e ValueReceiver) Error() string {
	return fmt.Sprintf("Error at %v, %s", e.When, e.What)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_documentation">Documentation</h3>
<div class="ulist">
<ul>
<li>
<p>Go Tour - Errors - <a href="https://go.dev/tour/methods/19">Official Go tutorial explaining the error interface and how to implement custom error types</a></p>
</li>
<li>
<p>Go Tour - Exercise: Errors - <a href="https://go.dev/tour/methods/20">Hands-on exercise demonstrating proper Error() method implementation and common pitfalls</a></p>
</li>
<li>
<p>Go by Example - Errors - <a href="https://gobyexample.com/errors">Practical examples of error handling and custom error types in Go</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>