This rule raises an issue when `std::is_constant_evaluated()` or `if consteval` are used in context,
where they always produce the same result, i.e. are always `true` or always `false`.

== Why is this an issue?

The `std::is_constant_evaluated` function (introduced in {cpp}20) and the `if consteval` language construct (introduced in {cpp}23) are used to determine whether the evaluation is performed at compile-time or runtime.
This can be useful when, for example, two different implementations are provided for an algorithm: 
one, that does not perform any IO operations and is compatible with compile-time evaluation, and the other one, at runtime that emits log entries as side effects.

These constructs should be used inside functions that are `constexpr`, and thus can be evaluated both at compile-time and runtime.

When used inside a context that is either always evaluated at compile-time or always evaluated at runtime,
a call to `std::is_constant_evaluated` will always return the same result, similarly `if (not) consteval` will always evaluate the same branch,
making their use redundant.

This rule will raise issues for contexts where expressions are always evaluated at compile-time or always evaluated at runtime.

In contexts that are always evaluated at compile-time:

* `+std::is_constant_evaluated()+` will always return `true`,
* `+if consteval { /* then-branch */ }+` will always be `true` and evaluate the `then-branch`,
* `+if !consteval { /* then-branch */ } else { /* else-branch */}+` will always be `false` and evaluate the `else-branch`.

These include:

* The conditions of an `if constexpr` or a `static_assert`
+
[source,cpp]
----
constexpr double power(double b, int x) {
  if constexpr (std::is_constant_evaluated()) {  // Noncompliant: will always be true
    // compile-time implementation
  } else {
    // runtime implementation
  }
}

static_assert(std::is_constant_evaluated()); // Noncompliant: will always return true
----

* The initialization of a variable declared `constexpr` or `constinit`
+
[source,cpp]
----
constexpr int size = std::is_constant_evaluated() ? 10 : 20; // Noncompliant: will always return true
constinit int val = std::is_constant_evaluated() ? 20 : 30; // Noncompliant: will always return true
---- 

* All expressions inside the immediate context. This includes bodies of `consteval` function, `then` branches of `if consteval`, and `else` branches of `if not consteval`.
+
[source,cpp]
----
consteval bool onlyCompileTimeFunc() {
  if consteval {  // Noncompliant: always true
    /* Branch is always taken */
  } else {
    /* Branch is never taken */
  }
  
  if not consteval { // Noncompliant: always false
    /* Branch is never taken */
  } else {
    /* Branch is always taken */
  }

  bool ce = std::is_constant_evaluated(); // Noncompliant: will always returns true
  return std::is_constant_evaluated(); // Noncompliant: will always returns true
}

constexpr bool possiblyCompileTimeFunc() {
  if consteval { // Compliant: depends on the call side
    if consteval { // Noncompliant: will always be true
      /* .... */ 
    }
    if not consetval { // Noncompliant: will always be false
      /* .... */
    }
    return std::is_constant_evaluated(); // Noncompliant: will always returns true
  }

  if ! consteval { // Compliant: depends on the call side
    /* Runtime branch */
  } else {
    return std::is_constant_evaluated(); // Noncompliant: will always returns true
  }

  return std::is_constant_evaluated(); // Compliant: depends on call side
}
----

In contexts that are always evaluated at runtime:

* `+std::is_constant_evaluated()+` will always return `false`,
* `+if consteval { /* then-branch */ } else { /* else-branch */}+` will always be `false` and evaluate `else-branch`.
* `+if !consteval { /* then-branch */ }+` will always be `true` and evaluate `then-branch`.

They include:

* The body of functions that are not `constexpr` or `consteval`,

* `else` branches of `if consteval`,

* `then` branches of `if not consteval`.

[source,cpp]
----
bool onlyRuntimeFunc() {
  if consteval { // Noncompliant: always false
    /* Never taken branch */
  } else {
    /* Always taken branch */
  }

  if not consteval {  // Noncompliant: always true
    /* Always taken branch */
  } else {
    /* Never taken branch */
  }

  bool ce = std::is_constant_evaluated(); // Noncompliant: will always returns false
  return std::is_constant_evaluated(); // Noncompliant: will always returns false
}

constexpr bool possiblyCompileTimeFunc() {
  if not consteval { // Compliant: depends on the call side
    if consteval { // Noncompliant: will always be false
      /* ... */ 
    }
    if not consetval { // Noncompliant: will always be true
      /* .... */
    }
    return std::is_constant_evaluated(); // Noncompliant: will always returns false
  }

  if consteval { // Compliant: depends on the call side
    /* Compile-time branch */
  } else {
    return std::is_constant_evaluated(); // Noncompliant: will always returns false
  }

  return std::is_constant_evaluated(); // Compliant: depends on call side
}
----

=== When issues are raised for lambdas?

The call operator of a lambda can be explicitly marked `consteval`. In such cases, it can only be invoked at compile-time, and the rule raises an issue:

[source,cpp]
----
[] () consteval {
  if consteval {  // Noncompliant: always true
    /* .... */
  }
  return std::is_constant_evaluated(); // Noncompliant: will always returns true
};
----

Otherwise, the lambda call operator is implicitly considered to be `constexpr`,
regardless if it is marked so.
This means that the lambda can be invoked at compile-time, 
and uses of `std::is_constant_evaluated()` and `if consteval` are not redundant.

However, when lambda is invoked locally only in compile-time or runtime context, 
uses of such functions are still redundant.
In particular, this is clear, when the lambda is immediately invoked, to initialize a variable for example. The rule will raise issues in that case:

[source,cpp]
----
// The lambda is provably invoked at compile-time only:
constexpr bool ce = [] () {
  if consteval {  // Noncompliant: always true
    return true;
  }
  return false;
}();
----

=== When do `constexpr` functions become immediate (`consteval`)?

An immediate (`consteval`) function can be invoked only at compile-time,
and thus requires that all arguments are known at compile-time,
i.e. either there are constants or the function is invoked in the immediate context:
[source,cpp]
----
consteval int process(int);
float process(float);

constexpr void foo(int x) {
  return process(x); // ill-formed, the process cannot be called at compile-time
}
----

In the case of non-template functions, this can be fixed by putting the call
to immediate function inside an `if consteval` block.
However, in the case of templates, it is possible that depending on the template parameters,
an immediate or runtime function will be called.
In such case, the compiler will automatically change the enclosing function to an immediate function,
in a process referred to as immediate escalation:

[source,cpp]
----
consteval int process(int);
float process(float);

template<typename T>
constexpr void foo(T x) { 
  // Calls `consteval` process if T = int, and runtimne for T = float.
  // foo<int> is promoted to immediate function.
  return process(x);
}
----

The same behavior is applied to lambdas, both generic and non-generic,
if they contain an immediate invocation.

As a consequence, uses of `std::is_constant_evaluated()` and `if consteval` may be redundant,
in case of immediate escalated lambda or function template instantiations.
This rule will raise issues if such uses are redundant for all possible specializations
of lambda or template:

[source,cpp]
----
consteval int process(int);
float process(float);

template<typename T>
constexpr void conditionallyImmediate(T x) {
  process(x); // Calls consteval function depending on the argument type
  return std::is_constant_evaluated(); // Compliant: not all specializations are immediate
}

template<typename T>
constexpr void alwaysImmediate(T x, int t) {
  process(t); // Always call consteval function
  return std::is_constant_evaluated(); // Noncompliant: all specializations are immediate
}

constexpr auto nonGenericLambda = [](int x) {
  process(x); // Always call consteval function
  return std::is_constant_evaluated(); // Noncompliant: lambda is immediate
}

template<typename T>
constexpr auto = conditionalGenericLambda = [] (auto x) {
  process(x); // Calls consteval function depending on the argument type
  return std::is_constant_evaluated(); // Compliant: not all specializations are immediate
}

template<typename T>
constexpr auto alwaysGenericLambda = [](T x, int t) {
  process(t); // Always call consteval function
  return std::is_constant_evaluated(); // Noncompliant: all specializations are immediate
}
----

== How to fix it

Depending on the context, the issue may be fixed by:

* changing the context of invocation: removing `constexpr` from `if` or changing function from `consteval` to `constexpr`
* removing dead code: replacing `std::is_constant_evaluated()` with the produced value, removing `if consteval` and dead branches

=== Code examples

Changing `if constexpr` into `if`, so the condition is no longer always evaluated at compile-time.

==== Noncompliant code example

[source,cpp,diff-id=1,diff-type=noncompliant]
----
constexpr double power(double b, int x) {
  if constexpr (std::is_constant_evaluated()) {  // Noncompliant: will always be true
    // compile-time implementation
  } else {
    // runtime implementation
  }
}
----

==== Compliant solution

[source,cpp,diff-id=1,diff-type=compliant]
----
constexpr double power(double b, int x) {
  if (std::is_constant_evaluated()) {
    // compile-time implementation
  } else {
    // runtime implementation
  }
}
----

Removing dead branches and inlining the result of `std::is_constant_evaluated()`.

==== Noncompliant code example

[source,cpp,diff-id=2,diff-type=noncompliant]
----
constexpr bool possiblyCompileTimeFunc() {
  if consteval {
    if consteval { // Noncompliant: will always be true
      /* Code A */ 
    }
    if not consteval { // Noncompliant: will always be false
      /* Code B */
    }
    return std::is_constant_evaluated(); // Noncompliant: will always returns true
  }

  if ! consteval {
    /* Code C */
  }

  return std::is_constant_evaluated(); // Compliant: result depends on evaluation
}
----

==== Compliant solution

[source,cpp,diff-id=2,diff-type=compliant]
----
constexpr bool possiblyCompileTimeFunc() {
  if consteval {
    /* Code A */ 
    return true;
  }

  if ! consteval {
    /* Code C */
  }
 
  return std::is_constant_evaluated(); // Compliant: result depends on evaluation
}
----

Changing the function to be declared as `constexpr` to allow runtime evaluation:

==== Noncompliant code example

[source,cpp,diff-id=3,diff-type=noncompliant]
----
consteval bool onlyCompileTimeFunc() {
  if consteval {  // Noncompliant: always true
    /* Code A */
  } else {
    /* Code B */
  }
  
  return std::is_constant_evaluated(); // Noncompliant: will always returns true
}
----

==== Compliant solution

[source,cpp,diff-id=3,diff-type=compliant]
----
constexpr bool onlyCompileTimeFunc() {
  if consteval { // Compliant: result depends on evaluation
    /* Code A */
  } else {
    /* Code B */
  }
  
  return std::is_constant_evaluated(); // Compliant: result depends on evaluation
}
----


== Resources

=== Documentation
* {cpp} reference - https://en.cppreference.com/w/cpp/language/consteval[consteval specifier]
* {cpp} reference - https://en.cppreference.com/w/cpp/language/if#Consteval_if[Consteval if]

=== Standards

* Open Standards - https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2564r3.html[P2564R3] `consteval` needs to propagate up

