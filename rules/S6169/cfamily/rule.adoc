This rule raises an issue when `std::is_constant_evaluated()` or `if consteval` is used in context,
where they always produce the same result, i.e. always be `true` or `false`.

== Why is this an issue?

The `std::is_constant_evaluated` function (since {cpp}20) and the `if consteval` language construct (since {cpp}23) are used to determine whether the evaluation is performed at compile time or runtime.
This can be useful when, for example, two different implementations are provided for an algorithm: 
one, that does not perform any io operations and is compatible with compile-time evaluation, and the other one, for runtime that emits log entries as side effects.

This constructs should be used inside the functions that are `constexpr`, and thus can be evaluted both at compile-time and runtime.
When used inside context that either always evaluated at compile or always evaluted at runtime,
a call to `std::is_constant_evaluated` will always return the same result, similarly `if (not) consteval` will always evaluate the same branch,
making their uses redundant.

This rule will raise issues for context, where expressions are always evaluated at compile time, and:

* `std::is_constant_evaluated++` will always return `true`,
* `if conteval { /* then-branch */ }` will always be `true` and evalute `then-branch`,
* `if !consteval { /* then-branch */ } else { /* else-branch */}` will always be `false` and evaluate `else-branch`.

The conditions of the `if constexpr` and `static_assert` are always constant-evaluated:
[source,cpp]
----
constexpr double power(double b, int x) {
  if constexpr (std::is_constant_evaluated()) {  // Noncompliant: will always be true
    // compile-time implementation
  } else {
    // runtime implementation
  }
}

static_assert(std::is_constant_evaluted()); // Noncompliant: will always return true
----

Similarly, the initialization of the variables declared `constexpr` or `constinit` is performed at compile time:
[source,cpp]
----
constexpr int size = std::is_constant_evaluated() ? 10 : 20; // Noncompliant: will always return true
constinit int val = std::is_constant_evaluated() ? 20 : 30; // Noncompliant: will always return true
---- 

Finally, all expressions inside immediate context are constant-evaluated, 
this includes bodies of `consteval` function, `true` branches of `if consteval`, and `false` branches of `if not consteval`.
[source,cpp]
----
consteval bool onlyCompileTimeFunc() {
  if consteval {  // Noncompliant: always true
    /* Always taken branch */
  } else {
    /* Never taken branch */
  }
  
  if not consteval { // Noncompliant: always false
    /* Never taken branch */
  } else {
    /* Always taken branch */
  }

  bool ce = std::is_constant_evaluated(); // Noncompliant: will always returns true
  return std::is_constant_evaluated(); // Noncompliant: will always returns true
}

constexpr bool possiblyCompileTimeFunc() {
  if consteval { // Complaint: depends on the call side
    if consteval { // Noncompliant: will always be true
      /* .... */ 
    }
    if not consetval { // Noncompliant: will always be false
      /* .... */
    }
    return std::is_constant_evaluated(); // Noncompliant: will always returns true
  }

  if ! consteval { // Complaint: depends on the call side
    /* Runtime branch */
  } else {
    return std::is_constant_evaluated(); // Noncompliant: will always returns true
  }

  return std::is_constant_evaluated(); // Compliant: depends on call side
}
----

In contrast the bodies of functions that are not `constexpr` or `consteval`, `false` branches of `if consteval`, and `true` branches of `if not consteval`,
are always evaluated at runtime. As consequence: 

* `std::is_constant_evaluated++` will always return `false`,
* `if consteval { /* then-branch */ } else { /* else-branch */}` will always be `false` and evaluate `else-branch`.
* `if !consteval { /* then-branch */ }` will always be `true` and evaluate `else-branch`.

This rule also raises issues for uses of these construct in this runtime only constexts.
[source,cpp]
----
bool onlyRuntimeFunc() {
  if consteval { // Noncompliant: always false
    /* Never taken branch */
  } else {
    /* Always taken branch */
  }

  if not consteval {  // Noncompliant: always true
    /* Always taken branch */
  } else {
    /* Never taken branch */
  }

  bool ce = std::is_constant_evaluated(); // Noncompliant: will always returns false
  return std::is_constant_evaluated(); // Noncompliant: will always returns false
}

constexpr bool possiblyCompileTimeFunc() {
  if not consteval { // Complaint: depends on the call side
    if consteval { // Noncompliant: will always be false
      /* ... */ 
    }
    if not consetval { // Noncompliant: will always be true
      /* .... */
    }
    return std::is_constant_evaluated(); // Noncompliant: will always returns false
  }

  if consteval { // Complaint: depends on the call side
    /* Compile-time branch */
  } else {
    return std::is_constant_evaluated(); // Noncompliant: will always returns false
  }

  return std::is_constant_evaluated(); // Compliant: depends on call side
}
----

=== When issues are raised from lambdas?

Call operator of the lambda, can be explicitly marked `consteval`,
and in such case it can be invoked only at compile time, and the rule raises an issue:

[source,cpp]
----
[] () consteval {
  if consteval {  // Noncompliant: always true
    /* .... */
  }
  return std::is_constant_evaluated(); // Noncompliant: will always returns true
};
----

Otherwise, the lambda call operator is implicitly considered to be `constexpr`,
regardless if it is marked so.
This means that the lambda can be invoked at compile time, 
and uses of the the `std::is_constant_evaluated()` and `if consteval` are not redundant.

However, when lambda is invoked locally only in compile time or runtime context, 
uses of such functions are still redundant.
In particular, this is clear, when the lambda is immiediatelly invoked, for exmaple
to initializer variable, and the rule will raise issue in such situation:

[source,cpp]
----
// The lambnda is provably invoked at compile-time only:
constexpr bool ce = [] () {
  if consteval {  // Noncompliant: always true
    return true;
  }
  return false;
}();
----

=== Immediate escalation.

=== ?? Constant varibles

== How to fix it?

Depending on the context, the issue may be fixed by:

* changing the context of invocation: removing `constexpr` from `if` or changing function from `consteval` to `constexpr`
* removing dead code: replacing `std::is_constant_evaluated()` with the produced value, removing `if consteval` and dead branches

== Code examples

Changing `if constexpr` into `if`, so the condition is no longer always evaluated at compile time. 

==== Noncompliant code example

[source,cpp,diff-id=1,diff-type=noncompliant]
----
constexpr double power(double b, int x) {
  if constexpr (std::is_constant_evaluated()) {  // Noncompliant: will always be true
    // compile-time implementation
  } else {
    // runtime implementation
  }
}
----

==== Compliant solution

[source,cpp,diff-id=1,diff-type=compliant]
----
constexpr double power(double b, int x) {
  if (std::is_constant_evaluated()) {
    // compile-time implementation
  } else {
    // runtime implementation
  }
}
----

Removing dead branches and inlining the result of `std::is_constant_evaluated()`.

==== Noncompliant code example

[source,cpp,diff-id=2,diff-type=noncompliant]
----
constexpr bool possiblyCompileTimeFunc() {
  if consteval {
    if consteval { // Noncompliant: will always be true
      /* Code A */ 
    }
    if not consetval { // Noncompliant: will always be false
      /* Code B */
    }
    return std::is_constant_evaluated(); // Noncompliant: will always returns true
  }

  if ! consteval {
    /* Code C */
  }

  return std::is_constant_evaluated(); // Compliant: result depends on evaluation
}
----


==== Compliant solution

[source,cpp,diff-id=2,diff-type=compliant]
----
constexpr bool possiblyCompileTimeFunc() {
  if consteval {
      /* Code A */ 
    return true;
  }

  if ! consteval {
    /* Code C */
  }
 
  return std::is_constant_evaluated(); // Compliant: result depends on evaluation
}
----

Changing the function to be declared as `constexpr` to allow runtime evaluation:

==== Noncompliant code example

[source,cpp,diff-id=3,diff-type=noncompliant]
----
consteval bool onlyCompileTimeFunc() {
  if consteval {  // Noncompliant: always true
    /* Code A */
  } else {
    /* Code B */
  }
  
  return std::is_constant_evaluated(); // Noncompliant: will always returns true
}
----

==== Compliant solution

----
constexpr bool onlyCompileTimeFunc() {
  if consteval { // Compliant: result depends on evaluation
    /* Code A */
  } else {
    /* Code B */
  }
  
  return std::is_constant_evaluated(); // Compliant: result depends on evaluation
}
----


== Resources

=== Documentation
* {cpp} reference - https://en.cppreference.com/w/cpp/language/consteval[consteval specifier]
* {cpp} reference - https://en.cppreference.com/w/cpp/language/if#Consteval_if[Consteval if]
