This rule raises an issue when `std::is_constant_evaluated()` or `if consteval` is used in context,
where they always produce the same result, i.e. always be `true` or `false`.

== Why is this an issue?

The `std::is_constant_evaluated` function (since {cpp}20) and the `if consteval` language construct (since {cpp}23) are used to determine whether the evaluation is performed at compile time or runtime.
This can be useful when, for example, two different implementations are provided for an algorithm: 
one, that does not perform any io operations and is compatible with compile-time evaluation, and the other one, for runtime that emits log entries as side effects.

This constructs should be used inside the functions that are `constexpr`, and thus can be evaluted both at compile-time and runtime.
When used inside context that either always evaluated at compile or always evaluted at runtime,
a call to `std::is_constant_evaluated` will always return the same result, similarly `if (not) consteval` will always evaluate the same branch,
making their uses redundant.

This rule will raise issues for context, where expressions are always evaluated at compile time, and:

* `std::is_constant_evaluated++` will always return `true`,
* `if conteval { /* then-branch */ }` will always be `true` and evalute `then-branch`,
* `if !consteval { /* then-branch */ } else { /* else-branch */}` will always be `false` and evaluate `else-branch`.

The conditions of the `if constexpr` and `static_assert` are always constant-evaluated:
[source,cpp]
----
constexpr double power(double b, int x) {
  if constexpr (std::is_constant_evaluated()) {  // Noncompliant: will always be true
    // compile-time implementation
  } else {
    // runtime implementation
  }
}

static_assert(std::is_constant_evaluted()); // Noncompliant: will always return true
----

Similarly, the initialization of the variables declared `constexpr` or `constinit` is performed at compile time:
[source,cpp]
----
constexpr int size = std::is_constant_evaluated() ? 10 : 20; // Noncompliant: will always return true
constinit int val = std::is_constant_evaluated() ? 20 : 30; // Noncompliant: will always return true
---- 

Finally, all expressions inside the immediate context are constant-evaluated, 
this includes bodies of `consteval` function, `true` branches of `if consteval`, and `false` branches of `if not consteval`.
[source,cpp]
----
consteval bool onlyCompileTimeFunc() {
  if consteval {  // Noncompliant: always true
    /* Always taken branch */
  } else {
    /* Never taken branch */
  }
  
  if not consteval { // Noncompliant: always false
    /* Never taken branch */
  } else {
    /* Always taken branch */
  }

  bool ce = std::is_constant_evaluated(); // Noncompliant: will always returns true
  return std::is_constant_evaluated(); // Noncompliant: will always returns true
}

constexpr bool possiblyCompileTimeFunc() {
  if consteval { // Complaint: depends on the call side
    if consteval { // Noncompliant: will always be true
      /* .... */ 
    }
    if not consetval { // Noncompliant: will always be false
      /* .... */
    }
    return std::is_constant_evaluated(); // Noncompliant: will always returns true
  }

  if ! consteval { // Complaint: depends on the call side
    /* Runtime branch */
  } else {
    return std::is_constant_evaluated(); // Noncompliant: will always returns true
  }

  return std::is_constant_evaluated(); // Compliant: depends on call side
}
----

In contrast the bodies of functions that are not `constexpr` or `consteval`, `false` branches of `if consteval`, and `true` branches of `if not consteval`,
are always evaluated at runtime. As consequence: 

* `std::is_constant_evaluated++` will always return `false`,
* `if consteval { /* then-branch */ } else { /* else-branch */}` will always be `false` and evaluate `else-branch`.
* `if !consteval { /* then-branch */ }` will always be `true` and evaluate `else-branch`.

This rule also raises issues for uses of these construct in this runtime only constexts.
[source,cpp]
----
bool onlyRuntimeFunc() {
  if consteval { // Noncompliant: always false
    /* Never taken branch */
  } else {
    /* Always taken branch */
  }

  if not consteval {  // Noncompliant: always true
    /* Always taken branch */
  } else {
    /* Never taken branch */
  }

  bool ce = std::is_constant_evaluated(); // Noncompliant: will always returns false
  return std::is_constant_evaluated(); // Noncompliant: will always returns false
}

constexpr bool possiblyCompileTimeFunc() {
  if not consteval { // Complaint: depends on the call side
    if consteval { // Noncompliant: will always be false
      /* ... */ 
    }
    if not consetval { // Noncompliant: will always be true
      /* .... */
    }
    return std::is_constant_evaluated(); // Noncompliant: will always returns false
  }

  if consteval { // Complaint: depends on the call side
    /* Compile-time branch */
  } else {
    return std::is_constant_evaluated(); // Noncompliant: will always returns false
  }

  return std::is_constant_evaluated(); // Compliant: depends on call side
}
----

=== When issues are raised from lambdas?

The call operator of the lambda can be explicitly marked `consteval`,
and in such case, it can be invoked only at compile time, and the rule raises an issue:

[source,cpp]
----
[] () consteval {
  if consteval {  // Noncompliant: always true
    /* .... */
  }
  return std::is_constant_evaluated(); // Noncompliant: will always returns true
};
----

Otherwise, the lambda call operator is implicitly considered to be `constexpr`,
regardless if it is marked so.
This means that the lambda can be invoked at compile time, 
and uses of the `std::is_constant_evaluated()` and `if consteval` are not redundant.

However, when lambda is invoked locally only in compile time or runtime context, 
uses of such functions are still redundant.
In particular, this is clear, when the lambda is immediately invoked, for example
to initializer variable, and the rule will raise issues in such a situation:

[source,cpp]
----
// The lambnda is provably invoked at compile-time only:
constexpr bool ce = [] () {
  if consteval {  // Noncompliant: always true
    return true;
  }
  return false;
}();
----

=== When `constexpr` function becomes immediate (`consteval`)?

An immediate (`consteval`) function can be invoked only at compile time,
and thus requires that all arguments are known at compile time,
i.e. either there are constants or the function is invoked in the immediate context:
[source,cpp]
----
consteval int process(int);
float process(float);

constexpr void foo(int x) {
  return process(x); // ill-formed, the process cannot be called at compile-time
}
----

In the case of non-template functions, this can be fixed by putting the call
to immediate function inside of `if consteval` block.
However, in the case of templates, it is possible that depending on the template parameters,
an immediate or runtime function will be called.
In such case, the compiler will automatically change the enclosing function to immediate function, in a process referred to as immediate escalation:

[source,cpp]
----
consteval int process(int);
float process(float);

template<typename T>
constexpr void foo(T x) { 
  // Calls `consteval` process if T = int, and runtimne for T = float.
  // foo<int> is promoted to immediate function.
  return process(x); // immediate call if T = int, and runtime for T = float
}
----

The same behavior is applied to the lambdas, both generic and non-generic,
if they contain immediate invocation.

As consequence uses of `std::is_cosntant_evaluted()` and `if consteval` may be redundant,
in case of immediate escalated lambda or function template instantiations.
This rule will raise issues if such uses are redundant for all possible specializations
of lambda or template:

[source,cpp]
----
consteval int process(int);
float process(float);

template<typename T>
constexpr void conditionalImmediate(T x) {
  process(x); // Calls consteval function depending on the argument type
  return std::is_constant_evaluted(); // Compliant: not all specializations are immediate
}

template<typename T>
constexpr void alwaysImiediate(T x, int t) {
  process(t); // Always call consteval function
  return std::is_constant_evaluted(); // Nonompliant: all specializations are immiedate
}

constexprauto nonGenericLambda = [](int x) {
  process(x); // Always call consteval function
  return std::is_constant_evaluted(); // Nonompliant: lambda is immediate
}

template<typename T>
constexpr auto = conditionalGenericLambda = [] (auto x) {
  process(x); // Calls consteval function depending on the argument type
  return std::is_constant_evaluted(); // Compliant: not all specializations are immediate
}

template<typename T>
constexpr auto alwaysGenericLambda = [](T x, int t) {
  process(t); // Always call consteval function
  return std::is_constant_evaluted(); // Nonompliant: all specializations are immiedate
}
----

== How to fix it?

Depending on the context, the issue may be fixed by:

* changing the context of invocation: removing `constexpr` from `if` or changing function from `consteval` to `constexpr`
* removing dead code: replacing `std::is_constant_evaluated()` with the produced value, removing `if consteval` and dead branches

== Code examples

Changing `if constexpr` into `if`, so the condition is no longer always evaluated at compile time. 

==== Noncompliant code example

[source,cpp,diff-id=1,diff-type=noncompliant]
----
constexpr double power(double b, int x) {
  if constexpr (std::is_constant_evaluated()) {  // Noncompliant: will always be true
    // compile-time implementation
  } else {
    // runtime implementation
  }
}
----

==== Compliant solution

[source,cpp,diff-id=1,diff-type=compliant]
----
constexpr double power(double b, int x) {
  if (std::is_constant_evaluated()) {
    // compile-time implementation
  } else {
    // runtime implementation
  }
}
----

Removing dead branches and inlining the result of `std::is_constant_evaluated()`.

==== Noncompliant code example

[source,cpp,diff-id=2,diff-type=noncompliant]
----
constexpr bool possiblyCompileTimeFunc() {
  if consteval {
    if consteval { // Noncompliant: will always be true
      /* Code A */ 
    }
    if not consetval { // Noncompliant: will always be false
      /* Code B */
    }
    return std::is_constant_evaluated(); // Noncompliant: will always returns true
  }

  if ! consteval {
    /* Code C */
  }

  return std::is_constant_evaluated(); // Compliant: result depends on evaluation
}
----


==== Compliant solution

[source,cpp,diff-id=2,diff-type=compliant]
----
constexpr bool possiblyCompileTimeFunc() {
  if consteval {
      /* Code A */ 
    return true;
  }

  if ! consteval {
    /* Code C */
  }
 
  return std::is_constant_evaluated(); // Compliant: result depends on evaluation
}
----

Changing the function to be declared as `constexpr` to allow runtime evaluation:

==== Noncompliant code example

[source,cpp,diff-id=3,diff-type=noncompliant]
----
consteval bool onlyCompileTimeFunc() {
  if consteval {  // Noncompliant: always true
    /* Code A */
  } else {
    /* Code B */
  }
  
  return std::is_constant_evaluated(); // Noncompliant: will always returns true
}
----

==== Compliant solution

----
constexpr bool onlyCompileTimeFunc() {
  if consteval { // Compliant: result depends on evaluation
    /* Code A */
  } else {
    /* Code B */
  }
  
  return std::is_constant_evaluated(); // Compliant: result depends on evaluation
}
----


== Resources

=== Documentation
* {cpp} reference - https://en.cppreference.com/w/cpp/language/consteval[consteval specifier]
* {cpp} reference - https://en.cppreference.com/w/cpp/language/if#Consteval_if[Consteval if]

=== Standards

 * Open Standards - https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2564r3.html[P2564R3] `consteval` needs to propagate up

