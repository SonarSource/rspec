This rule raises an issue when a class contains getter and setter methods for the same property where one method is synchronized and the other is not.

== Why is this an issue?

When getter and setter methods have inconsistent synchronization, it creates a race condition vulnerability in multithreaded applications.

In concurrent programming, object state must be protected consistently across all access methods. If a setter method is synchronized but its corresponding getter is not (or vice versa), threads can observe inconsistent or partially updated state.

For example, consider a scenario where one thread calls the synchronized setter to update a property while another thread simultaneously calls the unsynchronized getter. The getter thread might read the property while it's being modified, potentially seeing an invalid intermediate state.

This inconsistency can lead to:

* **Data races**: Multiple threads accessing shared data without proper coordination
* **Inconsistent object state**: Threads may observe objects in invalid states
* **Unpredictable behavior**: The application may work correctly in single-threaded scenarios but fail unpredictably under concurrent load

The problem is particularly subtle because it may not manifest during development or testing, only appearing under specific timing conditions in production environments.

=== What is the potential impact?

This synchronization inconsistency can cause data corruption, application crashes, or incorrect business logic execution in multithreaded environments. The impact severity depends on the criticality of the affected data and how frequently the methods are called concurrently.

== How to fix it

Make both the getter and setter methods synchronized to ensure consistent access to the shared property.

=== Code examples

==== Noncompliant code example

[source,groovy,diff-id=1,diff-type=noncompliant]
----
class Person {
    String name
    
    synchronized void setName(String name) {
        this.name = name
    }
    
    String getName() { // Noncompliant
        return name
    }
}
----

==== Compliant solution

[source,groovy,diff-id=1,diff-type=compliant]
----
class Person {
    String name
    
    synchronized void setName(String name) {
        this.name = name
    }
    
    synchronized String getName() {
        return name
    }
}
----

== Resources

=== Documentation

 * Java Concurrency in Practice - https://jcip.net/[Comprehensive guide to concurrent programming in Java, covering synchronization patterns and best practices]

 * Oracle Java Documentation - Synchronized Methods - https://docs.oracle.com/javase/tutorial/essential/concurrency/syncmeth.html[Official Java tutorial on synchronized methods and their proper usage]

 * Groovy Documentation - Concurrency - https://groovy-lang.org/concurrency.html[Groovy-specific concurrency features and synchronization mechanisms]

=== Standards

 * CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization - https://cwe.mitre.org/data/definitions/362.html[Describes race conditions that occur when multiple threads access shared resources without proper synchronization]

 * CWE-567: Unsynchronized Access to Shared Data in a Multithreaded Context - https://cwe.mitre.org/data/definitions/567.html[Covers vulnerabilities arising from unsynchronized access to shared data structures]

=== Related rules

 * RSPEC-2886 - https://rules.sonarsource.com/java/RSPEC-2886/[Java equivalent rule for getter and setter synchronization consistency]
