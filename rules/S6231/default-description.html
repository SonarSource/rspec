<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>std::string_view</code> (introduced in C&#43;&#43;17) and <code>std::span</code> (introduced in C&#43;&#43;20) are thin generic wrappers for a contiguous sequence of elements. These wrappers can be used to unify the interface of functions that were previously accepting references to specific container types: <code>const std::string&amp;</code>, <code>const std::vector&lt;int&gt;&amp;</code>&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>One of the benefits of such modernization is that it eliminates the need to explicitly create a temporary container. This happens in situations where part of the sequence is passed as an argument: <code>substr</code> is called on <code>std::string</code>. It can also happen when the type of the container elements needs to be adjusted: converting <code>std::vector&lt;T*&gt;</code> to <code>std::vector&lt;const T*&gt;</code>. When changing the type of a function parameter to <code>std::string_view</code> or <code>std::span</code> the modification of the function call site to remove the no longer needed temporary might be missed and the code will still compile. This rule will help eliminate these temporaries.</p>
</div>
<div class="paragraph">
<p>This rule raises an issue when an unnecessary temporary is passed as an argument to a parameter of <code>std::string_view</code> or <code>std::span</code> type.</p>
</div>
<div class="sect2">
<h3 id="_noncompliant_code_example">Noncompliant code example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">void parse(std::string_view sv);
bool oddAre0(std::span&lt;int const* const&gt; nums);
std::vector&lt;int*&gt; getNums();

void caller(std::string const&amp; s) {
  parse(s.substr(10)); // Noncompliant
  parse(std::string(s, 2, 5)); // Noncompliant
  parse(std::string(s.data(), 20)); // Noncompliant
  parse(std::string(s.data(), 10)); // Noncompliant

  std::vector&lt;int*&gt; nums = getNums();
  if (oddAre0(std::vector&lt;int const*&gt;{nums.begin(), nums.end()})) { // Noncompliant: This copy is verbose and slow
    // ...
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_compliant_solution">Compliant solution</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">void parse(std::string_view sv);
bool oddAre0(std::span&lt;int const* const&gt; nums);
std::vector&lt;int*&gt; getNums();

void caller(std::string const&amp; s) {
  parse(std::string_view(s).substr(10));
  parse(std::string_view(s).substr(2, 5));
  parse(std::string_view(s.data(), 20));
  parse({ s.data(), 10 });

  std::vector&lt;int*&gt; nums = getNums();
  if (oddAre0(nums)) {
      // ...
  }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a data-rspec-id="S6009" class="rspec-auto-link">RSPEC-6009</a> - using <code>std::string_view</code> as a parameter type</p>
</li>
<li>
<p><a data-rspec-id="S6188" class="rspec-auto-link">RSPEC-6188</a> - using <code>std::span</code> as a parameter type</p>
</li>
</ul>
</div>
<hr>
</div>
</div>
<div class="sect1">
<h2 id="_comments_and_links">Comments And Links</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_relates_to_s6009">relates to: <a data-rspec-id="S6009" class="rspec-auto-link">S6009</a></h3>

</div>
<div class="sect2">
<h3 id="_relates_to_s6188">relates to: <a data-rspec-id="S6188" class="rspec-auto-link">S6188</a></h3>

</div>
</div>
</div>