This rule raises an issue when an `import` statement references a module that is not declared as a dependency in the project's `package.json` file.

== Why is this an issue?

Importing modules that are not explicitly listed in your `package.json` dependencies can lead to serious reliability issues. While your code might work locally, it can break when dependencies are reinstalled or when deployed to different environments.

There are several scenarios where this becomes problematic:

**Missing Dependencies**: If you import a module that isn't in your `package.json`, your application will fail with a "module not found" error when the `node_modules` directory is recreated from scratch.

**Transitive Dependencies**: Sometimes you might import a module that works because it's a dependency of one of your declared dependencies (a transitive dependency). However, this creates a fragile situation - if the parent dependency removes or changes its own dependency, your code will break without warning.

**Development vs Production**: A transitive dependency might only be available in development environments but not in production, causing runtime failures that are difficult to debug.

**Version Conflicts**: Without explicit version control in your `package.json`, you have no control over which version of the transitive dependency gets installed, potentially leading to compatibility issues.

By explicitly declaring all imported modules as dependencies, you ensure reproducible builds, predictable deployments, and better dependency management across your team and different environments.

=== What is the potential impact?

Applications may fail to start or crash at runtime when deployed to production environments or when dependencies are reinstalled. This can lead to service outages, failed deployments, and difficult-to-debug issues in different environments. Team members may experience inconsistent behavior when setting up the project locally.

=== How to fix?


Add the missing module to your package.json dependencies. Use npm or yarn to install and save the dependency properly.

==== Non-compliant code example

[source,javascript,diff-id=1,diff-type=noncompliant]
----
// package.json only has: { "dependencies": { "express": "^4.18.0" } }

import lodash from 'lodash'; // Noncompliant - lodash not in dependencies
import express from 'express';

const app = express();
const result = lodash.map([1, 2, 3], x => x * 2);
----

==== Compliant code example

[source,javascript,diff-id=1,diff-type=compliant]
----
// After running: npm install lodash --save
// package.json now has: { "dependencies": { "express": "^4.18.0", "lodash": "^4.17.21" } }

import lodash from 'lodash'; // Compliant - lodash now in dependencies
import express from 'express';

const app = express();
const result = lodash.map([1, 2, 3], x => x * 2);
----

=== Documentation

 * npm documentation - package.json dependencies - https://docs.npmjs.com/cli/v9/configuring-npm/package-json#dependencies[Official npm documentation explaining how to manage dependencies in package.json]
 * Node.js modules documentation - https://nodejs.org/api/modules.html[Official Node.js documentation on the module system and how module resolution works]
 * ESLint plugin n documentation - https://github.com/eslint-community/eslint-plugin-n[Documentation for the ESLint plugin that provides Node.js-specific linting rules]

=== Standards

 * npm Best Practices - Dependency Management - https://docs.npmjs.com/cli/v9/using-npm/developers#keeping-files-out-of-your-package[npm best practices for managing dependencies and package.json]

=== Related Rules

 * n/no-extraneous-require - https://github.com/eslint-community/eslint-plugin-n/blob/master/docs/rules/no-extraneous-require.md[Similar rule for CommonJS require() statements]
 * n/no-missing-import - https://github.com/eslint-community/eslint-plugin-n/blob/master/docs/rules/no-missing-import.md[Rule that checks for imports of modules that cannot be resolved]

