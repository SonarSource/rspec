Failing to release the state of a coroutine results in leaks of the coroutine frame, its parameters, promise object, and, depending on the suspension point, a set of local variables that where preserved on heap.

On one hand, the coroutine state is automatically released by the compiler when `final_suspend()` completes without suspending the coroutine. In other words, the relevant objects are destroyed when the execution flows off the end of the "body" (as rewritten by the compiler) of the coroutine.

On the other hand, the coroutine state is manually released when `destroy()` is invoked on its handle. Note that destroying a running coroutine or one that was already destroyed leads to undefined behavior.

This rules raises an issue when a coroutine state is leaked.

== Noncompliant Code Example

[source,cpp]
----
class ComplexTask {
  struct promise_type { 
     std::suspend_always final_suspend() const noexcept;
     /* ... */
   };
  std::coroutine_handle<> handle;
public:
  Task(std::coroutine_handle<> handle) : handle(handle) { }
};

ComplexTask complexTask(Config data) {
  // At this point, a copy of `data` is created and stored as part of the coroutine state.
  co_return something();
}

void doSomeWork() {
  auto task = complexTask(buildConfig());
} // Noncompliant
// The coroutine handle was not released and the copy of `data` is leaked.
----

== Compliant Solution

[source,cpp]
----
class ComplexTask {
  struct promise_type { /* ... */ };
  std::coroutine_handle<> handle;
public:
  Task(std::coroutine_handle<> handle) : handle(handle) { }
  Task(Task&& other) : handle(std::exchange(other.handle, nullptr)) { }
  ~Task() { if (handle) handle.destroy(); }
};

ComplexTask complexTask(Config data) {
  // At this point, a copy of `data` is created and stored as part of the coroutine state.
  co_return something();
}

void doSomeWork() {
  auto task = complexTask(buildConfig());
}
// The copy of `data` is released via ~Task().
----
