Failing to release the state of a coroutine results in leaks of the coroutine frame, including its parameters, promise object, and, depending on the suspension point, a set of local variables that were preserved on the heap.

On the one hand, the compiler automatically releases the coroutine state when `final_suspend()` completes without suspending the coroutine. In other words, the relevant objects are destroyed when the execution flows off the end of the "body" (as rewritten by the compiler) of the coroutine.

On the other hand, the coroutine state is manually released when `destroy()` is invoked on its handle. Note that destroying a running coroutine or one that was already destroyed leads to undefined behavior.

Therefore, the state of a coroutine is leaked when it is suspended via `final_suspend()` but `destroy()` isn't called on its handle.

This rule raises an issue when a coroutine state is leaked.

== Noncompliant Code Example

[source,cpp]
----
class ComplexTask {
public:
  struct promise_type { 
    std::suspend_always final_suspend() const noexcept;
    /* ... */
  };
private:
  std::coroutine_handle<> handle;
  ComplexTask(std::coroutine_handle<> handle) : handle(handle) { }
};

ComplexTask complexTask(Config data) {
  // At this point, a copy of `data` is created and stored as part of the coroutine state.
  co_return something(data);
}

void doSomeWork() {
  auto task = complexTask(buildConfig());
} // Noncompliant
// The coroutine handle was not released and the copy of `data` is leaked.
----

== Compliant Solution

[source,cpp]
----
class ComplexTask {
public:
  struct promise_type {
    std::suspend_always final_suspend() const noexcept;
    /* ... */
  };
private:
  std::coroutine_handle<> handle;
  ComplexTask(std::coroutine_handle<> handle) : handle(handle) { }
  ComplexTask(ComplexTask&& other) : handle(std::exchange(other.handle, nullptr)) { }
  ~ ComplexTask() { if (handle) handle.destroy(); }
};

ComplexTask complexTask(Config data) {
  // At this point, a copy of `data` is created and stored as part of the coroutine state.
  co_return something(data);
}

void doSomeWork() {
  auto task = complexTask(buildConfig());
}
// The copy of `data` is released via ~ComplexTask().
----
