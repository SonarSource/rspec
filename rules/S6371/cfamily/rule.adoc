When coroutine states are not properly released, some objects (such as coroutine parameters) may not be released properly, which can result in memory or resource leaks.

To avoid such leaks, the coroutine states need to be destroyed. This can be achieved by calling `destroy()` on the handles of suspended coroutines.

== Noncompliant Code Example

[source,cpp]
----
class ComplexTask {
  struct promise_type { /* ... */ };
  std::coroutine_handle<> handle;
public:
  Task(std::coroutine_handle<> handle) : handle(handle) { }
};

ComplexTask complexTask(Config data) {
  // At this point, a copy of `data` is created and stored as part of the coroutine state.
  co_return something();
}

void doSomeWork() {
  auto task = complexTask(buildConfig());
} // Noncompliant
// The coroutine handle was not released and the copy of `data` is leaked.
----

== Compliant Solution

[source,cpp]
----
class ComplexTask {
  struct promise_type { /* ... */ };
  std::coroutine_handle<> handle;
public:
  Task(std::coroutine_handle<> handle) : handle(handle) { }
  ~Task() { if (handle) handle.destroy(); }
};

ComplexTask complexTask(Config data) {
  // At this point, a copy of `data` is created and stored as part of the coroutine state.
  co_return something();
}

void doSomeWork() {
  auto task = complexTask(buildConfig());
}
// The copy of `data` is released via ~Task().
----
