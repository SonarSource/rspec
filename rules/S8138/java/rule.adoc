This rule raises an issue when code manually reads from a `Reader` using a buffer and accumulates the content, instead of using the simpler `readAllAsString()` or `readAllLines()` methods available in Java 25+.

== Why is this an issue?

Manual buffer-based reading from a `Reader` involves repetitive boilerplate code that can be simplified with Java 25's new methods.

Java 25 introduces two new convenience methods:

* `readAllAsString()` - reads all content as a single String
* `readAllLines()` - reads all content as a List of String lines

The traditional approach requires creating containers, allocating buffers, writing loops, and manual buffer management. This pattern is verbose and obscures the code's intent.

The new methods make the code more concise and the intent clearer.

=== What is the potential impact?

Using manual buffer reading instead of the new convenience methods leads to unnecessary code complexity and reduced maintainability. While functionally equivalent, the verbose approach makes the codebase harder to read and maintain, and increases the chance of implementation errors in buffer handling.

== How to fix it

Replace the manual buffer reading loop with a direct call to `readAllAsString()` when you need all content as a single string.

=== Code examples

==== Noncompliant code example

[source,java,diff-id=1,diff-type=noncompliant]
----
StringBuilder content = new StringBuilder();
char[] buffer = new char[4096];
int charsRead;
while ((charsRead = reader.read(buffer)) != -1) { // Noncompliant
    content.append(buffer, 0, charsRead);
}
return content.toString();
----

==== Compliant solution

[source,java,diff-id=1,diff-type=compliant]
----
return reader.readAllAsString();
----

== Resources

=== Documentation

 * Java 25 Reader API Documentation - https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/io/Reader.html#readAllAsString()[Official documentation for the readAllAsString() method]
