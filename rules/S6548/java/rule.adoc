The Singleton design pattern is a creational pattern. It ensures that only one instance of a class is created and provides a global point of access to it.
In Java, there are several ways to implement a Singleton, and the debate about the best approach has yet to be settled.

This rule marks all classes that are considered as Singletons, regardless of how they are implemented. This helps developers identifying where in the code Singletons are used. Singletons should be reviewed to confirm whether or not a Singleton is truly necessary and whether the selected implementation is the most suitable for the context.

Every Singleton implementation has its advantages and disadvantages. This rule exists to bring attention to them, so that informed decisions can be made.

// If you want to factorize the description uncomment the following line and create the file.
//include::../description.adoc[]

== Why is this an issue?

While the Singleton pattern can be useful in certain situations, overusing it can have several drawbacks:

* Tight coupling: The Singleton pattern can create tight coupling between the Singleton class and other classes that use it, which can make the code difficult to maintain and modify.
* Global state: The Singleton pattern can create global state, which can make it difficult to manage the state of the application and can lead to unexpected behavior.
* Testing: The Singleton pattern can make it difficult to test classes that depend on the Singleton, as the Singleton cannot be easily substituted with a mock object.
* Scalability: The Singleton pattern can make it difficult to scale an application, as it can create a bottleneck if multiple threads try to access the Singleton concurrently.
* Dependency injection: The Singleton pattern can make it difficult to use dependency injection frameworks, as the Singleton instance is usually created statically.

In general, the Singleton pattern should be used sparingly and only in situations where it provides a clear benefit over other patterns or approaches. It is important to consider the drawbacks and tradeoffs of using the Singleton pattern before incorporating it into an application.

//=== What is the potential impact?

//== How to fix it
== How to fix it in Eager Initialization
=== Code examples

==== Noncompliant code example

[source,java]
----
FIXME
----

==== Compliant solution

[source,java]
----
FIXME
----

== How to fix it in Static Block Initialization
=== Code examples

==== Noncompliant code example

[source,java]
----
FIXME
----

==== Compliant solution

[source,java]
----
FIXME
----

== How to fix it in Lazy Initialization
=== Code examples

==== Noncompliant code example

[source,java]
----
FIXME
----

==== Compliant solution

[source,java]
----
FIXME
----

== How to fix it in Thread Safe Singleton
=== Code examples

==== Noncompliant code example

[source,java]
----
FIXME
----

==== Compliant solution

[source,java]
----
FIXME
----

== How to fix it in Bill Pugh Singleton Implementation
=== Code examples

==== Noncompliant code example

[source,java]
----
FIXME
----

==== Compliant solution

[source,java]
----
FIXME
----

== How to fix it in Using Reflection to destroy Singleton Pattern
=== Code examples

==== Noncompliant code example

[source,java]
----
FIXME
----

==== Compliant solution

[source,java]
----
FIXME
----

== How to fix it in Enum Singleton
=== Code examples

==== Noncompliant code example

[source,java]
----
FIXME
----

==== Compliant solution

[source,java]
----
FIXME
----

== How to fix it in Serialization and Singleton
=== Code examples

==== Noncompliant code example

[source,java]
----
FIXME
----

==== Compliant solution

[source,java]
----
FIXME
----

//=== How does this work?

//=== Pitfalls

//=== Going the extra mile


//== Resources
//=== Documentation
//=== Articles & blog posts
//=== Conference presentations
//=== Standards
