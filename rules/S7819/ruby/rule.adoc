This rule raises an issue when code references local variables or methods that are undefined or inaccessible due to Ruby's scoping rules.

== Why is this an issue?

Ruby has strict scoping rules that determine where variables and methods can be accessed. Local variables are only accessible within the scope where they are defined, and method definitions create new scopes.

When code attempts to reference a local variable that doesn't exist in the current scope, Ruby will raise a `NameError` at runtime. This commonly happens in two scenarios:

*Local variables assigned in one method but referenced in another*: In Ruby, local variables are scoped to the method where they are defined. Assigning `current_user = user` inside a method creates a local variable that cannot be accessed from other methods.

*Local variables referenced across scope boundaries*: Method definitions create new scopes, so local variables defined outside a method are not accessible within that method. This is different from some other languages where inner scopes can access outer scope variables.

Ruby's method call syntax can make this confusing because method calls don't require parentheses. When Ruby encounters an undefined identifier, it first checks for local variables, then looks for method calls. If neither exists, it raises a `NameError`.

These scoping violations indicate a misunderstanding of Ruby's variable accessibility rules and often suggest that the code needs to be restructured to use appropriate mechanisms for sharing data between different parts of the program.

=== What is the potential impact?

This issue will cause `NameError` exceptions at runtime, leading to application crashes. The error may not be discovered until the specific code path is executed, potentially causing failures in production environments. This can result in poor user experience and system reliability issues.

== How to fix it

Use instance variables and proper getter/setter methods instead of local variables when you need to share state between methods.

=== Code examples

==== Noncompliant code example

[source,ruby,diff-id=1,diff-type=noncompliant]
----
class SessionsHelper
  def sign_in(user)
    current_user = user  # Local variable, not accessible elsewhere
  end
  
  def signed_in?
    !current_user.nil?  # Noncompliant: undefined local variable or method
  end
end
----

==== Compliant solution

[source,ruby,diff-id=1,diff-type=compliant]
----
class SessionsHelper
  def current_user
    @current_user ||= user_from_remember_token
  end
  
  def current_user=(user)
    @current_user = user
  end
  
  def signed_in?
    !current_user.nil?  # References properly defined method
  end
  
  private
  
  def user_from_remember_token
    # Implementation details
  end
end
----

== Resources

=== Documentation

 * Ruby Documentation - Variables and Constants - https://ruby-doc.org/core/doc/syntax/assignment_rdoc.html[Official Ruby documentation explaining variable scoping and assignment rules]

 * Ruby Style Guide - Variables - https://rubystyle.guide/#variables[Community style guide covering proper variable usage patterns in Ruby]
