A test case without assertions ensures only that no exceptions are thrown. Beyond basic runnability, it ensures nothing about the behavior of the code under test.

This rule raises an exception when no assertions from any of the following known frameworks are found in a test:

* AssertJ
* Awaitility
* EasyMock
* Eclipse Vert.x
* Fest 1.x and 2.x
* Hamcrest
* JMock
* JMockit
* JUnit
* Mockito
* Rest-assured 2.0
* RxJava 1.x and 2.x
* Selenide
* Spring's  <code>org.springframework.test.web.servlet.ResultActions.andExpect()</code>
* Truth Framework
* WireMock

Furthermore, as new or custom assertion frameworks may be used, the rule can be parametrized to define specific methods that will also be considered as assertions. No issue will be raised when such methods are found in test cases. The parameter value should have the following format <code><FullyQualifiedClassName>#<MethodName></code>, where <code>MethodName</code> can end with the wildcard character. For constructors, the pattern should be <code><FullyQualifiedClassName>#<init></code>.

Example:Â <code>com.company.CompareToTester#compare*,com.company.CustomAssert#customAssertMethod,com.company.CheckVerifier#<init></code>.

== Noncompliant Code Example

----
@Test 
public void testDoSomething() {  // Noncompliant
  MyClass myClass = new MyClass();
  myClass.doSomething();
}
----

== Compliant Solution

Example when <code>com.company.CompareToTester#compare*</code> is used as parameter to the rule.

----
import com.company.CompareToTester;

@Test 
public void testDoSomething() {
  MyClass myClass = new MyClass();
  assertNull(myClass.doSomething());  // JUnit assertion
  assertThat(myClass.doSomething()).isNull();  // Fest assertion
}

@Test 
public void testDoSomethingElse() {
  MyClass myClass = new MyClass();
  new CompareToTester().compareWith(myClass);  // Compliant - custom assertion method defined as rule parameter
  CompareToTester.compareStatic(myClass);  // Compliant
}
----
