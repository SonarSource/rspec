This rule raises an issue when global variables (prefixed with `$`) are used in Rails applications.

== Why is this an issue?

Global variables create tight coupling between different parts of your Rails application, making your code harder to maintain and test.

When you use global variables, you create hidden dependencies that are not obvious from looking at a class or method signature. This makes it difficult to understand what data a piece of code depends on, and it becomes nearly impossible to test components in isolation.

Global variables also introduce the risk of unexpected side effects. Since they can be modified from anywhere in your application, tracking down bugs becomes much more challenging. In a multi-threaded environment like Rails, global variables can also lead to race conditions.

Rails provides better alternatives for sharing data across your application. These alternatives are more explicit, easier to test, and follow Rails conventions.

=== What is the potential impact?

Using global variables can lead to:

* Code that is difficult to test and debug
* Tight coupling between unrelated parts of your application
* Unexpected side effects and hard-to-track bugs
* Race conditions in multi-threaded environments
* Violation of Rails conventions and best practices

== How to fix it in Rails

=== Code examples

Use Rails configuration objects for application-wide settings instead of global variables. This approach is thread-safe and follows Rails conventions.

==== Noncompliant code example

[source,ruby,diff-id=1,diff-type=noncompliant]
----
# Using global variable for application-wide values
$CUSTOMER_NAME = 'John' # Noncompliant

def some_method
  puts $CUSTOMER_NAME  # Creates tight coupling
end
----

==== Compliant solution

[source,ruby,diff-id=1,diff-type=compliant]
----
# config/application.rb - Using Rails configuration
MyApp::Application.configure do
  config.customer_name = 'John'
end

# Accessing the value
def some_method
  puts MyApp::Application.config.customer_name
end
----

Use session storage for user-specific data that needs to persist across requests instead of global variables.

==== Noncompliant code example

[source,ruby,diff-id=2,diff-type=noncompliant]
----
class UsersController < ApplicationController
  def user_clicked
    $current_user_id = params[:user_id] # Noncompliant
  end

  def view_user
    @current_user_id = $current_user_id
  end
end
----

==== Compliant solution

[source,ruby,diff-id=2,diff-type=compliant]
----
class UsersController < ApplicationController
  def user_clicked
    session[:current_user_id] = params[:user_id]
    redirect_to view_user_path
  end

  def view_user
    @current_user_id = session[:current_user_id]
  end
end
----

Use constants defined in initializers for application-wide constants instead of global variables.

==== Noncompliant code example

[source,ruby,diff-id=3,diff-type=noncompliant]
----
$API_VERSION = '1.0' # Noncompliant

class ApiController < ApplicationController
  def version
    render json: { version: $API_VERSION }
  end
end
----

==== Compliant solution

[source,ruby,diff-id=3,diff-type=compliant]
----
# config/initializers/api.rb
API_VERSION = '1.0'.freeze

class ApiController < ApplicationController
  def version
    render json: { version: API_VERSION }
  end
end
----

== Resources

=== Documentation

 * Rails Configuration Guide - https://guides.rubyonrails.org/configuring.html[Official Rails guide on application configuration]

 * Ruby user's guide - https://ruby-doc.org/docs/ruby-doc-bundle/UsersGuide/rg/globalvars.html[Global variables]

 * Rails Session Management - https://guides.rubyonrails.org/action_controller_overview.html#session[Rails guide on using sessions for data persistence]

=== Standards

 * CWE-1108: Excessive Reliance on Global Variables - https://cwe.mitre.org/data/definitions/1108.html[Common weakness related to overuse of global variables]
