<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>std::format</code> and <code>std::vformat</code> have the same runtime behavior for
well-formed format strings. The difference is exposed when there is
 an error in the format string. For instance, if it contains an
invalid format specifier:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>std::vformat</code> throws a <code>std::format_error</code> exception at runtime.</p>
</li>
<li>
<p><code>std::format</code> makes these mistakes ill-formed, causing the compilation to fail.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>std::format</code> should be used whenever possible, allowing to catch malformed format
strings early during the development process.</p>
</div>
<div class="paragraph">
<p>This rule raises an issue when <code>std::vformat</code> is used with a constant string
known at compile time.</p>
</div>
<div class="sect2">
<h3 id="_noncompliant_code_example">Noncompliant code example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">// Noncompliant, the string is known at compile time.
std::cout &lt;&lt; std::vformat("{:.1f}", std::make_format_args(5.2f)) &lt;&lt; std::endl;

// Noncompliant, the string is known at compile time.
constexpr std::string_view output_format = "{} {} {}";
std::cout &lt;&lt; std::vformat(output_format, std::make_format_args(42, 52, 62)) &lt;&lt; std::endl;

// Noncompliant
// The format specification does not match the type,
// throws `std::format_error` at run-time.
std::cout &lt;&lt; std::vformat("{:d}", std::make_format_args(5.6f)) &lt;&lt; std::endl;

// Noncompliant
// The number of formatted fields is greater than the number of arguments,
// throws `std::format_error` at run-time.
std::cout &lt;&lt; std::vformat("{} {}", std::make_format_args("A string")) &lt;&lt; std::endl;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_compliant_solution">Compliant solution</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">std::cout &lt;&lt; std::format("{:.1f}", 5.2f) &lt;&lt; std::endl;            // Compliant

constexpr std::string_view output_format = "{} {} {}";
std::cout &lt;&lt; std::format(output_format, 42, 52, 62) &lt;&lt; std::endl; // Compliant

// Compile-time error, the format specification does not match the type.
// std::cout &lt;&lt; std::format("{:d}", 5.6f) &lt;&lt; std::endl;

// Compile-time error, the number of formatted fields is greater than the number of arguments.
// std::cout &lt;&lt; std::format("{} {}", "A string") &lt;&lt; std::endl;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_exceptions">Exceptions</h3>
<div class="paragraph">
<p>This rule will not report the use of <code>std::vformat</code> when its arguments
are received by the enclosing function wrapped in a <code>std::format_args</code> object.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">void log_internal (std::format_args const&amp; args) {
  assert(args.get(3));
  std::cout &lt;&lt; std::vformat("{} {}[{}]: {}", args);
}</code></pre>
</div>
</div>
</div>
</div>
</div>