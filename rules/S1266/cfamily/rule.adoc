== Why is this an issue?

----
class Array
{
public:
  Array(int lowBound, int highBound);
  ...
private:
  size_t size_;       //  # of elements in array
  vector<int> data_;
  int lBound_;        //lower bound
  int hBound_;       //higher bound
};
Array<T>::Array(int lowBound, int highBound)
  :size_(highBound - lowBound + 1),
  data_(size_),
  lBound_(lowBound),
  hBound_(highBound)
{
  ...
}
----

Class members are always initialized in the order of their declaration in the class; the order in which they are listed in a member initialization list makes no difference.

In the classes generated by your Array template, size will always be initialized first, followed by data, lBound, and hBound.

Listing members in an initialization list in the order which they are declared allows to check that dependencies between class attributes are well managed. If in the example data was declared before size, the initialization list would have allowed to detect easily the problem i.e. that data is initialized using a non-initialized size ... supposing that this rule is respected. (Maintainability & Consistency)


ifdef::env-github,rspecator-view[]
'''
== Comments And Links
(visible only on this page)

=== duplicates: S3229

endif::env-github,rspecator-view[]
