== Why is this an issue?

The purpose of implementing the `java.util.concurrent.locks.Condition` interface is to gain access to its more nuanced `await` methods. From the Java API documentation:

____
`Condition` factors out the `Object` monitor methods (`wait`, `notify` and `notifyAll`) into distinct objects to give the effect of having multiple wait-sets per object, by combining them with the use of arbitrary Lock implementations. Where a `Lock` replaces the use of `synchronized` methods and statements, a `Condition` replaces the use of the `Object` monitor methods.

____

 Since the use of a `Condition` replaces the use of `Object` monitor methods, calling the method `Object.wait(...)` on a class implementing the `Condition` is contradictory and should be avoided.


== Code examples

=== Noncompliant code example

[source,java,diff-id=1,diff-type=noncompliant]
----
void doSomething(Condition condition) {
    condition.wait(); // Noncompliant, Object#wait is called

        ...
}
----


=== Compliant solution

[source,java,diff-id=1,diff-type=compliant]
----
void doSomething(Condition condition) {
    condition.await(); // Compliant, Condition#await is called

        ...
}
----

== References
* https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/Condition.html[Javadoc of `java.util.concurrent.locks.Condition`]

ifdef::env-github,rspecator-view[]

'''
== Implementation Specification
(visible only on this page)

=== Message

The "Condition.await(...)" method should be used instead of "Object.wait(...)"


endif::env-github,rspecator-view[]
