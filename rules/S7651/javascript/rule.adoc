This rule raises an issue when Angular output bindings (including aliases) are named using standard DOM event names like 'click', 'change', 'blur', etc.

== Why is this an issue?

Naming Angular output bindings with the same names as native DOM events creates confusion and potential conflicts in your application.

When you use native DOM event names for custom outputs, it becomes unclear whether you're dealing with a native browser event or a custom component event. This ambiguity makes the code harder to understand and maintain.

Additionally, this naming pattern can lead to unexpected behavior. Developers might accidentally bind to the wrong event or assume certain browser behaviors that don't apply to custom events. In some cases, it might even interfere with event propagation or cause conflicts with native event handling.

The confusion is particularly problematic when working in teams, as other developers might not immediately recognize whether an event is custom or native, leading to debugging difficulties and potential bugs.

=== What is the potential impact?

Using native DOM event names for custom outputs can lead to:

* Code confusion and reduced maintainability
* Debugging difficulties when distinguishing between native and custom events
* Potential conflicts with native event handling
* Unexpected application behavior
* Increased development time due to unclear event origins

=== How to fix in Angular?

Rename the output binding to use a descriptive, non-native name that clearly indicates its purpose.

==== Non-compliant code example

[source,typescript,diff-id=1,diff-type=noncompliant]
----
@Component()
class MyComponent {
  @Output() change = new EventEmitter<string>(); // Noncompliant
}
----

==== Compliant code example

[source,typescript,diff-id=1,diff-type=compliant]
----
@Component()
class MyComponent {
  @Output() valueChange = new EventEmitter<string>();
}
----

When using the new output() function, ensure both the property name and alias avoid native DOM event names.

==== Non-compliant code example

[source,typescript,diff-id=2,diff-type=noncompliant]
----
@Component()
class MyComponent {
  change = output<string>(); // Noncompliant
  
  // Also avoid native names in aliases
  customEvent = output<string>({ alias: 'click' }); // Noncompliant
}
----

==== Compliant code example

[source,typescript,diff-id=2,diff-type=compliant]
----
@Component()
class MyComponent {
  valueChange = output<string>();
  
  // Use descriptive aliases
  customEvent = output<string>({ alias: 'itemSelected' });
}
----

In component metadata, ensure output declarations use descriptive names instead of native DOM events.

==== Non-compliant code example

[source,typescript,diff-id=3,diff-type=noncompliant]
----
@Component({
  outputs: ['change', 'click: itemClick'] // Noncompliant
})
class MyComponent {}
----

==== Compliant code example

[source,typescript,diff-id=3,diff-type=compliant]
----
@Component({
  outputs: ['valueChange', 'itemSelected: itemClick']
})
class MyComponent {}
----

=== Documentation

 * Angular Event Binding Guide - https://angular.dev/guide/templates/event-listeners[Official Angular documentation on event binding and custom events]
 * Angular Component Interaction - https://angular.dev/guide/components/outputs[Guide on component outputs and event emitters]
 * MDN DOM Events Reference - https://developer.mozilla.org/en-US/docs/Web/Events[Complete list of standard DOM events to avoid in custom outputs]

