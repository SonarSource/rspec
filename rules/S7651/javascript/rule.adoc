This rule raises an issue when Angular output bindings (using `@Output()` decorator, `output()` function, or component metadata) are named after standard DOM events like 'click', 'change', 'blur', etc.

== Why is this an issue?

Angular components and directives can emit custom events through output bindings. When these output bindings use the same names as native DOM events, it creates confusion and potential conflicts.

Native DOM events have well-established behaviors that developers expect. For example, a 'click' event should fire when an element is clicked, or a 'change' event should fire when an input value changes. When a custom component uses these same event names for different purposes, it breaks these expectations.

This naming conflict can lead to several problems:

* **Developer confusion**: Other developers working with the component might expect native DOM behavior but encounter custom component logic instead
* **Debugging difficulties**: It becomes harder to distinguish between native events and custom events when troubleshooting
* **Maintenance issues**: The code becomes less self-documenting, making it harder to understand the component's actual behavior
* **Potential runtime conflicts**: In some cases, both native and custom events might fire, leading to unexpected behavior

Angular provides output bindings specifically for custom component communication. These should use descriptive, component-specific names that clearly indicate their purpose and origin.

=== What is the potential impact?

Using native DOM event names for custom output bindings can cause confusion for developers, make debugging more difficult, and potentially lead to unexpected behavior when both native and custom events are triggered. This reduces code maintainability and can introduce subtle bugs.

=== How to fix in Angular?

Rename the output binding to use a descriptive, component-specific name instead of a native DOM event name. Update the property name and any aliases to avoid conflicts with standard DOM events.

==== Non-compliant code example

[source,typescript,diff-id=1,diff-type=noncompliant]
----
@Component()
class MyComponent {
  @Output() change = new EventEmitter<string>(); // Noncompliant
}
----

==== Compliant code example

[source,typescript,diff-id=1,diff-type=compliant]
----
@Component()
class MyComponent {
  @Output() valueChange = new EventEmitter<string>();
}
----

When using the newer `output()` function, ensure the property name and any aliases don't conflict with native DOM events.

==== Non-compliant code example

[source,typescript,diff-id=2,diff-type=noncompliant]
----
@Component()
class MyComponent {
  click = output<MouseEvent>(); // Noncompliant
}
----

==== Compliant code example

[source,typescript,diff-id=2,diff-type=compliant]
----
@Component()
class MyComponent {
  buttonClick = output<MouseEvent>();
}
----

For outputs defined in component metadata, rename both the property and any aliases to avoid native DOM event names.

==== Non-compliant code example

[source,typescript,diff-id=3,diff-type=noncompliant]
----
@Component({
  outputs: ['blur'] // Noncompliant
})
class MyComponent {}
----

==== Compliant code example

[source,typescript,diff-id=3,diff-type=compliant]
----
@Component({
  outputs: ['focusLost']
})
class MyComponent {}
----

=== Documentation

 * Angular Output Decorator - https://angular.io/api/core/Output[Official Angular documentation for the @Output decorator]
 * Angular Event Binding - https://angular.io/guide/event-binding[Guide on how to handle events in Angular applications]
 * Angular Component Interaction - https://angular.io/guide/component-interaction[Documentation on component communication patterns in Angular]

=== Standards

 * DOM Events - MDN - https://developer.mozilla.org/en-US/docs/Web/Events[Complete list of standard DOM events that should be avoided for custom output names]

