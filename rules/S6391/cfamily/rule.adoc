Coroutines, introduced in C++20, are functions in which execution can be suspended and resumed.
When a coroutine resumes, it takes over where it left thanks to the coroutine state.

A _coroutine state_ is an object which contains all the information a coroutine needs to resume its execution correctly:
local variables, copy of the parameters...

This means that if a coroutine has a parameter that is a reference to an object, this object must exist as long as the coroutine is not destroyed.
Otherwise, the reference stored in the _coroutine state_ will become a dangling reference and will lead to undefined behavior when the coroutine resumes.

This rule flags all coroutine parameters with reference semantics, such a `const` reference, a `std::string_view`, or a `std::span` with `const` elements.

To fix the issue, you can either pass the parameter by value or use the `std::reference_wrappar` to make your intent explicit.

== Exceptions

This rule does not raise an issue for `std::reference_wrapper` parameters
taking it as a witness of the care taken to prevent the reference to become dangling.

== Noncompliant Code Example

----
generator<char> spell(const std::string& m) { // Noncompliant
    for (char letter : m) {
        co_yield letter;
    }
}

void print() {
    for (char letter : spell("hello world")) { // Here the parameter "m" binds to a temporary
        std::cout << letter << '\n';           // and becomes dangling on the next iteration
    }
}
----

== Compliant Solution

----
generator<char> spell(const std::string m) { // Compliant: take the argument by copy
    for (char letter : m) {
        co_yield letter;
    }
}

void print() {
    for (char letter : spell("hello world")) {
        std::cout << letter << '\n';
    }
}
----

== See

* S6163: an advanced version of this rule that detects bugs resulting from an access to such dangling references.
