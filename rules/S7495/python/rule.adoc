This rule raises an issue when `set()` or `dict()` is called with a list comprehension.

== Why is this an issue?

Python's comprehensions offer a powerful way to create lists, sets, and dictionaries. 
However, wrapping a list comprehension within a `set()` or `dict()` call introduces an unnecessary step: the creation of an intermediate list in memory. 
This intermediate list is then iterated over to construct the final set or dictionary. 
This approach can be less efficient in terms of both memory usage and execution speed, especially for large datasets. 
Direct set or dictionary comprehensions build the target collection without this intermediate step, leading to cleaner and more performant code.

== How to fix it

Replace the intermediate list comprehension by a direct `set` or `dict` comprehension.

=== Code examples

==== Noncompliant code example

[source,python,diff-id=1,diff-type=noncompliant]
----
foo = [1, 2, 2, 3]
def f(x):
    return x % 2

result = set([f(x) for x in foo]) # Noncompliant: set() around list comprehension

----

==== Compliant solution
[source,python,diff-id=1,diff-type=compliant]
----
foo = [1, 2, 2, 3]
def f(x):
    return x % 2

result = {f(x) for x in foo} # Compliant
----

== Resources

=== Documentation
* Python Documentation - https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions[List Comprehensions] 
* Python Documentation - https://docs.python.org/3/tutorial/datastructures.html#dictionaries[Dictionaries]
* Python Documentation - https://docs.python.org/3/tutorial/datastructures.html#sets[Sets]
