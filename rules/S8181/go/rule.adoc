This is an issue when test functions only check for the absence of errors without verifying that the expected behavior, state changes, or outcomes actually occurred.

== Why is this an issue?

Tests that only verify error absence provide insufficient coverage and create a false sense of security. Such tests may pass even when the code produces incorrect results, fails to achieve its intended effects, or doesn't properly modify system state.

When a test only checks that a function doesn't return an error, it misses critical scenarios where:

* Operations appear successful but produce wrong results
* Resources aren't actually created, updated, or deleted as expected
* State changes don't occur despite successful function execution
* Configuration settings aren't applied correctly

This problem often occurs when:

* Using `io.Discard` to ignore function output without validation
* Testing create/update/delete operations without verifying the actual state change
* Refactoring tests in ways that remove important assertions
* Writing cleanup functions that ignore deletion errors

Weak tests reduce confidence in code quality and may allow bugs to slip through that could have been caught with proper verification.

=== What is the potential impact?

Weak test coverage can lead to undetected bugs in production, reduced confidence in code changes, and increased risk of regressions. Critical functionality may fail silently while tests continue to pass, making issues harder to diagnose and fix.

== How to fix it

Add assertions to verify the expected behavior after operations complete successfully. Check that state changes occurred, resources were modified correctly, and outputs match expectations.

=== Code examples

==== Noncompliant code example

[source,go,diff-id=1,diff-type=noncompliant]
----
func TestUpdateUser(t *testing.T) {
    user := &User{Name: "John"}
    err := updateUser(user, "Jane")
    if err != nil {
        t.Errorf("updateUser failed: %v", err)
    }
    // Missing assertion to verify user.Name was actually updated // Noncompliant
}
----

==== Compliant solution

[source,go,diff-id=1,diff-type=compliant]
----
func TestUpdateUser(t *testing.T) {
    user := &User{Name: "John"}
    err := updateUser(user, "Jane")
    if err != nil {
        t.Errorf("updateUser failed: %v", err)
    }
    if user.Name != "Jane" {
        t.Errorf("expected user name to be 'Jane', got '%s'", user.Name)
    }
}
----

== Resources

=== Documentation

 * Go Testing Package - https://pkg.go.dev/testing[Official Go testing package documentation with best practices for writing effective tests]

 * Effective Go - Testing - https://go.dev/doc/effective_go#testing[Go's official guide on writing good tests and test practices]

 * Go Testing Best Practices - https://go.dev/doc/tutorial/add-a-test[Tutorial on adding tests to Go applications with proper assertion patterns]

=== Standards

 * CWE-754: Improper Check for Unusual or Exceptional Conditions - https://cwe.mitre.org/data/definitions/754.html[Relates to insufficient validation of expected conditions and outcomes]

=== Related rules

 * RSPEC-2699 - https://rules.sonarsource.com/javascript/RSPEC-2699/[Tests should include assertions (JavaScript implementation of similar concept)]
