This rule raises an issue when a class implements the Singleton pattern with a ``++getInstance()++`` method but has a public constructor that allows multiple instances to be created.

== Why is this an issue?

The Singleton design pattern ensures that only one instance of a class exists throughout the application's lifecycle. This pattern is useful when you need to coordinate actions across the system or manage shared resources like configuration settings or database connections.

When a Singleton class has a public constructor, it defeats the pattern's core purpose. Multiple instances can be created directly using the `new` keyword, bypassing the controlled instantiation mechanism. This leads to several problems:

* *Inconsistent state*: Different instances may hold different data, causing unpredictable behavior
* *Resource waste*: Multiple instances consume unnecessary memory and processing power
* *Broken assumptions*: Code expecting a single instance may malfunction when multiple instances exist
* *Difficult debugging*: Issues become harder to trace when multiple instances interact unexpectedly

A proper Singleton implementation uses a private constructor to prevent external instantiation and provides controlled access through a static method.

=== What is the potential impact?

Multiple instances of a Singleton class can cause data inconsistency, resource waste, and unpredictable application behavior. This can lead to difficult-to-debug issues and compromise the reliability of systems that depend on the Singleton's unique instance guarantee.

== How to fix it

Make the constructor private and implement proper instance control in the getInstance() method. This prevents external instantiation while ensuring only one instance exists.

=== Code examples

==== Noncompliant code example

[source,apex,diff-id=1,diff-type=noncompliant]
----
public class MySingleton {
    public MySingleton() { // Noncompliant
        // public constructor allows multiple instances
    }
    
    public static MySingleton getInstance() {
        return new MySingleton();
    }
}
----

==== Compliant solution

[source,apex,diff-id=1,diff-type=compliant]
----
public class MySingleton {
    private static MySingleton instance;
    
    private MySingleton() {
        // private constructor prevents external instantiation
    }
    
    public static MySingleton getInstance() {
        if (instance == null) {
            instance = new MySingleton();
        }
        return instance;
    }
}
----

== Resources

=== Documentation

 * Apex Design Patterns - Singleton Pattern - https://www.apexhours.com/apex-design-patterns[Comprehensive guide to implementing design patterns in Apex, including the Singleton pattern]

 * Singleton Design Pattern in Apex - https://www.apexhours.com/singleton-design-pattern-in-apex/[Detailed explanation of the Singleton pattern implementation in Salesforce Apex]

=== Related rules

 * S3050
