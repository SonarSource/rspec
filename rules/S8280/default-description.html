<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This rule raises an issue when executing processes in Groovy without implementing comprehensive lifecycle management, specifically when missing timeout handling, output stream consumption, or proper resource cleanup.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When executing external processes in Groovy, several critical issues can occur without proper lifecycle management:</p>
</div>
<div class="paragraph">
<p><strong>Hanging Applications</strong>: Using <code>waitFor()</code> without a timeout can cause your application to hang indefinitely if the external process becomes unresponsive or takes longer than expected. This is particularly problematic in production environments where reliability is crucial.</p>
</div>
<div class="paragraph">
<p><strong>Process Blocking</strong>: External processes write their output to buffers. If these buffers become full and are not consumed, the process will block and stop executing. This happens because the operating system prevents the process from writing more data until the existing output is read.</p>
</div>
<div class="paragraph">
<p><strong>Resource Leaks</strong>: Process objects maintain several streams (input, output, and error streams) that consume system resources. If these streams are not properly closed, they can accumulate over time, leading to resource exhaustion and potential system instability.</p>
</div>
<div class="paragraph">
<p>These issues compound each other - a blocked process that never completes will never have its resources cleaned up, creating a cascade of problems that can severely impact application performance and stability.</p>
</div>
<div class="sect2">
<h3 id="_what_is_the_potential_impact">What is the potential impact?</h3>
<div class="paragraph">
<p>Applications may hang indefinitely, consume excessive system resources, or fail unpredictably in production environments. Resource leaks can accumulate over time, leading to memory exhaustion and system instability.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_fix_it">How to fix it</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Implement comprehensive process lifecycle management by using waitForOrKill() with timeouts, consuming process output, and properly closing streams.</p>
</div>
<div class="sect2">
<h3 id="_code_examples">Code examples</h3>
<div class="sect3">
<h4 id="_noncompliant_code_example">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">def process = "long-running-command".execute()
process.waitFor() // Noncompliant: may hang indefinitely and block on full buffers
// streams not closed, potential resource leak</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">def process = "long-running-command".execute()
process.consumeProcessOutput() // prevent blocking
process.waitForOrKill(30000) // timeout after 30 seconds
process.closeStreams() // clean up resources</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_documentation">Documentation</h3>
<div class="ulist">
<ul>
<li>
<p>Groovy Process Documentation - <a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/lang/Process.html">Official Groovy documentation for Process class methods including waitForOrKill, consumeProcessOutput, and closeStreams</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>