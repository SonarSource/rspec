<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>emplace</code> enables you to avoid copying or moving the value you are about to insert and, instead, it constructs it in-place with the arguments provided.</p>
</div>
<div class="paragraph">
<p>Prefer using <code>emplace</code>, or <code>emplace_hint</code> if all the conditions hold:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>You are inserting a single value.</p>
</li>
<li>
<p>You are constructing a fresh temporary value just to insert it into the set.</p>
</li>
<li>
<p>You expect that the key is not in the set.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You should keep the <code>insert</code> in any of the cases below:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>You are inserting multiple values in one shot.</p>
</li>
<li>
<p>You are inserting a pre-existing value that is constructed for another purpose.</p>
</li>
<li>
<p>You are inserting an object that is cheap to move or to copy (e.g., an integer).</p>
</li>
<li>
<p>The key you are inserting is likely to be in the set (in this case by using <code>insert</code> you avoid creating a useless temporary node).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This rule detects calls to <code>insert</code> that lead to the creation of a large temporary object thatÂ can be avoided by using the <code>emplace</code> member function.</p>
</div>
<div class="sect2">
<h3 id="_noncompliant_code_example">Noncompliant code example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">struct A {
  int x;
  std::array&lt;std::string, 100&gt; more;// Expensive to copy or move
public:
  A(int x, const std::string&amp; more) : x(x), more({more}) {}
  bool operator&lt;(A const &amp;other) const {
    return x &lt; other.x;
  }
};
std::array&lt;std::string, 3&gt; strs = {"big brown fox", "little kitten", "regular human"};
void f() {
  std::set&lt;A&gt; set;
  for (int i = 0; i &lt; 1'000'000; ++i) {
    set.insert(A{i, strs[i%3]});// Noncompliant
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_compliant_solution">Compliant solution</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">struct A {
  int x;
  std::array&lt;std::string, 100&gt; more;// Expensive to copy or move
public:
  A(int x, const std::string&amp; more) : x(x), more({more}) {}
  bool operator&lt;(A const &amp;other) const {
    return x &lt; other.x;
  }
};
std::array&lt;std::string, 3&gt; strs = {"big brown fox", "little kitten", "regular human"};
void f() {
  std::set&lt;A&gt; set;
  for (int i = 0; i &lt; 1'000'000; ++i) {
    set.emplace(i, strs[i%3]);// Compliant
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_exceptions">Exceptions</h3>
<div class="paragraph">
<p>You should keep <code>insert</code> for exception safety if your key type is a smart pointer and the argument is a new expression.</p>
</div>
</div>
</div>
</div>