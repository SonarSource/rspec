This rule raises an issue when the expression used in an ``++except++`` block is a boolean expression of exceptions.

== Why is this an issue?

The only two possible types for an ``++except++``'s expression are a class deriving from ``++BaseException++``, or a tuple composed of such classes (or an old style class if you are using python 2, but this has been removed in python 3).

The result of a boolean expression of exceptions is a single exception class, thus using a boolean expression in an ``++except++`` block will result in catching only one kind of exception.

[source,python]
----
try:
    raise TypeError()
except ValueError or TypeError:  # Noncompliant
    print("Catching only ValueError")
except ValueError and TypeError:  # Noncompliant
    print("catching only TypeError")
except (ValueError or TypeError) as exception:  # Noncompliant
    print("Catching only ValueError")

foo = ValueError or TypeError  # foo == ValueError
foo = ValueError and TypeError  # foo == TypeError
----

Instead use a tuple of the exceptions that should be caught in the ``++except++`` block.

[source,python]
----
try:
    raise TypeError()
except (ValueError, TypeError) as exception:
    print("Catching ValueError and TypeError")
----

== Resources

=== Documentation

* https://docs.python.org/3/reference/compound_stmts.html#except[the ``++try++`` statement] - Python try statement

ifdef::env-github,rspecator-view[]

'''
== Implementation Specification
(visible only on this page)

=== Message

Rewrite this "except" expression as a tuple of exception classes


=== Highlighting

The "except"'s expression


endif::env-github,rspecator-view[]
