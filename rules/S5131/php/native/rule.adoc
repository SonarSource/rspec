include::../../summary.adoc[]

== Why is this an issue?

include::../../rationale.adoc[]

include::../../impact.adoc[]

include::../../threats.adoc[]

== How to fix it?

User input embedded in HTML code should be HTML-encoded to prevent the injection of additional code.
PHP provides the built-in function `htmlspecialchars` to do this.

[source,php]
----
echo '<h1>' . $input . '</h1>'; // Noncompliant
----

[source,php]
----
echo '<h1>' . htmlspecialchars($input) . '</h1>';
----

If you do not intend to send HTML code to the clients, the vulnerability can be resolved by telling them what data they are receiving using the content-type header.
For example, setting the content-type to `text/plain` using the built-in `header` function allows to safely reflect user input since browsers will not try to parse and execute the response.

[source,php]
----
echo $input; // Noncompliant
----

[source,php]
----
header('Content-Type: text/plain');
echo $input;
----

=== How does this work?

=== Pitfalls

include::../../common/pitfalls/content-types.adoc[]

==== Unquoted variables in attributes

If ``++$input++`` is untrusted, JavaScript code can be injected by adding event-handler attributes like ``++onload++``.

[source,php]
----
echo '<img src="image.jpg" alt=' . htmlspecialchars($input) . ' />';
----

Surround the attribute with double quotes to prevent arbitrary attributes from being added.

[source,php]
----
echo '<img src="image.jpg" alt="' . htmlspecialchars($input) . '" />';
----

==== Single quoted variables in attributes

By default, `htmlspecialchars` does not encode single quotes, so if ``++$input++`` is untrusted, JavaScript code can be injected.

[source,php]
----
echo "<img src='" . htmlspecialchars($input) . "'>";
----

Make sure to set the option `ENT_QUOTES` to encode single quotes.

[source,php]
----
echo "<img src='" . htmlspecialchars($input, ENT_QUOTES) . "'>";
----

==== Variables in script blocks

If ``++$name++`` is untrusted, JavaScript code can be injected even if the variable is HTML-encoded.

[source,html]
----
<!doctype html>
<script>var name = '<?= htmlspecialchars($name) ?>';</script>
----

You can insert the value in a data attribute outside of the script-block instead.

[source,html]
----
<!doctype html>
<script data-name="<?= htmlspecialchars($name) ?>">...</script>.
----

==== Headers and output

If the HTTP body is sent before `header` is called, no headers will be send to the client.

[source,php]
----
echo 'No more headers at this point';
header('Content-Type: text/plain');
echo $input;
----

To resolve the issue send the headers before any output.

[source,php]
----
header('Content-Type: text/plain');
echo $input;
----

=== Going the extra mile

== Resources

=== Documentation

include::../../common/resources/articles.adoc[]

include::../../common/resources/presentations.adoc[]

include::../../common/resources/standards.adoc[]

ifdef::env-github,rspecator-view[]

'''
== Implementation Specification
(visible only on this page)

include::../../message.adoc[]

include::../../highlighting.adoc[]

'''
== Comments And Links
(visible only on this page)

include::../../comments-and-links.adoc[]
endif::env-github,rspecator-view[]
