<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This vulnerability makes it possible to temporarily execute JavaScript code in the context of the application, granting access to the session of the victim. This is possible because user-provided data, such as URL parameters, are copied into the HTML body of the HTTP response that is sent back to the user.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Reflected cross-site scripting (XSS) occurs in a web application when the application retrieves data like parameters or headers from an incoming HTTP request and inserts it into its HTTP response without first sanitizing it. The most common cause is the insertion of GET parameters.</p>
</div>
<div class="paragraph">
<p>When well-intentioned users open a link to a page that is vulnerable to reflected XSS, they are exposed to attacks that target their own browser.</p>
</div>
<div class="paragraph">
<p>A user with malicious intent carefully crafts the link beforehand.</p>
</div>
<div class="paragraph">
<p>After creating this link, the attacker must use phishing techniques to ensure that his target users click on the link.</p>
</div>
<div class="sect2">
<h3 id="_what_is_the_potential_impact">What is the potential impact?</h3>
<div class="paragraph">
<p>A well-intentioned user opens a malicious link that injects data into the web
application. This data can be text, but it can also be arbitrary code that can
be interpreted by the target user&#8217;s browser, such as HTML, CSS, or JavaScript.</p>
</div>
<div class="paragraph">
<p>Below are some real-world scenarios that illustrate some impacts of an attacker
exploiting the vulnerability.</p>
</div>
<div class="sect3">
<h4 id="_vandalism_on_the_front_end_website">Vandalism on the front-end website</h4>
<div class="paragraph">
<p>The malicious link defaces the target web application from the perspective of
the user who is the victim. This may result in loss of integrity and theft of
the benevolent user&#8217;s data.</p>
</div>
</div>
<div class="sect3">
<h4 id="_identity_spoofing">Identity spoofing</h4>
<div class="paragraph">
<p>The forged link injects malicious code into the web application.
The code enables identity spoofing thanks to cookie theft.</p>
</div>
</div>
<div class="sect3">
<h4 id="_record_user_activity">Record user activity</h4>
<div class="paragraph">
<p>The forged link injects malicious code into the web application. To leak
confidential information, attackers can inject code that records keyboard
activity (keylogger) and even requests access to other devices, such as the
camera or microphone.</p>
</div>
</div>
<div class="sect3">
<h4 id="_chaining_xss_with_other_vulnerabilities">Chaining XSS with other vulnerabilities</h4>
<div class="paragraph">
<p>In many cases, bug hunters and attackers chain cross-site scripting
vulnerabilities with other vulnerabilities to maximize their impact.<br>
For example, an XSS can be used as the first step to exploit more dangerous
vulnerabilities or features that require higher privileges, such as a code
injection vulnerability in the admin control panel of a web application.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_fix_it_in_django">How to fix it in Django</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_code_examples">Code examples</h3>
<div class="paragraph">
<p>The following code is vulnerable to cross-site scripting because it returns an HTML response that contains user input.</p>
</div>
<div class="paragraph">
<p>If you do not intend to send HTML code to clients, the vulnerability can be fixed by specifying the type of data returned in the response.
For example, you can use the <code>JsonResponse</code> class to return JSON messages securely.</p>
</div>
<div class="sect3">
<h4 id="_noncompliant_code_example">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">from django.http import HttpResponse
import json

def index(request):
    json = json.dumps({ "data": request.GET.get("input") })
    return HttpResponse(json)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">from django.http import JsonResponse

def index(request):
    json = { "data": request.GET.get("input") }
    return JsonResponse(json)</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is also possible to set the content-type manually with the <code>content_type</code> parameter when creating an <code>HttpResponse</code> object.</p>
</div>
</div>
<div class="sect3">
<h4 id="_noncompliant_code_example_2">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">from django.http import HttpResponse

def index(request):
    return HttpResponse(request.GET.get("input"))</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution_2">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">from django.http import HttpResponse

def index(request):
    return HttpResponse(request.GET.get("input"), content_type="text/plain")</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_how_does_this_work">How does this work?</h3>
<div class="paragraph">
<p>If the HTTP response consists of HTML code, it is highly recommended to use a template engine like <a href="https://docs.djangoproject.com/en/4.0/topics/templates/">Django&#8217;s template system</a> to generate it.
The Django template engine separates the view from the business logic and automatically encodes the output of variables, drastically reducing the risk of cross-site scripting vulnerabilities.</p>
</div>
<div class="paragraph">
<p>If you do not intend to send HTML code to clients, the vulnerability can be fixed by telling them what data they are receiving with the <code>content-type</code> HTTP header.
This header tells the browser that the response does not contain HTML code and should not be parsed and interpreted as HTML.
Thus, the response is not vulnerable to reflected cross-site scripting.</p>
</div>
<div class="paragraph">
<p>For example, setting the Content-Type HTTP header to <code>text/plain</code> allows to safely reflect user input, because browsers will not try to parse and execute the response.</p>
</div>
</div>
<div class="sect2">
<h3 id="_pitfalls">Pitfalls</h3>
<div class="sect3">
<h4 id="_content_types">Content-types</h4>
<div class="paragraph">
<p>Be aware that there are more content-types than <code>text/html</code> that allow to execute JavaScript code in a browser and thus are prone to cross-site scripting vulnerabilities.<br>
The following content-types are known to be affected:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>application/mathml+xml</p>
</li>
<li>
<p>application/rdf+xml</p>
</li>
<li>
<p>application/vnd.wap.xhtml+xml</p>
</li>
<li>
<p>application/xhtml+xml</p>
</li>
<li>
<p>application/xml</p>
</li>
<li>
<p>image/svg+xml</p>
</li>
<li>
<p>multipart/x-mixed-replace</p>
</li>
<li>
<p>text/html</p>
</li>
<li>
<p>text/rdf</p>
</li>
<li>
<p>text/xml</p>
</li>
<li>
<p>text/xsl</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_the_limits_of_validation">The limits of validation</h4>
<div class="paragraph">
<p>Validation of user inputs is a good practice to protect against various injection attacks. But for XSS, validation on its own is not the recommended approach.</p>
</div>
<div class="paragraph">
<p>As an example, filtering out user inputs based on a deny-list will never fully prevent XSS vulnerability from being exploited. This practice is sometimes used by web application firewalls. It is only a matter of time for malicious users to find the exploitation payload that will defeat the filters.</p>
</div>
<div class="paragraph">
<p>Another example is applications that allow users or third-party services to send HTML content to be used by the application. A common approach is trying to parse HTML and strip sensitive HTML tags. Again, this deny-list approach is vulnerable by design: maintaining a list of sensitive HTML tags, in the long run, is very difficult.</p>
</div>
<div class="paragraph">
<p>A preferred option is to use Markdown in conjunction with a parser that removes embedded HTML and restricts the use of "javascript:" URI.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_going_the_extra_mile">Going the extra mile</h3>
<div class="sect3">
<h4 id="_content_security_policy_csp_header">Content Security Policy (CSP) Header</h4>
<div class="paragraph">
<p>With a defense-in-depth security approach, the <strong>CSP</strong> response header can be
added to instruct client browsers to <strong>block</strong> loading data that does not meet the
application&#8217;s security requirements. If configured correctly, this can prevent any attempt
to exploit XSS in the application.<br>
<a href="https://web.dev/csp-xss/">Learn more here.</a></p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_fix_it_in_django_templates">How to fix it in Django Templates</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_code_examples_2">Code examples</h3>
<div class="paragraph">
<p>The following code is vulnerable to cross-site scripting because auto-escaping of special HTML characters has been disabled. The recommended way to fix this code is to move the HTML content to the template and to only inject the dynamic value. Therefore, it is not necessary to disable auto-escaping.</p>
</div>
<div class="sect3">
<h4 id="_noncompliant_code_example_3">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">from django.shortcuts import render

def hello(request):
        name = request.GET.get("name")
        hello = f"&lt;h1&gt;Hello { name }&lt;/h1&gt;"
        return render(request, 'hello.html', {'hello': hello})</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;!doctype html&gt;
{% autoescape false %}
{{ hello }} &lt;!-- Noncompliant --&gt;
{% endautoescape %}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution_3">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">from django.shortcuts import render

def hello(request):
        name = request.GET.get("name")
        return render(request, 'hello.html', {'name': name})</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;!doctype html&gt;
&lt;h1&gt;Hello {{ name }}&lt;/h1&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_how_does_this_work_2">How does this work?</h3>
<div class="paragraph">
<p>Template engines are used by web applications to build HTML content. Template files contain both static HTML and template language instructions. These instructions allow, for example, to insert dynamic values in the document as the template is rendered. Template engines can auto-escape HTML special characters of dynamic values in order to prevent XSS vulnerabilities.</p>
</div>
<div class="paragraph">
<p>In Django applications, the engine&#8217;s auto-escaping feature is enabled by default. XSS vulnerabilities arise when an untrusted value is injected into the template and auto-escaping is disabled with <code>{% autoescape false %}</code> or <code>|safe</code>. This is often the case when a piece of dynamic HTML is generated from code and used in a template variable.</p>
</div>
<div class="sect3">
<h4 id="_encode_data_according_to_the_html_context">Encode data according to the HTML context</h4>
<div class="paragraph">
<p>The best approach to protect against XSS is to systematically encode data that is written to HTML documents.
The goal is to leave the data intact from the end user&#8217;s point of view but make it uninterpretable by web browsers.</p>
</div>
<div class="paragraph">
<p>XSS exploitation techniques vary depending on the HTML context where malicious input is injected. For each HTML context, there is a specific encoding to prevent JavaScript code from being interpreted.
The following table summarizes the encoding to apply for each HTML context.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Context</th>
<th class="tableblock halign-left valign-top">Code example</th>
<th class="tableblock halign-left valign-top">Exploit example</th>
<th class="tableblock halign-left valign-top">Encoding</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Inbetween tags</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;!doctype html&gt;
&lt;div&gt;
  { data }
&lt;/div&gt;</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;!doctype html&gt;
&lt;div&gt;
  &lt;script&gt;
    alert(1)
  &lt;/script&gt;
&lt;/div&gt;</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>HTML entity encoding: replace the following characters by HTML-safe sequences.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>&amp; &#8594; &amp;amp;</p>
</li>
<li>
<p>&lt; &#8594; &amp;lt;</p>
</li>
<li>
<p>&gt; &#8594; &amp;gt;</p>
</li>
<li>
<p>" &#8594; &amp;quot;</p>
</li>
<li>
<p>' &#8594; &amp;#x27;</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>In an attribute surrounded with single or double quotes</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;!doctype html&gt;
&lt;div tag="{ data }"&gt;
  ...
&lt;/div&gt;</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;!doctype html&gt;
&lt;div tag=""
     onmouseover="alert(1)"&gt;
  ...
&lt;/div&gt;</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>HTML entity encoding: replace the following characters with HTML-safe sequences.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>&amp; &#8594; &amp;amp;</p>
</li>
<li>
<p>&lt; &#8594; &amp;lt;</p>
</li>
<li>
<p>&gt; &#8594; &amp;gt;</p>
</li>
<li>
<p>" &#8594; &amp;quot;</p>
</li>
<li>
<p>' &#8594; &amp;#x27;</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>In an unquoted attribute</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;!doctype html&gt;
&lt;div tag={ data }&gt;
  ...
&lt;/div&gt;</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;!doctype html&gt;
&lt;div tag=foo
     onmouseover=alert(1)&gt;
  ...
&lt;/div&gt;</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong>Dangerous context</strong>: HTML output encoding will not prevent XSS fully.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>In a URL attribute</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;!doctype html&gt;
&lt;a href="{ data }"&gt;
  ...
&lt;/a&gt;</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;!doctype html&gt;
&lt;a href="javascript:alert(1)"&gt;
  ...
&lt;/a&gt;</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Validate the URL by parsing the data. Make sure relative URLs start with a  <code>/</code> and that absolute URLs use <code>https</code> as a scheme.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>In a script block</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;!doctype html&gt;
&lt;script&gt;
  { data }
&lt;/script&gt;</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;!doctype html&gt;
&lt;script&gt;
  alert(1)
&lt;/script&gt;</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong>Dangerous context</strong>: HTML output encoding will not prevent XSS fully.
To pass values to a JavaScript context, the recommended way is to use a data attribute:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;!doctype html&gt;
&lt;script data="{ data }"&gt;
  ...
&lt;/script&gt;</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Django template auto-escaping only takes care of HTML entity encoding. It does not protect from XSS when a variable is injected into an unquoted attribute or directly into a script block.</p>
</div>
<div class="paragraph">
<p>Auto-escaping can also be disabled at the application level and introduce XSS vulnerabilities even if <code>{% autoescape false %}</code> or <code>|safe</code> are not used.</p>
</div>
</div>
<div class="sect3">
<h4 id="_noncompliant_code_example_4">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python"># settings.py
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'OPTIONS': {
            'autoescape': False,
            ],
        },
    },
]</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution_4">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python"># settings.py
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'OPTIONS': {
            'autoescape': True,
            ],
        },
    },
]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_pitfalls_2">Pitfalls</h3>
<div class="sect3">
<h4 id="_variables_in_script_blocks">Variables in script blocks</h4>
<div class="paragraph">
<p>As mentioned in the section "How to fix it", injecting user-controlled values into a client-side JavaScript <code>script</code> is dangerous.
In such a case it is better to add the value to an attribute.</p>
</div>
<div class="paragraph">
<p>Another option is to use the <code>json_script</code> filter to insert a data structure that can then be accessed through the JavaScript code.</p>
</div>
<div class="sect4">
<h5 id="_noncompliant_code_example_5">Noncompliant code example</h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;!doctype html&gt;
&lt;script&gt; var name = '{{ name }}';&lt;/script&gt;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_compliant_solution_5">Compliant solution</h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;!doctype html&gt;
{{ name|json_script:"name-data" }}
&lt;script&gt; var name = JSON.parse(document.getElementById('name-data').textContent);&lt;/script&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_the_limits_of_validation_2">The limits of validation</h4>
<div class="paragraph">
<p>Validation of user inputs is a good practice to protect against various injection attacks. But for XSS, validation on its own is not the recommended approach.</p>
</div>
<div class="paragraph">
<p>As an example, filtering out user inputs based on a deny-list will never fully prevent XSS vulnerability from being exploited. This practice is sometimes used by web application firewalls. It is only a matter of time for malicious users to find the exploitation payload that will defeat the filters.</p>
</div>
<div class="paragraph">
<p>Another example is applications that allow users or third-party services to send HTML content to be used by the application. A common approach is trying to parse HTML and strip sensitive HTML tags. Again, this deny-list approach is vulnerable by design: maintaining a list of sensitive HTML tags, in the long run, is very difficult.</p>
</div>
<div class="paragraph">
<p>A preferred option is to use Markdown in conjunction with a parser that removes embedded HTML and restricts the use of "javascript:" URI.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_going_the_extra_mile_2">Going the extra mile</h3>
<div class="sect3">
<h4 id="_content_security_policy_csp_header_2">Content Security Policy (CSP) Header</h4>
<div class="paragraph">
<p>With a defense-in-depth security approach, the <strong>CSP</strong> response header can be
added to instruct client browsers to <strong>block</strong> loading data that does not meet the
application&#8217;s security requirements. If configured correctly, this can prevent any attempt
to exploit XSS in the application.<br>
<a href="https://web.dev/csp-xss/">Learn more here.</a></p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_fix_it_in_flask">How to fix it in Flask</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_code_examples_3">Code examples</h3>
<div class="paragraph">
<p>The following code is vulnerable to cross-site scripting because it returns an HTML response that contains user input.</p>
</div>
<div class="paragraph">
<p>If you do not intend to send HTML code to clients, the vulnerability can be fixed by specifying the type of data returned in the response.
For example, you can use the <code>jsonify</code> class to return JSON messages safely.</p>
</div>
<div class="sect3">
<h4 id="_noncompliant_code_example_6">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">from flask import make_response, request
import json

@app.route('/')
def index():
    json = json.dumps({ "data": request.args.get("input") })
    return make_response(json)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution_6">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">from flask import jsonify, request

@app.route('/')
def index():
    return jsonify({ "data": request.args.get("input") })</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is also possible to set the content-type manually with the <code>mimetype</code> parameter when calling the <code>make_response</code> function.</p>
</div>
</div>
<div class="sect3">
<h4 id="_noncompliant_code_example_7">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">from flask import make_response, request

@app.route('/')
def index():
    return make_response(request.args.get("input"))</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution_7">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">from flask import make_response, request

@app.route('/')
def index():
    response = make_response(request.args.get("input"))
    response.mimetype = "text/plain"
    return response</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_how_does_this_work_3">How does this work?</h3>
<div class="paragraph">
<p>If the HTTP response is HTML code, it is highly recommended to use a template engine like <a href="https://jinja.palletsprojects.com/">Jinja</a> to generate it.
This template engine separates the view from the business logic and automatically encodes the output of variables, drastically reducing the risk of cross-site scripting vulnerabilities.</p>
</div>
<div class="paragraph">
<p>If you do not intend to send HTML code to clients, the vulnerability can be fixed by specifying the type of data returned in the response with the <code>content-type</code> HTTP header.
This HTTP header tells the client browser that the response does not contain HTML code and should not be parsed and interpreted as HTML.
Thus, the response is not vulnerable to reflected cross-site scripting.</p>
</div>
<div class="paragraph">
<p>For example, setting the content-type header to <code>text/plain</code> allows to safely reflect user input because browsers will not try to parse and execute the response.</p>
</div>
</div>
<div class="sect2">
<h3 id="_pitfalls_3">Pitfalls</h3>
<div class="sect3">
<h4 id="_content_types_2">Content-types</h4>
<div class="paragraph">
<p>Be aware that there are more content-types than <code>text/html</code> that allow to execute JavaScript code in a browser and thus are prone to cross-site scripting vulnerabilities.<br>
The following content-types are known to be affected:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>application/mathml+xml</p>
</li>
<li>
<p>application/rdf+xml</p>
</li>
<li>
<p>application/vnd.wap.xhtml+xml</p>
</li>
<li>
<p>application/xhtml+xml</p>
</li>
<li>
<p>application/xml</p>
</li>
<li>
<p>image/svg+xml</p>
</li>
<li>
<p>multipart/x-mixed-replace</p>
</li>
<li>
<p>text/html</p>
</li>
<li>
<p>text/rdf</p>
</li>
<li>
<p>text/xml</p>
</li>
<li>
<p>text/xsl</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_the_limits_of_validation_3">The limits of validation</h4>
<div class="paragraph">
<p>Validation of user inputs is a good practice to protect against various injection attacks. But for XSS, validation on its own is not the recommended approach.</p>
</div>
<div class="paragraph">
<p>As an example, filtering out user inputs based on a deny-list will never fully prevent XSS vulnerability from being exploited. This practice is sometimes used by web application firewalls. It is only a matter of time for malicious users to find the exploitation payload that will defeat the filters.</p>
</div>
<div class="paragraph">
<p>Another example is applications that allow users or third-party services to send HTML content to be used by the application. A common approach is trying to parse HTML and strip sensitive HTML tags. Again, this deny-list approach is vulnerable by design: maintaining a list of sensitive HTML tags, in the long run, is very difficult.</p>
</div>
<div class="paragraph">
<p>A preferred option is to use Markdown in conjunction with a parser that removes embedded HTML and restricts the use of "javascript:" URI.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_going_the_extra_mile_3">Going the extra mile</h3>
<div class="sect3">
<h4 id="_content_security_policy_csp_header_3">Content Security Policy (CSP) Header</h4>
<div class="paragraph">
<p>With a defense-in-depth security approach, the <strong>CSP</strong> response header can be
added to instruct client browsers to <strong>block</strong> loading data that does not meet the
application&#8217;s security requirements. If configured correctly, this can prevent any attempt
to exploit XSS in the application.<br>
<a href="https://web.dev/csp-xss/">Learn more here.</a></p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_fix_it_in_jinja">How to fix it in Jinja</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_code_examples_4">Code examples</h3>
<div class="paragraph">
<p>The following code is vulnerable to cross-site scripting because auto-escaping of special HTML characters has been disabled.
The recommended way to fix this code is to move the HTML content to the template and to only inject the dynamic value. Therefore, it is not necessary to disable auto-escaping.</p>
</div>
<div class="sect3">
<h4 id="_noncompliant_code_example_8">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">from flask import render_template

@app.route('/hello/&lt;name&gt;')
def hello(name=None):
    hello = f"&lt;h1&gt;Hello { name }&lt;/h1&gt;"
    return render_template('hello.html', hello=hello)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;!doctype html&gt;
{% autoescape false %}
{{ hello }} &lt;!-- Noncompliant --&gt;
{% endautoescape %}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution_8">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">from flask import render_template

@app.route('/hello/&lt;name&gt;')
def hello(name=None):
    return render_template('hello.html', name=name)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;!doctype html&gt;
&lt;h1&gt;Hello {{ name }}&lt;/h1&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_how_does_this_work_4">How does this work?</h3>
<div class="paragraph">
<p>Template engines are used by web applications to build HTML content. Template files contain static HTML as well as template language instructions. These instructions allow, for example, to insert dynamic values (variables) in the document as the template is rendered.
Template engines can auto escape HTML special characters of variables in order to prevent XSS vulnerabilities.</p>
</div>
<div class="paragraph">
<p>In Flask applications, Jinja&#8217;s auto-escaping feature is enabled by default. XSS vulnerabilities arise when an untrusted value is injected into the template and auto-escaping is disabled with the <code>{% autoescape false %}</code> or <code>|safe</code> filters.
This is often the case when a piece of dynamic HTML is generated from Python code and used in a template variable.</p>
</div>
</div>
<div class="sect2">
<h3 id="_pitfalls_4">Pitfalls</h3>
<div class="sect3">
<h4 id="_variables_in_script_blocks_2">Variables in script blocks</h4>
<div class="paragraph">
<p>Although auto-escaping drastically decreases the chance of introducing cross-site scripting vulnerabilities, there are still specific cases where vulnerabilities can occur.
Injecting user-controlled values inside a <code>script</code> is dangerous. In such a case, the best practice is to add the value to an attribute.
Another option is to use the <code>tojson</code> filter to insert a data structure in the JavaScript code at render time.</p>
</div>
<div class="sect4">
<h5 id="_noncompliant_code_example_9">Noncompliant code example</h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;!doctype html&gt;
&lt;script&gt; var name = '{{ name }}';&lt;/script&gt;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_compliant_solution_9">Compliant solution</h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;!doctype html&gt;
&lt;script&gt; var name = {{ name | tojson }}&lt;/script&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_going_the_extra_mile_4">Going the extra mile</h3>
<div class="sect3">
<h4 id="_content_security_policy_csp_header_4">Content Security Policy (CSP) Header</h4>
<div class="paragraph">
<p>With a defense-in-depth security approach, the <strong>CSP</strong> response header can be
added to instruct client browsers to <strong>block</strong> loading data that does not meet the
application&#8217;s security requirements. If configured correctly, this can prevent any attempt
to exploit XSS in the application.<br>
<a href="https://web.dev/csp-xss/">Learn more here.</a></p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_fix_it_in_fastapi">How to fix it in FastAPI</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_code_examples_5">Code examples</h3>
<div class="paragraph">
<p>The following code is vulnerable to cross-site scripting because it returns an HTML response that contains user input.</p>
</div>
<div class="paragraph">
<p>If you do not intend to send HTML code to clients, the vulnerability can be fixed by specifying the type of data returned in the response.
For example, you can use the <code>JsonResponse</code> class to return JSON messages securely.</p>
</div>
<div class="paragraph">
<p>It is also possible to set the <code>Content-Type</code> manually by using the <code>media_type</code> parameter of the <code>Response</code> constructor.</p>
</div>
<div class="sect3">
<h4 id="_noncompliant_code_example_10">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">from fastapi import FastAPI, Response
import json

app = FastAPI()

@app.get("/example")
def example(input: str):
    json_str = json.dumps({"data": input})
    return Response(json_str)  # Noncompliant</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">from fastapi import FastAPI, Response

app = FastAPI()

@app.get("/example")
def example(input: str):
    return Response(input)  # Noncompliant</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution_10">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">from fastapi import FastAPI
from fastapi.responses import JSONResponse

app = FastAPI()

@app.get("/example")
def example(input: str):
    return JSONResponse({"data": input})</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">from fastapi import FastAPI, Response

app = FastAPI()

@app.get("/example")
def example(input: str):
    return Response(input, media_type="text/plain")</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_how_does_this_work_5">How does this work?</h3>
<div class="paragraph">
<p>If the HTTP response is HTML code, it is highly recommended to use a template engine like <a href="https://jinja.palletsprojects.com/">Jinja</a> to generate it.
This template engine separates the view from the business logic and automatically encodes the output of variables, drastically reducing the risk of cross-site scripting vulnerabilities.</p>
</div>
<div class="paragraph">
<p>If you do not intend to send HTML code to clients, the vulnerability can be fixed by correctly setting the <code>Content-Type</code> HTTP header.
This HTTP header defines which media type the browser can expect from the response, so the browser can parse it correctly. By specifying a type that is not HTML, the browser does not interpret the response as HTML, which in turn prevents cross-site scripting.</p>
</div>
<div class="paragraph">
<p>For example, when setting the <code>Content-Type</code> header to <code>text/plain</code>, browsers will interpret the HTTP response as plaintext and will not process it any further. This allows user input to be reflected safely.</p>
</div>
</div>
<div class="sect2">
<h3 id="_pitfalls_5">Pitfalls</h3>
<div class="sect3">
<h4 id="_content_types_3">Content-types</h4>
<div class="paragraph">
<p>Be aware that there are more content-types than <code>text/html</code> that allow to execute JavaScript code in a browser and thus are prone to cross-site scripting vulnerabilities.<br>
The following content-types are known to be affected:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>application/mathml+xml</p>
</li>
<li>
<p>application/rdf+xml</p>
</li>
<li>
<p>application/vnd.wap.xhtml+xml</p>
</li>
<li>
<p>application/xhtml+xml</p>
</li>
<li>
<p>application/xml</p>
</li>
<li>
<p>image/svg+xml</p>
</li>
<li>
<p>multipart/x-mixed-replace</p>
</li>
<li>
<p>text/html</p>
</li>
<li>
<p>text/rdf</p>
</li>
<li>
<p>text/xml</p>
</li>
<li>
<p>text/xsl</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_the_limits_of_validation_4">The limits of validation</h4>
<div class="paragraph">
<p>Validation of user inputs is a good practice to protect against various injection attacks. But for XSS, validation on its own is not the recommended approach.</p>
</div>
<div class="paragraph">
<p>As an example, filtering out user inputs based on a deny-list will never fully prevent XSS vulnerability from being exploited. This practice is sometimes used by web application firewalls. It is only a matter of time for malicious users to find the exploitation payload that will defeat the filters.</p>
</div>
<div class="paragraph">
<p>Another example is applications that allow users or third-party services to send HTML content to be used by the application. A common approach is trying to parse HTML and strip sensitive HTML tags. Again, this deny-list approach is vulnerable by design: maintaining a list of sensitive HTML tags, in the long run, is very difficult.</p>
</div>
<div class="paragraph">
<p>A preferred option is to use Markdown in conjunction with a parser that removes embedded HTML and restricts the use of "javascript:" URI.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_going_the_extra_mile_5">Going the extra mile</h3>
<div class="sect3">
<h4 id="_content_security_policy_csp_header_5">Content Security Policy (CSP) Header</h4>
<div class="paragraph">
<p>With a defense-in-depth security approach, the <strong>CSP</strong> response header can be
added to instruct client browsers to <strong>block</strong> loading data that does not meet the
application&#8217;s security requirements. If configured correctly, this can prevent any attempt
to exploit XSS in the application.<br>
<a href="https://web.dev/csp-xss/">Learn more here.</a></p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_documentation">Documentation</h3>
<div class="ulist">
<ul>
<li>
<p>OWASP - <a href="https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html">XSS Prevention Cheat Sheet</a></p>
</li>
<li>
<p><a href="https://docs.djangoproject.com/en/4.0/ref/request-response/">Django Project, Request and response objects (Django 4.0)</a></p>
</li>
<li>
<p><a href="https://docs.djangoproject.com/en/4.0/ref/templates/builtins">Django, Built-in template tags and filters</a></p>
</li>
<li>
<p><a href="https://flask.palletsprojects.com/en/stable/web-security/?highlight=xss#cross-site-scripting-xss">Flask, Security Considerations</a></p>
</li>
<li>
<p><a href="https://jinja.palletsprojects.com/en/stable/templates/">The Pallets Projects, Jinja, Template Designer Documentation</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_articles_blog_posts">Articles &amp; blog posts</h3>
<div class="ulist">
<ul>
<li>
<p>SonarSource - <a href="https://blog.sonarsource.com/wordpress-stored-xss-vulnerability">WordPress 5.8.2 Stored XSS Vulnerability</a></p>
</li>
<li>
<p>SonarSource - <a href="https://blog.sonarsource.com/ghost-admin-takeover">Ghost CMS 4.3.2 - Cross-Origin Admin Takeover</a></p>
</li>
<li>
<p>Samy Kamkar - <a href="https://samy.pl/myspace/">The MySpace Worm</a></p>
</li>
<li>
<p>James Kettle, PortSwigger - <a href="https://portswigger.net/research/web-storage-the-lesser-evil-for-session-tokens">Web Storage: The Lesser Evil for Session Tokens</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_conference_presentations">Conference presentations</h3>
<div class="ulist">
<ul>
<li>
<p><a href="https://www.youtube.com/watch?v=ksq7e6UUDag">DEF CON Safe Mode Red Team Village, Ray Doyle, Weaponized XSS Moving Beyond Alert</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_standards">Standards</h3>
<div class="ulist">
<ul>
<li>
<p>OWASP - <a href="https://owasp.org/Top10/A03_2021-Injection/">Top 10 2021 Category A3 - Injection</a></p>
</li>
<li>
<p>OWASP - <a href="https://owasp.org/www-project-top-ten/2017/A7_2017-Cross-Site_Scripting_(XSS)">Top 10 2017 Category A7 - Cross-Site Scripting (XSS)</a></p>
</li>
<li>
<p>CWE - <a href="https://cwe.mitre.org/data/definitions/79">CWE-79 - Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</a></p>
</li>
<li>
<p>STIG Viewer - <a href="https://stigviewer.com/stigs/application_security_and_development/2024-12-06/finding/V-222602">Application Security and Development: V-222602</a> - The application must protect from Cross-Site Scripting (XSS) vulnerabilities.</p>
</li>
<li>
<p>STIG Viewer - <a href="https://stigviewer.com/stigs/application_security_and_development/2024-12-06/finding/V-222609">Application Security and Development: V-222609</a> - The application must not be subject to input handling vulnerabilities.</p>
</li>
</ul>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_implementation_specification">Implementation Specification</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_message">Message</h3>
<div class="paragraph">
<p>Change this code to not reflect unsanitized user-controlled data.</p>
</div>
</div>
<div class="sect2">
<h3 id="_highlighting">Highlighting</h3>
<div class="paragraph">
<p>"[varname]" is tainted (assignments and parameters)</p>
</div>
<div class="paragraph">
<p>this argument is tainted (method invocations)</p>
</div>
<div class="paragraph">
<p>the returned value is tainted (returns &amp; method invocations results)</p>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_comments_and_links">Comments And Links</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_is_duplicated_by_s2576">is duplicated by: <a data-rspec-id="S2576" class="rspec-auto-link">S2576</a></h3>

</div>
</div>
</div>