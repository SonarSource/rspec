<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Introduced in C&#43;&#43;11, <code>static_assert</code> checks a precondition at compile-time and emits a diagnostic error message.</p>
</div>
<div class="paragraph">
<p>For any condition that could be checked at compile-time, <code>static_assert</code> should be preferred to the C macro <code>assert</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Because it is checked at compile-time, the maintainer changing the code is immediately warned when the condition breaks, as opposed to <code>assert</code> which will trigger only when the specific line is run, potentially by another person.</p>
</li>
<li>
<p>Because it is checked at compile-time, it is impossible to accidentally create a side-effect.</p>
</li>
<li>
<p>It cannot have a runtime performance cost.</p>
</li>
<li>
<p>Contrary to <code>assert</code>, it is not a macro and thus doesn&#8217;t have the same surprising behaviors like bad handling of commas or confusing error messages when it doesn&#8217;t compile.</p>
</li>
<li>
<p>It is designed to emit a customizable error message which will be useful to diagnose the error.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">template &lt;class T&gt;
void testFunction(T t) {
  assert(sizeof(long) &lt;= sizeof(long long) &amp;&amp; "long long is smaller than long!"); // Noncompliant
  assert(std::is_integral_v&lt;T&gt; &amp;&amp; "This template only works for integral types"); // Noncompliant
  assert(t &gt; 0); // Compliant: only known at runtime
  // ...
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">template &lt;class T&gt;
void testFunction(T t) {
  static_assert(sizeof(long) &lt;= sizeof(long long), "long long is smaller than long!");
  static_assert(std::is_integral_v&lt;T&gt;, "This template only works for integral types");
  assert(t &gt; 0); // Compliant: only known at runtime
  // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This rule doesn&#8217;t trigger for assertions that are false on purpose to stop the execution flow:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">[[noreturn]] void stop() {
  assert(false); // Compliant: Interrupting the runtime execution
  assert(!"We shouldn't reach this"); // Compliant: Interrupting the runtime execution
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_documentation">Documentation</h3>
<div class="ulist">
<ul>
<li>
<p>C&#43;&#43; reference - <a href="https://en.cppreference.com/w/cpp/language/static_assert"><code>static_assert</code> declaration</a></p>
</li>
<li>
<p>C&#43;&#43; reference - <a href="https://en.cppreference.com/w/cpp/error/assert"><code>assert</code></a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_external_coding_guidelines">External coding guidelines</h3>
<div class="ulist">
<ul>
<li>
<p>MISRA C&#43;&#43;:2023, 22.3.1 - The "assert" macro shall not be used with a constant-expression.</p>
</li>
<li>
<p>C&#43;&#43; Core Guidelines - <a href="https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#p5-prefer-compile-time-checking-to-run-time-checking">P.5: Prefer compile-time checking to run-time checking</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>