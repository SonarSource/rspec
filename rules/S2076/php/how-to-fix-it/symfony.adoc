=== How to fix it in .NET

include::../../common/fix/code-rationale.adoc[]

==== Non-compliant code example

[source,php,diff-id=1,diff-type=noncompliant]
----
public function unsafe(Request $request): JsonResponse
{
    $process = Process::fromShellCommandline($request->query->get("cmd"));
    $process->run();
    $code = $process->wait();
    return $this->json($code == 0);
}
----

==== Compliant solution

[source,php,diff-id=1,diff-type=compliant]
----
public function safe(Request $request): JsonResponse
{
    $DIAG_CMD = [["/bin/ping","-c","1","--"],["/usr/bin/host","--"]];
    $cmd = $DIAG_CMD[$request->query->get("cmdId")];
    $cmd[] = $request->query->get("host");

    $process = new Process($cmd);
    $process->run();
    $code = $process->wait();
    return $this->json($code == 0);
}
----

=== How does this work?

include::../../common/fix/introduction.adoc[]

include::../../common/fix/pre-approved-list.adoc[]

:sanitizationLib: Symfony\Component\Process\Process
include::../../common/fix/sanitize-meta-characters.adoc[]

Here, the compliant solution includes multiple layers of security.

First, a static list of allowed commands is used. Users are only allowed to
choose a command to run from the list of trusted ones. This prevents arbitrary
programs from being run.

Then, the `Process` constructor is used in place of the less safe
`fromShellCommandline` function. Directly using `Process` disables shell
integration for the command being run. This prevents any unexpected escaping
from the trusted static commands. Also, as the user-submitted parameter is
included as an element of the parameter array, the `Process` constructor will
perform an appropriate encoding of it. This will ensure no additional parameter
can be injected into the trusted static commands.

To finish, the trusted static commands include a `--` argument. This will
ensure the user-controlled parameter is not interpreted as a command option.
