This is an issue when using `bytes.Compare(a, b) == 0` or `bytes.Compare(a, b) != 0` to check if two byte slices are equal or not equal.

== Why is this an issue?

The `bytes.Compare` function is designed for ordering comparisons and returns -1, 0, or 1 to indicate the relative order of two byte slices. When you only need to check equality, `bytes.Compare` does unnecessary work.

The `bytes.Equal` function is specifically optimized for equality checks. It can return early as soon as it finds a difference, and it may use optimized assembly code for better performance on certain architectures.

Using `bytes.Compare` for equality checks makes your code slower and less clear about its intent. The performance difference can be significant, especially when comparing large byte slices or when the comparison is performed frequently.

=== What is the potential impact?

Using `bytes.Compare` instead of `bytes.Equal` for equality checks results in unnecessary performance overhead. The impact increases with the size of the byte slices being compared and the frequency of comparisons in your application.

== How to fix it

Replace `bytes.Compare(a, b) == 0` with `bytes.Equal(a, b)` for equality checks.

=== Code examples

==== Noncompliant code example

[source,go,diff-id=1,diff-type=noncompliant]
----
if bytes.Compare(data1, data2) == 0 { // Noncompliant
    fmt.Println("Equal")
}
----

==== Compliant solution

[source,go,diff-id=1,diff-type=compliant]
----
if bytes.Equal(data1, data2) {
    fmt.Println("Equal")
}
----

== Resources

=== Documentation

 * bytes.Equal documentation - https://pkg.go.dev/bytes#Equal[Official Go documentation for the bytes.Equal function]

 * bytes.Compare documentation - https://pkg.go.dev/bytes#Compare[Official Go documentation for the bytes.Compare function]

 * Go Blog: go fmt your code - https://go.dev/blog/gofmt#mechanical-source-transformation[Blog post discussing mechanical transformations including the bytes.Compare to bytes.Equal optimization]
