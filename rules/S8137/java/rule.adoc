This rule raises an issue when `Math.pow()` is cast to an integer type (`int` or `long`) and both arguments are integers.

== Why is this an issue?

When you need to calculate powers of integers, casting `Math.pow()` to an integer type causes problems.

`Math.pow()` returns a `double`, which means the calculation uses floating-point arithmetic. When you cast this result back to an integer, you get:

* **Silent overflow**: Results exceeding the integer type's maximum value wrap around without warning
* **Precision loss**: Floating-point arithmetic introduces rounding errors
* **Performance overhead**: Converting integers to doubles and back is less efficient than direct integer operations

`Math.powExact()` is more efficient and avoids precision loss by working directly with integers.

=== What is the potential impact?

Silent overflow or precision loss can lead to incorrect calculations in your application. This is particularly dangerous in financial calculations, cryptographic operations, or any domain where mathematical accuracy is essential. The bugs may go unnoticed during testing but cause problems in production with larger input values.

== How to fix it

Replace the cast of `Math.pow()` with `Math.powExact()`. This method is designed specifically for integer exponentiation and will throw an `ArithmeticException` if the result overflows, making errors explicit rather than silent.

=== Code examples

==== Noncompliant code example

[source,java,diff-id=1,diff-type=noncompliant]
----
public int calculatePower(int base, int exponent) {
    return (int) Math.pow(base, exponent); // Noncompliant
}
----

==== Compliant solution

[source,java,diff-id=1,diff-type=compliant]
----
public int calculatePower(int base, int exponent) {
    return Math.powExact(base, exponent);
}
----

== Resources

=== Documentation

 * Math.powExact() - Java Documentation - https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Math.html#powExact(int,int)[Official documentation for Math.powExact methods]
