<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Recursive methods must always reach a base case where the recursion is
stopped.
Infinite recursion is caused by logical errors and it will crash your
application.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Recursion is a technique to solve a computational problem by splitting it into
smaller problems.
A method is recursive, if it splits its input into smaller instances and calls
itself on these instances.
This continues until a smallest input, a <em>base case</em>, is reached that can not
be split further.
Similarly, recursion can also occur when multiple methods invoke each other.</p>
</div>
<div class="paragraph">
<p>Recursion is a useful tool, but it must be used carefully. Recursive methods need to detect base cases and end recursion with a <code>return</code> statement.
When this is not the case, recursion will continue until the stack overflows and the
program crashes due to a <code>StackOverflowError</code>.</p>
</div>
<div class="sect2">
<h3 id="_what_is_the_potential_impact">What is the potential impact?</h3>
<div class="paragraph">
<p>Issues of this type interrupt the normal execution of a program, causing it to
crash or putting it into an inconsistent state.
Therefore, this issue might impact the availability and reliability of your
application, or even result in data loss.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_fix_it">How to fix it</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To correctly implement recursion, you must ensure that the following conditions
are met:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>On every recursive call, the input to the call needs to become smaller,
meaning it needs to be brought closer to the base case.
For instance, if you are operating on a list, you can split it into smaller
segments.
If the input is numerical, you can ensure that you only make recursive calls
on numbers that are strictly smaller.</p>
</li>
<li>
<p>The recursive method must contain a <em>termination condition</em> that checks
whether the base case has been reached.
If so, it must not perform another recursive call.
For example, a base case can be that the input is an empty list.</p>
</li>
<li>
<p>You need to ensure that your process for splitting the input into smaller
instances will actually lead to the base case.</p>
</li>
</ol>
</div>
<div class="sect2">
<h3 id="_code_examples">Code examples</h3>
<div class="sect3">
<h4 id="_noncompliant_code_example">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int myPow(int num, int exponent) {
  num = num * myPow(num, exponent - 1); // Noncompliant: myPow unconditionally calls itself.
  return num;  // this is never reached
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int myPow(int num, int exponent) {
  if (exponent == 0) { // &lt;- termination condition
    return 1;
  }

  if (exponent &lt; 0) {
    throw new IllegalArgumentException("Negative exponents are not supported.");
  }

  num = num * myPow(num, exponent - 1);
  return num;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_how_does_this_work">How does this work?</h3>
<div class="paragraph">
<p>In the example, <code>myPow</code> computes the power of <code>num</code> to the given <code>exponent</code>.
The problem is solved recursively by computing the power of <code>num</code> to
<code>exponent - 1</code> first and then multiplying the result with <code>num</code>.</p>
</div>
<div class="paragraph">
<p>Thus, the problem is correctly reduced to a recursive call on a strictly smaller
input.
However, the noncompliant implementation lacks a base case.
I.e., the input <code>exponent</code> will eventually become negative, and the recursion
never stops.
This is solved by introducing the termination condition <code>exponent == 0</code>, which
stops the recursion.</p>
</div>
<div class="paragraph">
<p>Now, the recursion is finite for all valid, non-negative input values for
<code>exponent</code>.
However, it would still allow for infinite recursion on negative exponents.
Hence, for additional safety, we add a check that leads to an
<code>IllegalArgumentException</code>.
Throwing this exception also crashes the program, but for the right reasons:
It reports misuse of the method and provides useful debugging information to the
programmer.</p>
</div>
</div>
<div class="sect2">
<h3 id="_pitfalls">Pitfalls</h3>
<div class="paragraph">
<p>Even when implemented correctly, recursion can still lead to a
<code>StackOverflowError</code>.
Every recursive call consumes memory on the stack.
If the number of recursive calls is large enough, the available stack memory can
be exhausted, even for finite recursions.
Thus, for large input sizes, recursion should be avoided.</p>
</div>
</div>
<div class="sect2">
<h3 id="_going_the_extra_mile">Going the extra mile</h3>
<div class="paragraph">
<p>There are techniques for converting any recursive method into a loop-based,
iterative method.
This can be utilized when running into the pitfall of recursion on large inputs.</p>
</div>
<div class="paragraph">
<p>For instance, the following is an iterative version of the previous example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int myPow(int num, int exponent) {
  if (exponent &lt; 0) {
    throw new IllegalArgumentException("Negative exponents are not supported.");
  }

  int result = 1;
  while (exponent &gt; 0) {
    result *= num;
    --exponent;
  }

  return result;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As the conversion of recursive methods into iterative methods is a complex
topic, we refer to external articles on the topic.
See the section <em>Articles &amp; blog posts</em> under the tab <em>More Info</em>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_documentation">Documentation</h3>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/StackOverflowError.html">StackOverflowError</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_articles_blog_posts">Articles &amp; blog posts</h3>
<div class="ulist">
<ul>
<li>
<p><a href="https://www.baeldung.com/cs/convert-recursion-to-iteration">From Recursive to Iterative Functions</a> by Baeldung.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_standards">Standards</h3>
<div class="ulist">
<ul>
<li>
<p>The JVMS on <a href="https://docs.oracle.com/javase/specs/jvms/se17/html/jvms-2.html#jvms-2.5.2">Stacks</a></p>
</li>
</ul>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_implementation_specification">Implementation Specification</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_message">Message</h3>
<div class="paragraph">
<p>Add a way to break out of this [method&#8217;s recursion|method].</p>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_comments_and_links">Comments And Links</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_on_30_may_2023_161440_greg_paidis_wrote">on 30 May 2023, 16:14:40 Greg Paidis wrote:</h3>
<div class="paragraph">
<p>During a LaYC sprint, I removed abap, cobol, flex, javascript, php, rpg, vb6 and vbnet dummy implementations, since they are not implemented in the corresponding analyzers and there are no tickets open in order to do so.</p>
</div>
</div>
</div>
</div>