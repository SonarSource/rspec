<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Before records appeared in Java 16, there was a common way to represent getters for private fields of a class:  a method named "get" with a capitalized field name. For example, for a <code>String</code> field named "myField" the signature of the getter method will be: <code>public String getMyField()</code></p>
</div>
<div class="paragraph">
<p>In records, getters are named differently. Getters created by default do not contain the "get" prefix. So for a record&#8217;s <code>String</code> field "myField" the getter method will be: <code>public String myField()</code></p>
</div>
<div class="paragraph">
<p>This means that if you want to override the default getter behavior it is better to use the method provided by records instead of creating a new one. Otherwise, this will bring confusion to the users of the record as two getters will be available and even leads to bugs if the behavior is different from the default one.</p>
</div>
<div class="paragraph">
<p>This rule raises an issue when a record contains a getter named "get" with a capitalized field name that is not behaving the same as the default one.</p>
</div>
<div class="sect2">
<h3 id="_noncompliant_code_example">Noncompliant code example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">record Person(String name, int age) {
    public String getName() { // Noncompliant
        return name.toUpperCase(Locale.ROOT);
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_compliant_solution">Compliant solution</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">record Person(String name, int age) {
    @Override
    public String name() { // Compliant
        return name.toUpperCase(Locale.ROOT);
    }
}

record Person(String name, int age) {
    public String getNameUpperCase() { // Compliant
        return name.toUpperCase(Locale.ROOT);
    }
}
record Person(String name, int age) {
    public String getName() { // Compliant, is equivalent to 'name()'
        return name;
    }
}
record Person(String name, int age) {
    @Override
    public String name() { // Compliant
        return name.toUpperCase(Locale.ROOT);
    }
    public String getName() { // Compliant, equal to 'name()'
        return name.toUpperCase(Locale.ROOT);
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_exceptions">Exceptions</h3>
<div class="paragraph">
<p>If the implementations of <code>getMyField()</code> and <code>myField()</code> methods are equivalent, the issue should not be raised as this was probably done to support compatibility with the previous convention.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.oracle.com/javase/specs/jls/se16/html/jls-8.html#jls-8.10">Records specification</a></p>
</li>
</ul>
</div>
<hr>
</div>
</div>
<div class="sect1">
<h2 id="_implementation_specification">Implementation Specification</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_message">Message</h3>
<div class="paragraph">
<p>remove this getter 'getXxx()' from record and override an existing one 'xxx()'</p>
</div>
</div>
<div class="sect2">
<h3 id="_highlighting">Highlighting</h3>
<div class="paragraph">
<p>method declaration</p>
</div>
</div>
</div>
</div>