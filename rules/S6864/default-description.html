<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A memory limit is a configuration that sets the maximum amount of memory that a
container can use. It is part of the resource management functionality of
Kubernetes, which allows for the control and allocation of computational
resources to containers.</p>
</div>
<div class="paragraph">
<p>When a memory limit is set for a container, Kubernetes ensures that the
container does not exceed the specified limit. If a container tries to use more
memory than its limit, the system will reclaim the excess memory, which could
lead to termination of processes within the container.</p>
</div>
<div class="paragraph">
<p>Without a memory limit, a container can potentially consume all available memory
on a node, which can lead to unpredictable behavior of the container or the node
itself. Therefore, defining a memory limit for each container is a best practice
in Kubernetes configurations. It helps in managing resources effectively and
ensures that a single container does not monopolize the memory resources of a
node.</p>
</div>
<div class="sect2">
<h3 id="_what_is_the_potential_impact">What is the potential impact?</h3>
<div class="sect3">
<h4 id="_denial_of_service">Denial of Service</h4>
<div class="paragraph">
<p>Without a memory limit, a container can consume all available memory on a node.
This could lead to a Denial of Service (DoS) condition where other containers on
the same node are starved of memory. These containers may slow down, become
unresponsive, or even crash, affecting the overall functionality and
availability of applications running on them.</p>
</div>
</div>
<div class="sect3">
<h4 id="_inefficient_resource_allocation">Inefficient Resource Allocation</h4>
<div class="paragraph">
<p>When containers lack specified resource requests, the Kubernetes scheduler may
not make optimal decisions about pod placement and resource contention
management. This could result in the scheduler placing a resource-intensive pod
on a node with insufficient resources, leading to performance issues or even
node failure.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_fix_it">How to fix it</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_code_examples">Code examples</h3>
<div class="paragraph">
<p>To avoid potential issues, either specify a memory limit for each container in a pod specification or create a resource of a kind <code>LimitRange</code>, that sets a default memory limit for all containers in all pod specifications belonging to the same namespace.</p>
</div>
<div class="sect3">
<h4 id="_noncompliant_code_example">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">apiVersion: v1
kind: Pod
metadata:
  name: example
spec:
  containers:
    - name: web # Noncompliant
      image: nginx</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">apiVersion: v1
kind: Pod
metadata:
  name: example
spec:
  containers:
    - name: web # Noncompliant
      image: nginx</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">apiVersion: v1
kind: Pod
metadata:
  name: example
spec:
  containers:
    - name: web
      image: nginx
      resources:
        limits:
          memory: 100Mi</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">apiVersion: v1
kind: LimitRange
metadata:
  name: mem-limit-range
  namespace: default-mem-example
spec:
  limits:
    - type: Container
      default:
        memory: 100Mi
---
apiVersion: v1
kind: Pod
metadata:
  name: example
  namespace: default-mem-example
spec:
  containers:
    - name: web
      image: nginx</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_how_does_this_work">How does this work?</h3>
<div class="paragraph">
<p>A limit can be set through the property <code>resources.limits.memory</code> of a
container. Alternatively, a default limit for a namespace can be set with
<code>LimitRange</code> through <code>spec.limits[].default.memory</code>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_documentation">Documentation</h3>
<div class="ulist">
<ul>
<li>
<p>Kubernetes Documentation - <a href="https://kubernetes.io/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/">Configure Default Memory Requests and Limits for a Namespace</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_standards">Standards</h3>
<div class="ulist">
<ul>
<li>
<p>CWE - <a href="https://cwe.mitre.org/data/definitions/770">CWE-770 - Allocation of Resources Without Limits or Throttling</a></p>
</li>
</ul>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_implementation_specification">Implementation Specification</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_message">Message</h3>
<div class="paragraph">
<p>Specify a memory limit for this container.</p>
</div>
</div>
<div class="sect2">
<h3 id="_highlighting">Highlighting</h3>
<div class="ulist">
<ul>
<li>
<p>Highlight the key of the first child of the container that does not specify a memory limit.</p>
</li>
</ul>
</div>
</div>
</div>
</div>