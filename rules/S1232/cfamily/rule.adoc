Use the matching way of deallocating the objects to the one used to allocate them to avoid segmentation faults and memory leaks.

== Why is this an issue?

The same form that was used to create an object should always be used to delete it.
Specifically, deallocation should correspond to allocation as per the table below.

.Matching allocation and deallocation ways
[options="header"]
|============================================
|Allocation                   | Deallocation
|`p = new T();`               | `delete p;`
|`+p = new T[5];+`            | `+delete[] p;+`
|`p = malloc(sizeof(int)*5);` | `free(p);`
|============================================

Specifically, arrays should be deleted with `+delete []+` and objects should be deleted with `delete`.

This is also true for the memory allocated with `+malloc+` or one of its variants.
It must be released using `free()` and not `delete`.
Similarly, the memory allocated with `new` cannot be released using `free()` instead of `delete`.

=== What is the potential impact?

Using a mismatching deallocation construct leads to undefined behavior.
This means the compiler is not bound by the language standard anymore and your program has no meaning assigned to it.

Practically, you can observe the following effects:

- Deleting a single object with `+delete[]+` leads to a segmentation fault
  trying to access memory-manager metadata that is not there.
- Deleting an array with `delete` leads to a memory leak because it will
  delete and deallocate only the first element of the array.
- Freeing with `free()` the underlying memory for an object constructed with `new`
  will skip the destructor call, most likely leading to a memory leak.
  Additionally, a destructor might still be called on freed memory causing further undefined behavior.
- Deleting with `delete` an memory block allocated with `operator new`
  will lead to a destructor invocation on an "object" that was never constructed
  so the destructor might hit an unsatisfied assumption.

=== Why does the rule apply to `::operator new(std::size_t count)`?

TODO:

== How to fix it

Use the deallocation mechanism that matches the allocation.

=== Code examples

==== Noncompliant code example

[source,cpp,diff-id=1,diff-type=noncompliant]
----
std::string* _pString1 = new std::string;
std::string* _pString2 = new std::string[100];
char* _pChar = (char *) malloc(100);

delete [] _pString1; // Noncompliant: an object was declared, but array deletion is attempted
delete _pString2;  // Noncompliant: an array was declared, but an object (the first in the array) is deleted
delete _pChar; // Noncompliant
----


==== Compliant solution

[source,cpp,diff-id=1,diff-type=compliant]
----
std::string* _pString1 = new std::string;
std::string* _pString2 = new std::string[100];
char* _pChar = (char *) malloc(100);

delete _pString1; // Compliant: delete the object
delete [] _pString2; // Compliant: delete the entire array
free(_pChar); // Compliant: free the memory C-style
----

=== Going the extra mile

Manually allocating and deallocating memory is a code smell
because of the issue covered by this rule, and because it is easy to leak memory.

Whenever possible, prefer the RAII (resource acquisition is allocation) {cpp} idiom.

If, in the example above, you use the appropriate standard objects,
you do not need to remember how and when to deallocate them:

[source,cpp]
----
std::string _pString1a; // A local variable often is enough

// Use a smart pointer when you do need heap allocation
auto _pString1b = std::make_unique<std::string>();

std::vector<std::string> _pString2(100);
std::string _pChar{100, '\0'};

// No need to call "delete" or "free".
// Memory allocated for the three objects above will be freed automatically
// when they go out of scope.
----

== Resources

=== Standards

* CERT - https://wiki.sei.cmu.edu/confluence/x/Gns-BQ[MEM51-CPP. Properly deallocate dynamically allocated resources]

=== Related rules

* S5025 recommends avoiding manual memory management


ifdef::env-github,rspecator-view[]

'''
== Implementation Specification
(visible only on this page)

=== Message

Use "[delete|delete []]|free()" here instead.


'''
== Comments And Links
(visible only on this page)

=== is duplicated by: S3530

endif::env-github,rspecator-view[]
