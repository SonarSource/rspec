Use the matching way of deallocating the objects to the one used to allocate them to avoid segmentation faults and memory leaks.

== Why is this an issue?

The same form that was used to create an object should always be used to delete it.
Specifically, deallocation should correspond to allocation as per the table below.

.Matching allocation and deallocation ways
[options="header"]
|============================================
|Allocation                   | Deallocation
|`p = new T();`               | `delete p;`
|`+p = new T[5];+`            | `+delete[] p;+`
|`p = malloc(sizeof(int)*5);` | `free(p);`
|============================================

=== What is the potential impact?

Using a mismatching deallocation construct leads to undefined behavior.
This means the compiler is not bound by the language standard anymore and your program has no meaning assigned to it.

Practically, you can observe the following effects:

- Deleting a single object with `+delete[]+` leads to a segmentation fault
  trying to access memory-manager metadata that is not there.
- Deleting an array with `delete` leads to a memory leak because it will
  delete and deallocate only the first element of the array.
- Freeing with `free()` the underlying memory for an object constructed with `new`
  will skip the destructor call, most likely leading to a memory leak.
  Additionally, a destructor might still be called on freed memory causing further undefined behavior.

=== Why is the issue raised for a type with a trivial destructor?

TODO:

----
struct TrivialClass {};


TrivialClass* p = new TrivialClass();
free(p); // no destructor is called.
----


----
int* p = malloc(10 * sizeof(int));
delete[] p; // expect array coookie
----


TODO `::operator new(std::size_t count)`

----
::operator new(10 * sizeof(int));
free()
----

== How to fix it

Use the deallocation mechanism that matches the allocation.

=== Code examples

==== Noncompliant code example

[source,cpp,diff-id=1,diff-type=noncompliant]
----
std::string* _pString1 = new std::string;
std::string* _pString2 = new std::string[100];
char* _pChar = (char *) malloc(100);

delete [] _pString1; // Noncompliant: an object was declared, but array deletion is attempted
delete _pString2;  // Noncompliant: an array was declared, but an object (the first in the array) is deleted
delete _pChar; // Noncompliant
----


==== Compliant solution

[source,cpp,diff-id=1,diff-type=compliant]
----
std::string* _pString1 = new std::string;
std::string* _pString2 = new std::string[100];
char* _pChar = (char *) malloc(100);

delete _pString1; // Compliant: delete the object
delete [] _pString2; // Compliant: delete the entire array
free(_pChar); // Compliant: free the memory C-style
----

=== Going the extra mile

Manually allocating and deallocating memory is a code smell
because of the issue covered by this rule, and because it is easy to leak memory.

Whenever possible, prefer the RAII (Resource Acquisition Is Initialization) {cpp} idiom.

If, in the example above, you use the appropriate standard objects,
you do not need to remember how and when to deallocate them:

[source,cpp]
----
std::string _pString1a; // A local variable often is enough

// Use a smart pointer when you do need heap allocation
auto _pString1b = std::make_unique<std::string>();

std::vector<std::string> _pString2(100);
std::string _pChar{100, '\0'};

// No need to call "delete" or "free".
// Memory allocated for the three objects above will be freed automatically
// when they go out of scope.
----

== Resources

=== Standards

* CERT - https://wiki.sei.cmu.edu/confluence/x/Gns-BQ[MEM51-CPP. Properly deallocate dynamically allocated resources]

=== Related rules

* S5025 recommends avoiding manual memory management

=== Documentation

* {cpp} Reference - https://en.cppreference.com/w/cpp/language/raii[RAII (Resource Acquisition Is Initialization)]

ifdef::env-github,rspecator-view[]

'''
== Implementation Specification
(visible only on this page)

=== Message

Use "[delete|delete []]|free()" here instead.


'''
== Comments And Links
(visible only on this page)

=== is duplicated by: S3530

endif::env-github,rspecator-view[]
