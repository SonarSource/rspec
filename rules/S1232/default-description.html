<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Use the matching way of deallocating the objects to the one used to allocate them to avoid segmentation faults and memory leaks.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The same form that was used to create an object should always be used to delete it.
Specifically, deallocation should correspond to allocation as per the table below.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. Matching allocation and deallocation ways</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Allocation</th>
<th class="tableblock halign-left valign-top">Deallocation</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>p = new T();</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>delete p;</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>p = new T[5];</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>delete[] p;</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>p = malloc(sizeof(int)*5);</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>free(p);</code></p></td>
</tr>
</tbody>
</table>
<div class="sect2">
<h3 id="_what_is_the_potential_impact">What is the potential impact?</h3>
<div class="paragraph">
<p>Using a mismatching deallocation construct leads to undefined behavior.
This means the compiler is not bound by the language standard anymore and your program has no meaning assigned to it.</p>
</div>
<div class="paragraph">
<p>Practically, you can observe the following effects:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Deleting a single object with <code>delete[]</code> leads to a segmentation fault
trying to access memory-manager metadata that is not there.</p>
</li>
<li>
<p>Deleting an array with <code>delete</code> leads to a memory leak because it will
delete and deallocate only the first element of the array.</p>
</li>
<li>
<p>Freeing with <code>free()</code> the underlying memory for an object constructed with <code>new</code>
will skip the destructor call, most likely leading to a memory leak.
Additionally, a destructor might still be called on deallocated memory causing further undefined behavior.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_why_is_the_issue_raised_for_a_type_with_a_trivial_destructor">Why is the issue raised for a type with a trivial destructor?</h3>
<div class="paragraph">
<p>Automatic constructor and destructor invocation is not the only difference between
the C-style <code>malloc</code>/<code>free</code> memory allocator, and the C&#43;&#43;-style <code>new</code>/<code>delete</code>.</p>
</div>
<div class="paragraph">
<p>These two memory allocators use different metadata and different algorithms.
For example, <code>new</code> has an array form <code>new[]</code> that stores an "array cookie".</p>
</div>
<div class="paragraph">
<p>The following example causes undefined behavior,
even though the destructor has now effect,
because <code>free()</code> expects different metadata for the pointer it is passed
than what is arranged by the <code>new</code> operator:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">struct TrivialClass {};


TrivialClass* p = new TrivialClass();
free(p); // Noncompliant: no-op destructor is skipped; still undefined behavior</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the code below, <code>delete[]</code> expects to find an array cookie and fails:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">int* p = malloc(10 * sizeof(int));
delete[] p; // Noncompliant: expect array cookie</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you need allocate memory in a custom <code>T::operator new(std::size_t)</code>,
you should use <code>void* ::operator new(std::size_t)</code> and not <code>free()</code>.</p>
</div>
<div class="paragraph">
<p>Note that <code>::operator new</code> is still not compatible with <code>free()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">auto p = ::operator new(10 * sizeof(int));
free(p); // Noncompliant</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_fix_it">How to fix it</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Use the deallocation mechanism that matches the allocation.</p>
</div>
<div class="sect2">
<h3 id="_code_examples">Code examples</h3>
<div class="sect3">
<h4 id="_noncompliant_code_example">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">std::string* _pString1 = new std::string;
std::string* _pString2 = new std::string[100];
char* _pChar = (char *) malloc(100);

delete [] _pString1; // Noncompliant: an object was declared, but array deletion is attempted
delete _pString2;  // Noncompliant: an array was declared, but an object (the first in the array) is deleted
delete _pChar; // Noncompliant</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">std::string* _pString1 = new std::string;
std::string* _pString2 = new std::string[100];
char* _pChar = (char *) malloc(100);

delete _pString1; // Compliant: delete the object
delete [] _pString2; // Compliant: delete the entire array
free(_pChar); // Compliant: free the memory C-style</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_going_the_extra_mile">Going the extra mile</h3>
<div class="paragraph">
<p>In C&#43;&#43;, manually allocating and deallocating memory is considered a code smell.</p>
</div>
<div class="paragraph">
<p>It is recommended to follow the <em>RAII</em> idiom and create a class that manages the memory by allocating it when the object is constructed and freeing it when it is destroyed.
Furthermore, copy and move operations on such objects are designed such that this object can be passed by value between functions (either as an argument or by being returned)
in place of raw pointers.</p>
</div>
<div class="paragraph">
<p>Depending on the type, passing an <em>RAII</em> object operations may either:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Allocate a new block of memory and copy the elements (<code>std::vector</code>).</p>
</li>
<li>
<p>Transfer ownership of the memory to constructed object (<code>std::unique_ptr</code>).</p>
</li>
<li>
<p>Use shared ownership and free memory when the last object is destroyed (<code>std::shared_ptr</code>).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This guarantees that the memory managed by such object is automatically deallocated by the destructor,
using the matching form of deallocation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">std::string _pString1a; // A local variable, that manages heap memory

// Use a smart pointer when you do need heap allocation
auto _pString1b = std::make_unique&lt;std::string&gt;();

std::vector&lt;std::string&gt; _pString2(100);
std::string _pChar{100, '\0'};

// No need to call "delete" or "free".
// Memory allocated for the three objects above will be freed automatically
// when they go out of scope.</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_standards">Standards</h3>
<div class="ulist">
<ul>
<li>
<p>CERT - <a href="https://wiki.sei.cmu.edu/confluence/x/Gns-BQ">MEM51-CPP. Properly deallocate dynamically allocated resources</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_related_rules">Related rules</h3>
<div class="ulist">
<ul>
<li>
<p><a data-rspec-id="S5025" class="rspec-auto-link">S5025</a> recommends avoiding manual memory management</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_documentation">Documentation</h3>
<div class="ulist">
<ul>
<li>
<p>C&#43;&#43; reference - <a href="https://en.cppreference.com/w/cpp/language/raii">RAII (Resource Acquisition Is Initialization)</a></p>
</li>
</ul>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_implementation_specification">Implementation Specification</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_message">Message</h3>
<div class="paragraph">
<p>Use "[delete|delete []]|free()" here instead.</p>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_comments_and_links">Comments And Links</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_is_duplicated_by_s3530">is duplicated by: <a data-rspec-id="S3530" class="rspec-auto-link">S3530</a></h3>

</div>
</div>
</div>