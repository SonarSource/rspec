This rule raises an issue when a collection is created with use of `map()` with a `lambda` function instead of a generator.

== Why is this an issue?

The `map()` function applies a given function to each item of an iterable. 
When this function is a `lambda`, especially a simple one, the resulting code can sometimes be less readable than its comprehension or generator expression equivalent. 
Comprehensions and generator expressions are often considered more "Pythonic" for such transformations as they integrate the loop and the operation more closely.

There are several reasons why comprehensions or generator expressions might be preferred over `map(lambda ...)`:

* *Readability:* A comprehension like `[x * 2 for x in nums]` is more straightforward to read and understand at a glance than `list(map(lambda x: x * 2, nums))`. The logic is more self-contained and doesn't require mentally parsing the `map` and `lambda` separately.
* *Flexibility:* Comprehensions can include filtering conditions (e.g., `[x for x in nums if x > 0]`) more directly than `map()`, which would require a separate `filter()` call or embedding the condition within the `lambda`.
* *Performance:* While `map()` can be very efficient when used with built-in functions or pre-defined functions written in C, the use of a Python `lambda` introduces function call overhead for each element in the iterable. For simple operations, a comprehension or generator expression can sometimes be faster as it may avoid this overhead or allow for more optimizations by the interpreter.

The main concern is when `map()` is combined with a `lambda` function for transformations that are easily expressible with:
* Generator expressions: `(expression for item in iterable)`
* List comprehensions: `[expression for item in iterable]`
* Set comprehensions: `{expression for item in iterable}`
* Dictionary comprehensions: `{key_expr: value_expr for item in iterable}`

== How to fix it

To fix this issue replace the `map(lambda ...)` construct with an equivalent generator expression or a list, set, or dictionary comprehension.

* Replace `map(lambda var: expression, iterable)` with a generator expression `(expression for var in iterable)`.
* Replace `list(map(lambda var: expression, iterable))` with a list comprehension `[expression for var in iterable]`.
* Replace `set(map(lambda var: expression, iterable))` with a set comprehension `{expression for var in iterable}`.
* Replace `dict(map(lambda var: (key_expr, value_expr), iterable))` with a dictionary comprehension `{key_expr: value_expr for var in iterable}` (where `key_expr` and `value_expr` might depend on `var`).

[source,python,diff-id=1,diff-type=noncompliant]
----
nums = [1, 2, 3, 4]

list_map = list(map(lambda num: num * 2, nums)) # Noncompliant: the map and lambda function can be replaced by a list-comprehension
----

[source,python,diff-id=1,diff-type=compliant]
----
nums = [1, 2, 3, 4]

list_comp = [num * 2 for num in nums] # Compliant
----

== Resources

=== Documentation

* Python Documentation - https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions[List Comprehensions] 
* Python Documentation - https://docs.python.org/3/tutorial/classes.html#generator-expressions[Generator Expressions]
* Python Documentation - https://docs.python.org/3/library/functions.html#map[map()]
* Python Documentation - https://docs.python.org/3/reference/expressions.html#lambda[Lambdas]


ifdef::env-github,rspecator-view[]

== Implementation details

We should detect calls to map(lambda, iterable)
We do not need to detect complex cases such as filtering of lambda.
We do not need to detect lambdas that are assigned to a var.

=== Highlight

The `map` call and the `lambda` keyword.

=== Message

Replace this lambda function with its generator equivalent.

endif::env-github,rspecator-view[]
