Downloading data without enhanced authenticity and integrity checks exposes
various infrastructures to attacks. +
Depending on the organization`s internal infrastructure, there are at least two
targets:

* Its supply chain pipelines, where Dockerfiles are assembled into container images
* Its production environments, where the container images are executed.

Generally, any environment where the container image is running is at risk,
whether it is a test environment, UAT, pre-production, production, or
development machine.

The core of this issue is to understand the implied **Trust Model** of this
Dockerfile. +

For example: By using `http` to download an artifact, the code trusts everything:

* It trusts the remote website to be the one it is expected to be.
* It trusts the network route to be free from eavesdropping and tampering with.
** The route being the Internet, the remote website, and the application's internal network.

By using `https`, the code trust model evolves:

* It trusts the Certificate Authority (CA) that verified the remote website's certificate.
* It trusts its own storage to store only verified CA public keys.
* It trusts the HTTPS connection to be free from eavesdropping and tampering with.
* It does not trust the network route to the remote artifact, including its own internal network.
** HTTPS allows to protect the remote artifact during its route from a host toward another.

In practical terms, trusting HTTPS connections to be free from eavesdropping
can actually be an attack vector, because legitimate software such as corporate
proxy, anti-viruses include HTTPS interception to filter and inspect packets at
the operating system level. +
And these products also suffer from vulnerabilities.

Furthermore, malicious software can also perform packet inspection by
penetrating network internals of operating systems or trusted certificate
storage. +
This raises the question of how much is the server protected and trusted, and
it is out-of-scope for this rule.

Applying a second verification method on top of the HTTPS checks allows to add
defense-in-depths and get reassured regarding "what ifs", such as:

* What if Certificate Authorities get breached and their data tampered with?
* What if my certificate store is compromised?
** Because either systems that generated it got compromised
** Because my own system might be compromised
** Because the system where my code runs is managed by a third-party and might be compromised
* What if the system where my code runs performs packet inspection?
* What if DNS services are breached and cancels the authenticity and integrity checks made thanks to HTTPS?

== Ask Yourself Whether

* The downloaded artifact is expected to be code, and executed.
* The downloaded artifact is going to get used as a configuration file.
* The infrastructure network route to this remote artifact involves a lot of various systems.

There is a risk if you answered yes to any of these questions.

== Recommended Secure Coding Practices

Use `https` in conjuction with another method to perform authenticity and integrity checks.

For example, PGP (GPG), and Microsoft's Authenticode service are two viable options.

The former relies on a decentralized approach called **Web of trust**, and the
latter on a mix of certificate and reputation.

If it is not possible to use a method involving authenticity **and** integrity
checks, one workaround is to perform only an integrity check by determining the
hash of the software that needs to be used, or its installer file, and to
compare it to the remote artifact's hash once downloaded. +
It should be a robust ghash, such as SHA256.

*Note: Use the SHA256 fix together with version pinning: avoid tags like
"latest" or similar to avoid breaking container builds when the version of the
remote artifact changes.*

== Sensitive Code Example

For Linux-based images:

[source,docker]
----
FROM debian

# Direct curl bashing
RUN curl https://example.com/installer.sh | bash # Sensitive

# Indirect code execution
RUN curl https://example.com/installer.py -o installer.py; \
    python3 installer.py # Sensitive
----

For Windows-based images:

[source,docker]
----
FROM mcr.microsoft.com/windows/servercore:ltsc2019

# Direct download and launch
RUN Invoke-Expression ((new-object net.webclient).DownloadString('https://example.com/installer.ps1')) # Sensitive

# Indirect code execution
RUN Invoke-WebRequest 'https://example.com/installer.py' -OutFile 'installer.py' -UseBasicParsing ; \
    python script.py; # Sensitive
----

== Compliant Solution

GPG solution for Linux-based images:

[source,docker]
----
FROM debian

ENV GPG_KEY_SERVER "hkps://keys.openpgp.org"
ENV GPG_KEY_ID     "A035C8C19219BA821ECEA86B64E628F8D684696D"

RUN set -eux; \
    \
    wget -O installer.tar.xz "https://example.com/installer.tar.xz"; \
    wget -O installer.tar.xz.asc "https://example.com/installer.tar.xz.asc"; \
    \
    GNUPGHOME="$(mktemp -d)"; export GNUPGHOME; \
    gpg --batch --keyserver ${GPG_KEY_SERVER} --recv-keys "${GPG_KEY_ID}"; \
    gpg --batch --verify installer.tar.xz.asc installer.tar.xz; \
    \
    command -v gpgconf > /dev/null && gpgconf --kill all || :; \
    rm -rf "$GNUPGHOME" installer.tar.xz.asc;

----

For Windows-based images, GPG is not available by default, so it needs to be
prealably downloaded. This poses a problem of trust transfer to `gpg4win.org`. +
To verify `GPG4Win`, we can chose to transfer our trust to Microsoft's trust
infrastructure, and use Authenticode.

It is recommended to avoid using a software to verify itself. Doing this makes
it vulnerable to trojanized versions of itself, that will always return that
they trust themselves.

Here is an example of using GPG to verify a software on Windows:

[source,docker]
----
FROM mcr.microsoft.com/windows/servercore:ltsc2019

ENV GPG4WIN_VERSION      "2.3.4"
ENV GPG4WIN_AUTHENTICODE "DE16D5972F0B7395F7D91EDC1F219B0FFE89FAB3"

# Download and verify gpg4win - Using Authenticode
RUN Invoke-WebRequest \
        -Uri 'http://files.gpg4win.org/gpg4win-vanilla-${GPG4WIN_VERSION}.exe' \
        -OutFile 'gpg4win.exe' \
        -UseBasicParsing; \
    \
    $authenticode = Get-AuthenticodeSignature 'gpg4win.exe'; \
    if ( $authenticode.Status -ne 'Valid' ) \
        { Write-Error 'Authenticode check failed.'; }; \
    if ( $authenticode.SignerCertificate.Thumbprint -ne '${GPG4WIN_AUTHENTICODE}' ) \
        { Write-Error 'Authenticode signer check failed.'; }; \
    \
    Start-Process .\gpg4win.exe -ArgumentList '/S' -NoNewWindow -Wait

ENV SOFTWARE_VERSION                 "3.10.8"
ENV SOFTWARE_AUTHENTICODE_THUMBPRINT "36168EE17C1A240517388540C903BB6717DD2563"
ENV SOFTWARE_GPG_KEYSERVER           "hkps://keys.openpgp.org"
ENV SOFTWARE_GPG_KEY_ID              "A035C8C19219BA821ECEA86B64E628F8D684696D"

# Download and verify software - Using gpg4win
# You can use gpg4win and Authenticode.
RUN $url = ('https://example.com/software-${SOFTWARE_VERSION}.exe'); \
    \
    [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12; \
    Invoke-WebRequest -Uri $url     -OutFile 'software.exe'; \
    Invoke-WebRequest -Uri $url.asc -OutFile 'software.exe.asc'; \
    \
    if ( (Get-AuthenticodeSignature 'software.exe').Status -ne 'Valid' ) \
        { Write-Error 'Authenticode check failed.' } ; \
    if ( (Get-AuthenticodeSignature "software.exe").SignerCertificate.Thumbprint -ne '${GPG_SIGNER}' ) \
        { Write-Error 'Authenticode signer check failed.'; }; \
    \
    gpg --batch --keyserver "${SOFTWARE_GPG_KEYSERVER}" --recv-keys "${SOFTWARE_GPG_KEY_ID}"; \
    gpg --batch --verify software.exe.asc software.exe;
----

SHA256 solution for Linux-based images:
[source,docker]
----
FROM debian

ENV ARTIFACT_SHA256 "f2ca1bb6c7e907d06dafe4687e579fce76b37e4e93b7605022da52e6ccc26fd2"

# Here, trust is transferred to the distribution's own package management trust model.
RUN set -eux; \
    \
    wget -O installer.py "https://example.com/installer.py"; \
    echo "$ARTIFACT_SHA256 *installer.py" | sha256sum -c -; \
----

SHA256 solution for Windows-based images:

[source,docker]
----
FROM mcr.microsoft.com/windows/servercore:ltsc2019

ENV SOFTWARE_SHA256 "f2ca1bb6c7e907d06dafe4687e579fce76b37e4e93b7605022da52e6ccc26fd2"

RUN Invoke-WebRequest 'https://example.com/software.exe' -OutFile 'software.exe' -UseBasicParsing ; \
    $fileHash = Get-FileHash 'software.exe' -Algorithm sha256; \
    if ( $fileHash.Hash -ne '${SOFTWARE_SHA256}' ) \
        { Write-Error 'Integrity checki failed.'; };
    Start-Process .\software.exe;
----

== See

* https://cwe.mitre.org/data/definitions/384.html[MITRE, CWE-345] -  Insufficient Verification of Data Authenticity

ifdef::env-github,rspecator-view[]

'''
== Implementation Specification
(visible only on this page)

=== Message

Set in https://sonarsource.atlassian.net/browse/SONARIAC-478[SONARIAC-478].

=== Highlighting

Set in https://sonarsource.atlassian.net/browse/SONARIAC-478[SONARIAC-478].

endif::env-github,rspecator-view[]

