Downloading data without authenticity and integrity checks exposes various
infrastructures to attacks. +
Depending on the organization`s internal infrastructure, there are at least two
targets:

* Its supply chain pipelines, where Dockerfiles are assembled into container images
* Its production environments, where the container images are executed.

Generally, any environment where the container image is running is at risk,
whether it is a test environment, UAT, pre-production, production, or
development machine.

A malicious user or attacker group can exploit this attack vector through
various indirect attack surfaces.

The first would be to attack and penetrate the remote site to replace the
required artifacts with either entirely malicious artifacts or Trojanized
artifacts: Malicious code would be added, but all or part of the main function
would be preserved.

A second alternative would be to attack intermediaries such as DNS or
certificate infrastructures (Certificate Authorities).

For example, the command `curl \https://example.com/get-example.sh | sh` could
cause something unexpected to be installed and infect the build process and
runtime environment by Trojanizing the binary to be executed at runtime.

In the end, this is all a matter of trust:
* If you trust PGP and nothing else, you trust the **Web of Trust**.
* If you trust Authenticode (Windows signing tools), you trust Microsoft's Trust Architecture

If you trust \https://example.com and do not verify their software, you trust
your network, the Internet's network intermediaries, the remote artifact and
the remote infrastructure supporting that remote artifact.


== Ask Yourself Whether

* The downloaded artifact is expected to be code, and executed.
* The downloaded artifact is going to get used as a configuration file.

There is a risk if you answered yes to any of these questions.

== Recommended Secure Coding Practices

Use PGP to verify the integrity **and** authenticity of the remote artifact:

* Write the GPG key ID (s) in the Dockerfile
** Otherwise, it can also be compromised.
* Import the keys corresponding to the ID (s) key to where the artifact provider stores them
** For example: `hkps://keys.openpgp.org`.
* Download the remote file and the corresponding signature file
** Signature files usually end with `.asc`.
* Check this remote file with `gpg` and make sure that a failed check stops the build.

If the artifact supplier does not provide signatures or anything PGP-related,
the workaround is to check the artifact`s integrity:

* Write the SHA256 hash of the remote artifact to the Dockerfile
* Download the remote file
* Verify that the SHA256 hash of the remote file matches the original hardcoded hash.

This solution ensures that the remote artifact does not change because
SHA256 hashes **still cannot be forged**. However, it does not guarantee the
authenticity of the person who created it.

*Note: Use SHA256 correction together with version pinning: avoid tags like
"latest" or similar to avoid breaking container builds when the version of the
remote artifact changes.*


== Sensitive Code Example

For Linux-based images:

[source,docker]
----
FROM debian

# Direct curl bashing
RUN curl https://example.com/installer.sh | bash # Sensitive

# Indirect code execution
RUN curl https://example.com/installer.py -o installer.py; \
    python3 installer.py # Sensitive
----

For Windows-based images:

[source,docker]
----
FROM mcr.microsoft.com/windows/servercore:ltsc2019

# Direct download and launch
RUN Invoke-Expression ((new-object net.webclient).DownloadString('https://example.com/installer.ps1')) # Sensitive

# Indirect code execution
RUN Invoke-WebRequest 'https://example.com/installer.py' -OutFile 'installer.py' -UseBasicParsing ; \
    python script.py; # Sensitive
----

== Compliant Solution

GPG solution for Linux-based images:

[source,docker]
----
FROM debian

ENV GPG_KEY_SERVER hkps://keys.openpgp.org
ENV GPG_KEY_ID     A035C8C19219BA821ECEA86B64E628F8D684696D

RUN set -eux; \
    \
    wget -O installer.tar.xz "https://example.com/installer.tar.xz"; \
    wget -O installer.tar.xz.asc "https://example.com/installer.tar.xz.asc"; \
    \
    GNUPGHOME="$(mktemp -d)"; export GNUPGHOME; \
    gpg --batch --keyserver ${GPG_KEY_SERVER} --recv-keys "${GPG_KEY_ID}"; \
    gpg --batch --verify installer.tar.xz.asc installer.tar.xz; \
    \
    command -v gpgconf > /dev/null && gpgconf --kill all || :; \
    rm -rf "$GNUPGHOME" installer.tar.xz.asc;

----

For Windows-based images, GPG is not available by default, so it needs to be
prealably downloaded. This poses a problem of trust transfer to `gpg4win.org`. +
To verify `GPG4Win`, we can chose to transfer our trust to Microsoft's trust
infrastructure, and use Authenticode.

It is recommended to avoid using a software to verify itself. Doing this makes
it vulnerable to trojanized versions of itself, that will always return that
they trust themselves.

Here is an example of using GPG to verify a software on Windows:

[source,docker]
----
FROM mcr.microsoft.com/windows/servercore:ltsc2019

ENV GPG4WIN_VERSION      2.3.4
ENV GPG4WIN_AUTHENTICODE DE16D5972F0B7395F7D91EDC1F219B0FFE89FAB3

# Download and verify gpg4win - Using Authenticode
RUN Invoke-WebRequest \
        -Uri 'http://files.gpg4win.org/gpg4win-vanilla-${GPG4WIN_VERSION}.exe' \
        -OutFile 'gpg4win.exe' \
        -UseBasicParsing; \
    \
    $authenticode = Get-AuthenticodeSignature 'gpg4win.exe'; \
    if ( $authenticode.Status -ne 'Valid' ) \
        { Write-Error 'Authenticode check failed.'; }; \
    if ( $authenticode.SignerCertificate.Thumbprint -ne '${GPG4WIN_AUTHENTICODE}' ) \
        { Write-Error 'Authenticode signer check failed.'; }; \
    \
    Start-Process .\gpg4win.exe -ArgumentList '/S' -NoNewWindow -Wait

ENV SOFTWARE_VERSION                 3.10.8
ENV SOFTWARE_AUTHENTICODE_THUMBPRINT 36168EE17C1A240517388540C903BB6717DD2563
ENV SOFTWARE_GPG_KEYSERVER           hkps://keys.openpgp.org
ENV SOFTWARE_GPG_KEY_ID              A035C8C19219BA821ECEA86B64E628F8D684696D

# Download and verify software - Using gpg4win
# You can use gpg4win and Authenticode.
RUN $url = ('https://example.com/software-${SOFTWARE_VERSION}.exe'); \
    \
    [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12; \
    Invoke-WebRequest -Uri $url     -OutFile 'software.exe'; \
    Invoke-WebRequest -Uri $url.asc -OutFile 'software.exe.asc'; \
    \
    if ( (Get-AuthenticodeSignature 'software.exe').Status -ne 'Valid' ) \
        { Write-Error 'Authenticode check failed.' } ; \
    if ( (Get-AuthenticodeSignature "software.exe").SignerCertificate.Thumbprint -ne '${GPG_SIGNER}' ) \
        { Write-Error 'Authenticode signer check failed.'; }; \
    \
    gpg --batch --keyserver "${SOFTWARE_GPG_KEYSERVER}" --recv-keys "${SOFTWARE_GPG_KEY_ID}"; \
    gpg --batch --verify software.exe.asc software.exe;
----

SHA256 solution for Linux-based images:
[source,docker]
----
FROM debian

ENV ARTIFACT_SHA256 f2ca1bb6c7e907d06dafe4687e579fce76b37e4e93b7605022da52e6ccc26fd2

# Here, trust is transferred to the distribution's own package management trust model.
RUN set -eux; \
    \
    wget -O installer.py "https://example.com/installer.py"; \
    echo "$ARTIFACT_SHA256 *installer.py" | sha256sum -c -; \
----

SHA256 solution for Windows-based images:

[source,docker]
----
FROM mcr.microsoft.com/windows/servercore:ltsc2019

ENV SOFTWARE_SHA256 f2ca1bb6c7e907d06dafe4687e579fce76b37e4e93b7605022da52e6ccc26fd2

RUN Invoke-WebRequest 'https://example.com/software.exe' -OutFile 'software.exe' -UseBasicParsing ; \
    $fileHash = Get-FileHash 'software.exe' -Algorithm sha256; \
    if ( $fileHash.Hash -ne '${SOFTWARE_SHA256}' ) \
        { Write-Error 'Integrity checki failed.'; };
    Start-Process .\software.exe;
----

== See

* https://cwe.mitre.org/data/definitions/384.html[MITRE, CWE-345] -  Insufficient Verification of Data Authenticity

ifdef::env-github,rspecator-view[]

'''
== Implementation Specification
(visible only on this page)

=== Message

Set in https://sonarsource.atlassian.net/browse/SONARIAC-478[SONARIAC-478].

=== Highlighting

Set in https://sonarsource.atlassian.net/browse/SONARIAC-478[SONARIAC-478].

endif::env-github,rspecator-view[]

