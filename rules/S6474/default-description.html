<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Using remote artifacts without authenticity and integrity checks can lead to
the unexpected installation of malicious software in the built container image.</p>
</div>
<div class="paragraph">
<p>In the build environment, where Dockerfiles are compiled into container images,
malicious code could gain access to sensitive data, such as build secrets or
source code, and durably poison the resulting image.</p>
</div>
<div class="paragraph">
<p>In the runtime environments where the container images are executed, malicious
code could access and modify all runtime data and use the container as a pivot
to attack the surrounding network environment.</p>
</div>
<div class="paragraph">
<p>By ensuring that a remote artifact is exactly what it is supposed to be before
it is used, the environment is protected from unexpected changes before or
after it is downloaded.<br>
That is to say if it has been replaced by malware:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>on the website where it is published.</p>
</li>
<li>
<p>in the environment where it is used.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Important note: HTTPS protects data in transit from one host to another. It
provides authenticity and integrity checks <strong>for the network stream</strong>, not for
the downloaded artifact itself.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_ask_yourself_whether">Ask Yourself Whether</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>The artifact is a file intended to execute code.</p>
</li>
<li>
<p>The artifact is a file that is intended to configure or affect running code in some way.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There is a risk if you answer yes to any of these questions.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_recommended_secure_coding_practices">Recommended Secure Coding Practices</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To check the authenticity and integrity of a remote artifact, <code>gpg</code> is the preferred
method, except on Windows hosts, since it is not available by default. In this
case, <strong>authenticode</strong> is the method of choice.</p>
</div>
<div class="paragraph">
<p>If the remote publisher does not provide a signature for the desired artifact,
hash verification is the most reliable solution. While it does not prove who
the creator of the artifact is, it does ensure that the file has not been
modified since the fingerprint was computed.</p>
</div>
<div class="paragraph">
<p>In this case, the artifact&#8217;s hash must:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Be computed with a secure hash algorithm such as <code>SHA512</code>, <code>SHA384</code>, or <code>SHA256</code>.</p>
</li>
<li>
<p>Be compared with a secure hash that was <strong>not</strong> downloaded from the same source.</p>
<div class="ulist">
<ul>
<li>
<p>To do so, the best option is to compute the hash before and add it in the code explicitly.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Note: Use the hash fix together with version binding. Avoid using tags
like "latest" or similar, so that container builds are not corrupted when the
version of the remote artifact changes.</strong></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_sensitive_code_example">Sensitive Code Example</h2>
<div class="sectionbody">
<div class="paragraph">
<p>For Linux-based images:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-docker" data-lang="docker">FROM debian

RUN curl https://example.com/installer.sh | bash # Sensitive

RUN curl https://example.com/installer.py -o installer.py; \
    python3 installer.py # Sensitive</code></pre>
</div>
</div>
<div class="paragraph">
<p>For Windows-based images:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-docker" data-lang="docker">FROM mcr.microsoft.com/windows/servercore:ltsc2019

RUN Invoke-Expression ((new-object net.webclient).DownloadString('https://example.com/installer.ps1')) # Sensitive

RUN Invoke-WebRequest 'https://example.com/installer.ps1' -OutFile 'installer.ps1' -UseBasicParsing ; \
    python script.ps1 # Sensitive</code></pre>
</div>
</div>
<div class="paragraph">
<p>For <code>ADD</code>-originating artifacts:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-docker" data-lang="docker">FROM alpine

ADD https://example.com/Makefile / # Sensitive

RUN make install</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_compliant_solution">Compliant Solution</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Note that the compliant solutions can also be used with artifacts originating
from an <code>ADD https://example.com/artifact</code> instruction.</p>
</div>
<div class="paragraph">
<p>GPG solution for Linux-based images:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-docker" data-lang="docker">FROM debian

ENV GPG_KEY_SERVER "hkps://keys.openpgp.org"
ENV GPG_KEY_ID     "A035C8C19219BA821ECEA86B64E628F8D684696D"

RUN set -eux; \
    \
    wget -O installer.tar.xz     "https://example.com/installer.tar.xz"; \
    wget -O installer.tar.xz.asc "https://example.com/installer.tar.xz.asc"; \
    \
    GNUPGHOME="$(mktemp -d)"; export GNUPGHOME; \
    gpg --batch --keyserver ${GPG_KEY_SERVER} --recv-keys "${GPG_KEY_ID}"; \
    gpg --batch --verify installer.tar.xz.asc installer.tar.xz</code></pre>
</div>
</div>
<div class="paragraph">
<p>For Windows-based images, GPG is not available by default, so it needs to be
downloaded beforehand. Thus, it is required to be checked before use.  To
verify <code>GPG4Win</code>, use Authenticode.</p>
</div>
<div class="paragraph">
<p>It is recommended to avoid using software to verify itself. Compromised
verification software might always validate itself.</p>
</div>
<div class="paragraph">
<p>Here is an example of using GPG to verify a software on Windows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-docker" data-lang="docker">FROM mcr.microsoft.com/windows/servercore:ltsc2019

ENV GPG4WIN_VERSION      "2.3.4"
ENV GPG4WIN_AUTHENTICODE "DE16D5972F0B7395F7D91EDC1F219B0FFE89FAB3"

# Download and verify gpg4win - Using Authenticode
RUN Invoke-WebRequest \
        -Uri $('http://files.gpg4win.org/gpg4win-vanilla-{}.exe' -f $env:GPG4WIN_VERSION) \
        -OutFile 'gpg4win.exe' \
        -UseBasicParsing; \
    \
    $authenticode = Get-AuthenticodeSignature 'gpg4win.exe'; \
    if ( $authenticode.Status -ne 'Valid' ) \
        { Write-Error 'Authenticode check failed.'; }; \
    if ( $authenticode.SignerCertificate.Thumbprint -ne $env:GPG4WIN_AUTHENTICODE ) \
        { Write-Error 'Authenticode signer check failed.'; }; \
    \
    Start-Process .\gpg4win.exe -ArgumentList '/S' -NoNewWindow -Wait

ENV SOFTWARE_VERSION                 "3.10.8"
ENV SOFTWARE_AUTHENTICODE_THUMBPRINT "36168EE17C1A240517388540C903BB6717DD2563"
ENV SOFTWARE_GPG_KEYSERVER           "hkps://keys.openpgp.org"
ENV SOFTWARE_GPG_KEY_ID              "A035C8C19219BA821ECEA86B64E628F8D684696D"

# Download and verify software - Using gpg4win
# You can use gpg4win and Authenticode.
RUN $url = $('https://example.com/software-${}.exe' -f $env:SOFTWARE_VERSION); \
    \
    [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12; \
    Invoke-WebRequest -Uri $url     -OutFile 'software.exe'     -UseBasicParsing; \
    Invoke-WebRequest -Uri $url.asc -OutFile 'software.exe.asc' -UseBasicParsing; \
    \
    if ( (Get-AuthenticodeSignature 'software.exe').Status -ne 'Valid' ) \
        { Write-Error 'Authenticode check failed.' } ; \
    if ( (Get-AuthenticodeSignature "software.exe").SignerCertificate.Thumbprint -ne $env:GPG_SIGNER ) \
        { Write-Error 'Authenticode signer check failed.'; }; \
    \
    gpg --batch --keyserver "${SOFTWARE_GPG_KEYSERVER}" --recv-keys $env:SOFTWARE_GPG_KEY_ID; \
    gpg --batch --verify software.exe.asc software.exe;</code></pre>
</div>
</div>
<div class="paragraph">
<p>SHA256 solution for Linux-based images:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-docker" data-lang="docker">FROM debian

ENV ARTIFACT_SHA256 "f2ca1bb6c7e907d06dafe4687e579fce76b37e4e93b7605022da52e6ccc26fd2"

RUN set -eux; \
    \
    wget -O installer.py "https://example.com/installer.py"; \
    echo "$ARTIFACT_SHA256 *installer.py" | sha256sum -c -</code></pre>
</div>
</div>
<div class="paragraph">
<p>SHA256 solution for Windows-based images:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-docker" data-lang="docker">FROM mcr.microsoft.com/windows/servercore:ltsc2019

ENV SOFTWARE_SHA256 "f2ca1bb6c7e907d06dafe4687e579fce76b37e4e93b7605022da52e6ccc26fd2"

RUN Invoke-WebRequest 'https://example.com/software.exe' -OutFile 'software.exe' -UseBasicParsing ; \
    $fileHash = Get-FileHash 'software.exe' -Algorithm sha256; \
    if ( $fileHash.Hash -ne $env:SOFTWARE_SHA256 ) \
        { Write-Error 'Integrity check failed.'; }; \
    Start-Process .\software.exe;</code></pre>
</div>
</div>
<div class="paragraph">
<p>SHA256 version on <code>ADD</code> instructions, for Dockerfiles using a non-stable syntax:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-docker" data-lang="docker"># syntax=docker/dockerfile:1-labs
FROM alpine

ADD \
    --checksum=sha256:24454f830cdb571e2c4ad15481119c43b3cafd48dd869a9b2945d1036d1dc68d \
    https://example.com/Makefile /

RUN make install</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_see">See</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>OWASP - <a href="https://owasp.org/Top10/A08_2021-Software_and_Data_Integrity_Failures/">Top 10 2021 Category A8 - Software and Data Integrity Failures</a></p>
</li>
<li>
<p>OWASP - <a href="https://owasp.org/www-project-mobile-top-10/2023-risks/m2-inadequate-supply-chain-security">Mobile Top 10 2024 Category M2 - Inadequate Supply Chain Security</a></p>
</li>
<li>
<p>CWE - <a href="https://cwe.mitre.org/data/definitions/494">CWE-494 - Download of Code Without Integrity Check</a></p>
</li>
<li>
<p>STIG Viewer - <a href="https://stigviewer.com/stigs/application_security_and_development/2024-12-06/finding/V-222618">Application Security and Development: V-222618</a> - Unsigned Category 1A mobile code must not be used in the application in accordance with DoD policy.</p>
</li>
<li>
<p><a href="https://www.linux.com/training-tutorials/pgp-web-trust-core-concepts-behind-trusted-communication/">Linux.com, PGP Web of Trust: Core Concepts Behind Trusted Communication</a></p>
</li>
</ul>
</div>
<hr>
</div>
</div>
<div class="sect1">
<h2 id="_implementation_specification">Implementation Specification</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_message">Message</h3>
<div class="ulist">
<ul>
<li>
<p>"Standard stream piping" detection: Downloading from this location without authenticity and integrity checks expose the container to network attacks. Make sure it is safe here.</p>
</li>
<li>
<p>Invoke-Expression: Running code without authenticity and integrity checks expose the container to network attacks. Make sure it is safe here.</p>
</li>
<li>
<p>File downloaded and used without checks: The authenticity and integrity of this artifact are not checked and expose the container to network attacks. Make sure it is safe here.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_highlighting">Highlighting</h3>
<div class="ulist">
<ul>
<li>
<p>"Standard stream piping" detection: The downloading command.</p>
</li>
<li>
<p>Invoke-Expression: the full instruction</p>
</li>
<li>
<p>File downloaded and used without checks: The URL</p>
</li>
</ul>
</div>
</div>
</div>
</div>