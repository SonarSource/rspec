<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Virtual and non-virtual functions are not dispatched the same way: for virtual functions, the resolution will be done dynamically while for non-virtual ones, it will be done statically by the compiler based on the type it sees.</p>
</div>
<div class="paragraph">
<p>Thus, overloading functions with both virtual and non-virtual functions adds a level of complexity to the code because the resolution of these functions will be completely different even though they share the same name. So the code becomes more confusing and more error-prone (for example if a virtual function is mistaken with a non-virtual one).</p>
</div>
<div class="sect2">
<h3 id="_noncompliant_code_example">Noncompliant code example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#include &lt;iostream&gt;

struct A {
  virtual void size(double a) {
    std::cout &lt;&lt; "A double" &lt;&lt; std::endl;
  }
  void size(int b) { // Noncompliant, it overloads size(double) which is virtual
    std::cout &lt;&lt; "A int" &lt;&lt; std::endl;
  }
};

struct B : A {
  void size(double a) override {
    std::cout &lt;&lt; "B double" &lt;&lt; std::endl;
  }
  void size(int b) {
    std::cout &lt;&lt; "B int" &lt;&lt; std::endl;
  }
};

int main() {
  A* a = new B;
  a-&gt;size(2.2); // will display "B double"
  a-&gt;size(2); // will display "A int"

  return 0;
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_compliant_solution">Compliant solution</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#include &lt;iostream&gt;

struct A {
  virtual void size(double a) {
    std::cout &lt;&lt; "A double" &lt;&lt; std::endl;
  }
  virtual void size(int b) {
    std::cout &lt;&lt; "A int" &lt;&lt; std::endl;
  }
};

struct B : A {
  void size(double a) override {
    std::cout &lt;&lt; "B double" &lt;&lt; std::endl;
  }
  void size(int b) override {
    std::cout &lt;&lt; "B int" &lt;&lt; std::endl;
  }
};

int main() {
  A* a = new B;
  a-&gt;size(2.2); // will display "B double"
  a-&gt;size(2); // will display "B int"

  return 0;
}</code></pre>
</div>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_implementation_specification">Implementation Specification</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_message">Message</h3>
<div class="paragraph">
<p>Declare this overload as virtual.</p>
</div>
</div>
</div>
</div>