<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This rule raises an issue when goroutines perform blocking operations or run indefinitely without proper context-based cancellation or timeout mechanisms.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Goroutines are lightweight threads in Go that make concurrent programming easy and efficient. However, without proper lifecycle management, they can become a source of serious problems.</p>
</div>
<div class="paragraph">
<p>When goroutines perform blocking operations like network calls, file I/O, or channel operations without timeout mechanisms, they can hang indefinitely. This leads to several issues:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Resource leaks</strong>: Goroutines that never terminate continue to consume memory and system resources</p>
</li>
<li>
<p><strong>Application unresponsiveness</strong>: Blocked goroutines can prevent proper application shutdown</p>
</li>
<li>
<p><strong>Scalability problems</strong>: Accumulated leaked goroutines can exhaust system resources</p>
</li>
<li>
<p><strong>Difficult debugging</strong>: Goroutine leaks are often hard to detect and diagnose in production</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Go&#8217;s <code>context</code> package provides a standard way to handle cancellation, timeouts, and request-scoped values across API boundaries. When goroutines use context properly, they can:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Respond to cancellation signals from parent operations</p>
</li>
<li>
<p>Implement timeouts for potentially long-running operations</p>
</li>
<li>
<p>Clean up resources when operations are no longer needed</p>
</li>
<li>
<p>Provide better observability and control over concurrent operations</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Without context handling, goroutines become fire-and-forget operations that can accumulate over time, eventually causing memory leaks and performance degradation.</p>
</div>
<div class="sect2">
<h3 id="_what_is_the_potential_impact">What is the potential impact?</h3>
<div class="paragraph">
<p>Goroutines without proper lifecycle management can cause memory leaks, resource exhaustion, and application instability. In high-traffic applications, this can lead to gradual performance degradation and eventual system failure. The lack of proper cancellation mechanisms also makes it difficult to implement graceful shutdowns and can result in hanging processes during deployment or restart scenarios.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_fix_it">How to fix it</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Use context.WithTimeout for operations that should have a maximum duration. This ensures that goroutines don&#8217;t block indefinitely on potentially slow operations.</p>
</div>
<div class="sect2">
<h3 id="_code_examples">Code examples</h3>
<div class="sect3">
<h4 id="_noncompliant_code_example">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-go" data-lang="go">func fetchData() {
    go func() {
        resp, err := http.Get("https://api.example.com/data") // Noncompliant
        if err != nil {
            return
        }
        defer resp.Body.Close()
        // Process response
    }()
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-go" data-lang="go">func fetchData(ctx context.Context) {
    go func() {
        ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
        defer cancel()

        req, _ := http.NewRequestWithContext(ctx, "GET", "https://api.example.com/data", nil)
        resp, err := http.DefaultClient.Do(req)
        if err != nil {
            return
        }
        defer resp.Body.Close()
        // Process response
    }()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_documentation">Documentation</h3>
<div class="ulist">
<ul>
<li>
<p>Go Context Package - <a href="https://pkg.go.dev/context">Official documentation for Go&#8217;s context package</a></p>
</li>
<li>
<p>Go Concurrency Patterns: Context - <a href="https://go.dev/blog/context">Official Go blog post explaining context usage patterns</a></p>
</li>
<li>
<p>Go Concurrency Patterns: Timing out, moving on - <a href="https://go.dev/blog/concurrency-timeouts">Go blog post about implementing timeouts in concurrent operations</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_standards">Standards</h3>
<div class="ulist">
<ul>
<li>
<p>CWE-400: Uncontrolled Resource Consumption - <a href="https://cwe.mitre.org/data/definitions/400.html">Weakness related to uncontrolled resource consumption that can lead to resource exhaustion</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>