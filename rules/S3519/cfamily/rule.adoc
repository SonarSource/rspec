Memory accesses should be bounded to prevent buffer overflows.

== Why is this an issue?

Array overruns and buffer overflows occur when a memory access accidentally goes beyond the boundary of the allocated array or buffer.

These overreaching accesses cause some of the most damaging and hard to track defects.
Not only do these faulty accesses constitute undefined behavior, but they frequently introduce security vulnerabilities and open up the program to buffer overflow attacks, too.


== What is the potential impact?

Accessing memory that goes beyond the boundary of the allocated array or buffer results in undefined behavior.

For programs that exercise undefined behavior, the compiler is no longer bound by the language specification.
The application may crash or, even worse, the application may appear to execute correctly while losing data or producing incorrect results.

Out-of-bounds memory accesses cause some of the most damaging and hard-to-track defects.
Unbounded memory accesses may also introduce severe security vulnerabilities.
In case a user of the program can control the contents of a buffer, for instance, a malicious attacker can the buffer overflow to overwrite critical data, execute arbitrary code, or gain unauthorized access to the system.


== How to fix it

Ensure that memory access are within the bounds of the allocated array or buffer.

If {cpp} is available, use the `std::array` or `std::vector` types to manage stack or heap-based arrays, respectively and use `std::string` to manage string buffers.


=== Code examples

==== Noncompliant code example

[source,cpp,diff-id=1,diff-type=noncompliant]
----
#include <stdio.h>

int main() {
  char buffer[64] = {0};
  if (fgets(buffer, 2048, stdin) != NULL) { // Noncompliant: target buffer may overflow
    printf("buffer contents: %s", buffer);
  }
  return 0;
}
----

==== Compliant solution

[source,cpp,diff-id=1,diff-type=compliant]
----
#include <stdio.h>

int main() {
  char buffer[64] = {0};
  if (fgets(buffer, 64, stdin) != NULL) { // Compliant: reads at most 64 - 1 characters
    printf("buffer contents: %s", buffer);
  }
  return 0;
}
----

==== Noncompliant code example

[source,cpp,diff-id=2,diff-type=noncompliant]
----
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void foo() {
  char *buf1 = (char *)malloc(17);
  char *buf2 = (char *)malloc(8);
  memset(buf1, 0, 17);
  memset(buf2, 0, 8);
  const char *const str = "AAAA"
                          "BBBB"
                          "CCCC"
                          "DDDD";
  strncpy(buf1, str, strlen(str));
  memcpy(buf2, buf1, 17); // Noncompliant: buf2 will overflow.
  printf("buf1: %s\n", buf1);
  printf("buf2: %s\n", buf2);
  free(buf1);
  free(buf2);
}
----

==== Compliant solution

[source,cpp,diff-id=2,diff-type=compliant]
----
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void foo() {
  char *buf1 = (char *)malloc(17);
  char *buf2 = (char *)malloc(8);
  memset(buf1, 0, 17);
  memset(buf2, 0, 8);
  const char *const str = "AAAA"
                          "BBBB"
                          "CCCC"
                          "DDDD";
  strncpy(buf1, str, strlen(str));
  // Compliant: copy 7 bytes and leave the 8th terminating null byte ('\0') untouched
  // such that `buf2` can be correctly printed in the subsequent lines.
  memcpy(buf2, buf1, 7);
  printf("buf1: %s\n", buf1);
  printf("buf2: %s\n", buf2);
  free(buf1);
  free(buf2);
}
----

==== Noncompliant code example

[source,cpp,diff-id=3,diff-type=noncompliant]
----
#include <stdio.h>

void foo() {
  char txt[16] = "Hello, World!";
  for (size_t i = 0; i <= sizeof(txt); ++i) { // Noncompliant: index should be between 0 and 15
    printf("%c\n", txt[i]);
  }
}
----

==== Compliant solution

[source,cpp,diff-id=3,diff-type=compliant]
----
void foo() {
  char txt[16] = "Hello, World!";
  for (size_t i = 0; i < sizeof(txt); ++i) { // Compliant: index is between 0 and 15
    printf("%c\n", txt[i]);
  }
}
----

=== Going the extra mile

Buffer overflows occur when a program writes data beyond the boundaries of a buffer and can lead to memory corruption and potential security vulnerabilities.
To mitigate this risk, developers must carefully manage array and buffer sizes (, use secure coding practices, and employ techniques like input validation and bounds checking).

In {cpp}, manual array or string, i.e., buffer manipulations are considered a code smell.

Instead, the `std::array` type should be used to manage stack-based arrays, and the `std::vector` type should be used if a heap-based array is desired.
Besides always carrying their respective sizes, i.e., number of elements, `std::array` and `std::vector` implement many useful member functions such as `begin()` and `end()`, allowing one to safely and conveniently process them using algorithms from the {cpp}'s `<algorithm>` header, for instance.
An example is shown in the following:

[source,cpp]
----
#include <algorithm>
#include <array>
#include <iostream>
#include <numeric>
#include <vector>

void bar() {
  // stack-based array
  std::array<int, 8> stack_buf;
  std::fill(stack_buf.begin(), stack_buf.end(), 42);
  for (auto i : stack_buf) {
    std::cout << i << ' ';
  }
  std::cout << '\n';
  std::cout << "sum of stack_buf's values: "
            << std::accumulate(stack_buf.begin(), stack_buf.end(), 0) << '\n';
  // heap-based array
  std::vector<int> heap_buf = {1, 2, 3, 4};
  heap_buf.resize(10);
  std::iota(heap_buf.begin(), heap_buf.end(), 1);
  std::cout << "sum of heap_buf's values: "
            << std::accumulate(heap_buf.begin(), heap_buf.end(), 0) << '\n';
}
----

The `std::string` type should be used to manage buffers, since it guarantees safe buffer manipulations.
Instead of manually concatenating two buffers using `strncat`, for instance, `std::string` allows this operation to be performed in a much more convenient manner as shown in the following code:

[source,cpp]
----
#include <iostream>
#include <string>

void buz(std::string const &s) {
  std::string t = "Hello, " + s;
  std::cout << t << '\n';
}
----

In addition, the `std::format` function allows one to format strings according to a user-specified format and returns the result as a string as shown in what follows:

[source, cpp]
----
#include <format>
#include <iostream>
#include <string>

void tar(std::string const &s) {
  std::string t = std::format("Hello, World! Greetings {}\n", s);
  std::cout << t << '\n';
}
----


== Resources

=== Conference presentations

* CppCon 2018 - https://www.youtube.com/watch?v=0S0QgQd75Sw&ab_channel=CppCon[Software Vulnerabilities in C and C++]

=== Standards

* CERT - https://wiki.sei.cmu.edu/confluence/x/wtYxBQ[ARR30-C. Do not form or use out-of-bounds pointers or array subscripts]
* CERT - https://wiki.sei.cmu.edu/confluence/x/i3w-BQ[STR50-CPP. Guarantee that storage for strings has sufficient space for character data and the null terminator]
* CWE - https://cwe.mitre.org/data/definitions/119[119 Improper Restriction of Operations within the Bounds of a Memory Buffer]
* CWE - https://cwe.mitre.org/data/definitions/121.html[121 Stack-based Buffer Overflow]
* CWE - https://cwe.mitre.org/data/definitions/122.html[122 Heap-based Buffer Overflow]
* CWE - https://cwe.mitre.org/data/definitions/131[131 Incorrect Calculation of Buffer Size]
* CWE - https://cwe.mitre.org/data/definitions/788[788 Access of Memory Location After End of Buffer]


ifdef::env-github,rspecator-view[]

'''
== Implementation Specification
(visible only on this page)

=== Message

* Review this array access; it is likely to be an overrun.
* Review this memory access; it is likely to create an overflow.


=== Highlighting

Primary: Array access or function call

Secondary: * Index value for arrays

* Length value for functions call
* For loop end condition if applicable


'''
== Comments And Links
(visible only on this page)

Possible messages of the rule S3519:

* alpha.security.ArrayBoundV2
[source,cpp]
----
void access_exceeds(void) {
  int id_sequence[3];
  id_sequence[0] = 123;
  id_sequence[1] = 234;
  id_sequence[2] = 345;
  id_sequence[3] = 456; // Noncompliant: accessing out of bounds.
  // Out of bound memory access (access exceeds upper limit of memory block)
}
void access_precedes(int x) {
  int buf[100];
  int *p = buf;
  --p;
  p[0] = 1; // Out of bound memory access (accessed memory precedes memory block)
}
int getchar(void);
void access_tainted(void) {
  int m = getchar();
  Buffer[m] = 1; // Out of bound memory access (index is tainted)
}
----

* alpha.security.ReturnPtrRange
[source,cpp]
----
int *test_idx_sym(int i) {
  static int arr[10];
  if (i != 40)
    return arr;
  return arr + i; // Returned pointer value points outside the original object
}
----

* alpha.unix.cstring.OutOfBounds
[source,cpp]
----
char* my_calloc(int n) {
  char *p = malloc(n);
  memset(p, 0, n + /*null terminator*/1); // OOB: off by one
  // Memory set function overflows the destination buffer
  return p;
}
void memcpy1(void) {
  char src[] = {1, 2, 3, 4};
  char dst[10];
  memcpy(dst, src, 5); // Memory copy function accesses out-of-bound array element
}
----

Typical bugs:
* Off-by-one bugs

Mitigations (extra mile):

* asan
* valgrind
* Use "bounded" alternative functions, such as `strncpy`.
* Compilation flags to harden the binary: FORTIFY_SOURCE, stack-canaries, ASLR
* fuzzing

Clarification question regarding inclusion forthis link in [https://discuss.sonarsource.com/t/layc-2023-languages-team-updates/14242/31?u=tomasz_kaminski[discuss].

Possibly missing CWEs from rspec:
* https://cwe.mitre.org/data/definitions/787.html
* https://cwe.mitre.org/data/definitions/193.html

=== is related to: S5782

endif::env-github,rspecator-view[]
