<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This vulnerability makes it possible that an encrypted communication is
intercepted.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Transport Layer Security (TLS) provides secure communication between systems
over the internet by encrypting the data sent between them. Certificate validation
adds an extra layer of trust and security to this process to ensure that a system
is indeed the one it claims to be.</p>
</div>
<div class="paragraph">
<p>When certificate validation is disabled, the client skips a critical security check.
This creates an opportunity for attackers to pose as a trusted entity and
intercept, manipulate, or steal the data being transmitted.</p>
</div>
<div class="sect2">
<h3 id="_what_is_the_potential_impact">What is the potential impact?</h3>
<div class="paragraph">
<p>Establishing trust in a secure way is a non-trivial task. When you disable
certificate validation, you are removing a key mechanism designed to build this
trust in internet communication, opening your system up to a number of potential
threats.</p>
</div>
<div class="sect3">
<h4 id="_identity_spoofing">Identity spoofing</h4>
<div class="paragraph">
<p>If a system does not validate certificates, it cannot confirm the identity of
the other party involved in the communication. An attacker can exploit this by
creating a fake server and masquerading as a legitimate one. For example,
they might set up a server that looks like your bank&#8217;s server, tricking your
system into thinking it is communicating with the bank. This scenario, called
identity spoofing, allows the attacker to collect any data your system sends
to them, potentially leading to significant data breaches.</p>
</div>
</div>
<div class="sect3">
<h4 id="_loss_of_data_integrity">Loss of data integrity</h4>
<div class="paragraph">
<p>When TLS certificate validation is disabled, the integrity of the data you send
and receive cannot be guaranteed. An attacker could modify the data in transit,
and you would have no way of knowing. This could range from subtle manipulations
of the data you receive to the injection of malicious code or malware into your
system. The consequences of such breaches of data integrity can be severe,
depending on the nature of the data and the system.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_fix_it_in_foundation">How to fix it in Foundation</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_code_examples">Code examples</h3>
<div class="paragraph">
<p>The following code contains examples of disabled certificate validation.</p>
</div>
<div class="paragraph">
<p>The certificate validation is disabled by implementing the <code>urlSession(_:didReceive:completionHandler:)</code> delegate method of <code>URLSessionDelegate</code> to unconditionally trust the server, without proper validation.</p>
</div>
<div class="paragraph">
<p>This means that a certificate initially rejected by the system will be accepted, regardless of its origin.</p>
</div>
<div class="sect3">
<h4 id="_noncompliant_code_example">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-swift" data-lang="swift">import Foundation

class MyURLSessionDelegate: NSObject, URLSessionDelegate {
    func urlSession(_ session: URLSession,
                    didReceive challenge: URLAuthenticationChallenge,
                    completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -&gt; Void) {

        if challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust {
            // Noncompliant: the server certificate is not validated
            let credential = URLCredential(trust: challenge.protectionSpace.serverTrust!)
            completionHandler(.useCredential, credential)
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution">Compliant solution</h4>
<div class="paragraph">
<p>The <code>serverTrust</code> object has to be validated. Based on the validation result, <code>completionHandler</code> should be called with either <code>.useCredential</code> to proceed with the connection, or <code>.cancelAuthenticationChallenge</code> to block it.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-swift" data-lang="swift">import Foundation

class MyURLSessionDelegate: NSObject, URLSessionDelegate {
    func urlSession(_ session: URLSession,
                    didReceive challenge: URLAuthenticationChallenge,
                    completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -&gt; Void) {

        guard challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust,
              let serverTrust = challenge.protectionSpace.serverTrust else {
            completionHandler(.performDefaultHandling, nil)
            return
        }

        if isServerCertificateValid(serverTrust) {
            completionHandler(.useCredential, URLCredential(trust: serverTrust))
        } else {
            completionHandler(.cancelAuthenticationChallenge, nil)
        }
    }

    private func isServerCertificateValid(_ serverTrust: SecTrust) -&gt; Bool {
        // Implement the server certificate validation logic here.
        // For instance, by using SecTrustEvaluateWithError or by doing certificate pinning.
        var error: CFError?
        return SecTrustEvaluateWithError(serverTrust, &amp;error)
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_how_does_this_work">How does this work?</h3>
<div class="paragraph">
<p>Addressing the vulnerability of disabled TLS certificate validation primarily
involves re-enabling the default validation.</p>
</div>
<div class="paragraph">
<p>To avoid running into problems with invalid certificates, consider the following
sections.</p>
</div>
<div class="sect3">
<h4 id="_using_trusted_certificates">Using trusted certificates</h4>
<div class="paragraph">
<p>If possible, always use a certificate issued by a well-known, trusted CA for
your server. Most programming environments come with a predefined list of
trusted root CAs, and certificates issued by these authorities are validated
automatically. This is the best practice, and it requires no additional code or
configuration.</p>
</div>
</div>
<div class="sect3">
<h4 id="_working_with_self_signed_certificates_or_non_standard_cas">Working with self-signed certificates or non-standard CAs</h4>
<div class="paragraph">
<p>In some cases, you might need to work with a server using a self-signed
certificate, or a certificate issued by a CA not included in your trusted roots.
Rather than disabling certificate validation in your code, you can add the
necessary certificates to your trust store.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_fix_it_in_alamofire">How to fix it in Alamofire</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_code_examples_2">Code examples</h3>
<div class="paragraph">
<p>The following code contains examples of disabled certificate validation.</p>
</div>
<div class="paragraph">
<p>The certificate validation can be disabled for a given domain by configuring the <code>ServerTrustManager</code> with a <code>DisabledTrustEvaluator</code>. This is dangerous as it allows any certificate for that domain, making the connection vulnerable to man-in-the-middle attacks.</p>
</div>
<div class="sect3">
<h4 id="_noncompliant_code_example_2">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-swift" data-lang="swift">import Alamofire

let manager = ServerTrustManager(evaluators: ["insecure.example.com": DisabledTrustEvaluator()])  // Noncompliant
let session = Session(serverTrustManager: manager)

session.request("https://insecure.example.com").response { response in
    // ...
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution_2">Compliant solution</h4>
<div class="paragraph">
<p>Do not use <code>DisabledTrustEvaluator</code>. Rely on Alamofire&#8217;s default trust evaluation, or use other evaluators like <code>PinnedCertificatesTrustEvaluator</code> or <code>DefaultTrustEvaluator</code> for enhanced security.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-swift" data-lang="swift">import Alamofire

let session = Session.default

session.request("https://secure.example.com").response { response in
    // ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_how_does_this_work_2">How does this work?</h3>
<div class="paragraph">
<p>Addressing the vulnerability of disabled TLS certificate validation primarily
involves re-enabling the default validation.</p>
</div>
<div class="paragraph">
<p>To avoid running into problems with invalid certificates, consider the following
sections.</p>
</div>
<div class="sect3">
<h4 id="_using_trusted_certificates_2">Using trusted certificates</h4>
<div class="paragraph">
<p>If possible, always use a certificate issued by a well-known, trusted CA for
your server. Most programming environments come with a predefined list of
trusted root CAs, and certificates issued by these authorities are validated
automatically. This is the best practice, and it requires no additional code or
configuration.</p>
</div>
</div>
<div class="sect3">
<h4 id="_working_with_self_signed_certificates_or_non_standard_cas_2">Working with self-signed certificates or non-standard CAs</h4>
<div class="paragraph">
<p>In some cases, you might need to work with a server using a self-signed
certificate, or a certificate issued by a CA not included in your trusted roots.
Rather than disabling certificate validation in your code, you can add the
necessary certificates to your trust store.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_fix_it_in_webkit">How to fix it in WebKit</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_code_examples_3">Code examples</h3>
<div class="paragraph">
<p>The following code contains examples of disabled certificate validation.</p>
</div>
<div class="paragraph">
<p>Certificate validation is bypassed when <code>webView(_:didReceive:completionHandler:)</code> from the <code>WKNavigationDelegate</code> protocol is implemented to unconditionally trust the <code>serverTrust</code> from a <code>URLAuthenticationChallenge</code>.</p>
</div>
<div class="paragraph">
<p>This means that even if a certificate is initially rejected by the system, the <code>WKWebView</code> will accept it, regardless of its origin.</p>
</div>
<div class="sect3">
<h4 id="_noncompliant_code_example_3">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-swift" data-lang="swift">import WebKit

class MyNavigationDelegate: NSObject, WKNavigationDelegate {
    func webView(_ webView: WKWebView, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -&gt; Void) {
        if challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust {
            if let serverTrust = challenge.protectionSpace.serverTrust {
                // Noncompliant: the server certificate is not validated
                completionHandler(.useCredential, URLCredential(trust: serverTrust))
                return
            }
        }
        completionHandler(.performDefaultHandling, nil)
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution_3">Compliant solution</h4>
<div class="paragraph">
<p>The <code>serverTrust</code> object has to be validated. Based on the validation result, <code>completionHandler</code> should be called with either <code>.useCredential</code> to proceed with the connection, or <code>.cancelAuthenticationChallenge</code> to block it.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-swift" data-lang="swift">import WebKit

class MyNavigationDelegate: NSObject, WKNavigationDelegate {
    func webView(_ webView: WKWebView, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -&gt; Void) {
        if challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust {
            if let serverTrust = challenge.protectionSpace.serverTrust {
                if isServerCertificateValid(serverTrust: serverTrust) {
                    completionHandler(.useCredential, URLCredential(trust: serverTrust))
                } else {
                    completionHandler(.cancelAuthenticationChallenge, nil)
                }
                return
            }
        }
        completionHandler(.performDefaultHandling, nil)
    }

    private func isServerCertificateValid(serverTrust: SecTrust) -&gt; Bool {
        // Implement the server certificate validation logic here.
        // For example, by pinning the certificate.
        var error: CFError?
        let isTrusted = SecTrustEvaluateWithError(serverTrust, &amp;error)
        return isTrusted &amp;&amp; error == nil
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_how_does_this_work_3">How does this work?</h3>
<div class="paragraph">
<p>Addressing the vulnerability of disabled TLS certificate validation primarily
involves re-enabling the default validation.</p>
</div>
<div class="paragraph">
<p>To avoid running into problems with invalid certificates, consider the following
sections.</p>
</div>
<div class="sect3">
<h4 id="_using_trusted_certificates_3">Using trusted certificates</h4>
<div class="paragraph">
<p>If possible, always use a certificate issued by a well-known, trusted CA for
your server. Most programming environments come with a predefined list of
trusted root CAs, and certificates issued by these authorities are validated
automatically. This is the best practice, and it requires no additional code or
configuration.</p>
</div>
</div>
<div class="sect3">
<h4 id="_working_with_self_signed_certificates_or_non_standard_cas_3">Working with self-signed certificates or non-standard CAs</h4>
<div class="paragraph">
<p>In some cases, you might need to work with a server using a self-signed
certificate, or a certificate issued by a CA not included in your trusted roots.
Rather than disabling certificate validation in your code, you can add the
necessary certificates to your trust store.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_standards">Standards</h3>
<div class="ulist">
<ul>
<li>
<p>OWASP - <a href="https://owasp.org/Top10/A02_2021-Cryptographic_Failures/">Top 10 2021 Category A2 - Cryptographic Failures</a></p>
</li>
<li>
<p>OWASP - <a href="https://owasp.org/Top10/A05_2021-Security_Misconfiguration/">Top 10 2021 Category A5 - Security Misconfiguration</a></p>
</li>
<li>
<p>OWASP - <a href="https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures/">Top 10 2021 Category A7 - Identification and Authentication Failures</a></p>
</li>
<li>
<p>OWASP - <a href="https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure">Top 10 2017 Category A3 - Sensitive Data Exposure</a></p>
</li>
<li>
<p>OWASP - <a href="https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration">Top 10 2017 Category A6 - Security Misconfiguration</a></p>
</li>
<li>
<p>OWASP - <a href="https://owasp.org/www-project-mobile-top-10/2016-risks/m3-insecure-communication">Mobile Top 10 2016 Category M3 - Insecure Communication</a></p>
</li>
<li>
<p>OWASP - <a href="https://owasp.org/www-project-mobile-top-10/2023-risks/m5-insecure-communication">Mobile Top 10 2024 Category M5 - Insecure Communication</a></p>
</li>
<li>
<p>OWASP - <a href="https://mas.owasp.org/checklists/MASVS-NETWORK/">Mobile AppSec Verification Standard - Network Communication Requirements</a></p>
</li>
<li>
<p>CWE - <a href="https://cwe.mitre.org/data/definitions/295">CWE-295 - Improper Certificate Validation</a></p>
</li>
<li>
<p>STIG Viewer - <a href="https://stigviewer.com/stigs/application_security_and_development/2024-12-06/finding/V-222550">Application Security and Development: V-222550</a> - The application must validate certificates by constructing a certification path to an accepted trust anchor.</p>
</li>
<li>
<p>Apple Developer Documentation - <a href="https://developer.apple.com/documentation/foundation/performing-manual-server-trust-authentication?language=swift">Performing manual server trust authentication</a></p>
</li>
</ul>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_implementation_specification">Implementation Specification</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_message">Message</h3>
<div class="paragraph">
<p>Enable server certificate validation on this SSL/TLS connection.</p>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_comments_and_links">Comments And Links</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_deprecates_s4424">deprecates: <a data-rspec-id="S4424" class="rspec-auto-link">S4424</a></h3>

</div>
<div class="sect2">
<h3 id="_deprecates_s5326">deprecates: <a data-rspec-id="S5326" class="rspec-auto-link">S5326</a></h3>

</div>
<div class="sect2">
<h3 id="_relates_to_s5527">relates to: <a data-rspec-id="S5527" class="rspec-auto-link">S5527</a></h3>

</div>
</div>
</div>