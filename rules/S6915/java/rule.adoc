== Why is this an issue?

Java 21 adds new `String.indexOf` methods that accept ranges (`beginIndex`, to `endIndex`) rather than just a start index.
If `beginIndex > endIndex`, these methods throw a `StringIndexOutOfBounds`, indicating an invalid range.
This can occur if the `beginIndex` and `endIndex` arguments are mistakenly reversed.

Note that the method variant with `beginIndex` and `endIndex` arguments is not a general substitute for the variant with a `fromIndex` argument,
but only when we don't want to scan the string until the last character.

== How to fix it

- Use `String.indexOf(what, beginIndex, endIndex)` instead of `String.indexOf(what, endIndex, beginIndex)`.
- If `endIndex` is the same as `what.length`, use `String.indexOf(what, beginIndex)` instead.
- If, in addition `endIndex` is 0, use `String.indexOf(what)` instead.

=== Code examples

==== Noncompliant code example

[source,java,diff-id=1,diff-type=noncompliant]
----
String hello = "Hello, world!";
int index = hello.indexOf('o', 11, 7); // Noncompliant, 11..7 is not a valid range
----

==== Compliant solution

[source,java,diff-id=1,diff-type=compliant]
----
String hello = "Hello, world!";
int index = hello.indexOf('o', 7, 11); // Compliant
----

==== Noncompliant code example

[source,java,diff-id=2,diff-type=noncompliant]
----
int index = hello.indexOf('o', 7, hello.length()); // Noncompliant, use hello.indexOf('0', 7)
----

==== Compliant solution

[source,java,diff-id=2,diff-type=compliant]
----
int index = hello.indexOf('o', 7); // Compliant
----

==== Noncompliant code example

[source,java,diff-id=3,diff-type=noncompliant]
----
int index = hello.indexOf('o', 0); // Noncompliant, use hello.indexOf('0')
----

==== Compliant solution

[source,java,diff-id=3,diff-type=compliant]
----
int index = hello.indexOf('o'); // Compliant
----

== Resources

* Java Documentation - https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/String.html#indexOf(int,int,int)[String.indexOf]


