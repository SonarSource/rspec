This rule raises an issue when the traditional `[` command (or `test` command) is used for conditional tests in Bash scripts, unless POSIX compatibility is explicitly required.

== Why is this an issue?

The traditional `[` command (also known as `test`) is an external command that treats its arguments as separate words, making it vulnerable to word splitting and pathname expansion issues. This can lead to unexpected behavior when variables contain spaces, special characters, or when filenames match glob patterns.

The modern `[[` construct is part of Bash syntax rather than a separate command. This means:

* Word splitting and pathname expansion do not occur within `[[ ]]`, making it more robust when handling variables that might contain spaces or special characters
* It provides better error handling and more predictable behavior
* It offers additional features like regular expression matching with the `=~` operator
* It's generally faster since it doesn't require spawning an external process

Using `[` can cause subtle bugs that are difficult to debug, especially when dealing with user input, filenames, or variables that might be empty or contain unexpected characters.

=== What is the potential impact?

Using the traditional `[` command instead of `[[` can lead to script failures or unexpected behavior when:

* Variables contain spaces, tabs, or newlines
* Filenames contain special characters or match glob patterns
* Variables are empty or unset

These issues can cause scripts to behave unpredictably in production environments, potentially leading to data loss, security vulnerabilities, or system instability.

== How to fix it

Replace the traditional `[` command with the modern `[[` construct. Update both the opening and closing brackets, and ensure proper spacing.

=== Code examples

==== Noncompliant code example

[source,bash,diff-id=1,diff-type=noncompliant]
----
if [ -z "$str" ]; then  # Noncompliant
  echo "empty"
fi

if [ "$var" = "value" ]; then  # Noncompliant
  echo "match"
fi
----

==== Compliant solution

[source,bash,diff-id=1,diff-type=compliant]
----
if [[ -z "$str" ]]; then
  echo "empty"
fi

if [[ "$var" = "value" ]]; then
  echo "match"
fi
----

== Resources

=== Documentation

 * Bash Manual - Conditional Constructs - https://www.gnu.org/software/bash/manual/html_node/Conditional-Constructs.html[Official Bash manual section on conditional constructs including [[ ]]]
 * LinuxCommand.org - Bash Coding Standards - https://linuxcommand.org/lc3_adv_standards.php[Comprehensive Bash scripting coding standards and best practices]

=== Standards

 * POSIX.1-2017 - Shell Command Language - https://pubs.opengroup.org/onlinepubs/9699919799/utilities/test.html[POSIX specification for the test command and conditional expressions]

