This rule raises an issue when a shell script executes a command without checking its exit code, potentially allowing the script to continue even when the command fails.

== Why is this an issue?

In shell scripts, commands can fail for various reasons: missing files, insufficient permissions, network issues, or invalid arguments. When a command fails, it returns a non-zero exit code to indicate the failure.

By default, shell scripts continue executing subsequent commands even when a previous command fails. This behavior can lead to several problems:

* **Silent failures**: Critical operations may fail without the script or user being aware of it
* **Cascading errors**: Later commands may operate on invalid or missing data from failed earlier commands
* **Inconsistent state**: The system may be left in an unexpected or corrupted state
* **Difficult debugging**: Issues may only surface much later, making it hard to trace back to the original failure

For example, if a script fails to download a file but continues to process it, the processing will likely fail in unexpected ways. Or if a database backup command fails but the script continues to delete old backups, you might lose data without realizing the new backup never completed.

Proper exit code checking allows scripts to detect failures immediately and take appropriate action, such as logging errors, cleaning up resources, or terminating execution safely.

=== What is the potential impact?

Scripts may continue executing after critical commands fail, leading to data corruption, incomplete operations, or systems being left in inconsistent states. This can result in production outages, data loss, or security vulnerabilities that are difficult to diagnose.

=== How to fix?


Check the exit code using the special variable `$?` immediately after the command. Use an if statement to handle failures appropriately.

==== Non-compliant code example

[source,bash,diff-id=1,diff-type=noncompliant]
----
#!/bin/bash
cp important_file.txt /backup/
echo "Backup completed successfully"
----

==== Compliant code example

[source,bash,diff-id=1,diff-type=compliant]
----
#!/bin/bash
cp important_file.txt /backup/
if [ $? -ne 0 ]; then
    echo "Error: Failed to backup important_file.txt"
    exit 1
fi
echo "Backup completed successfully"
----

=== Documentation

 * Bash Manual - Exit Status - https://www.gnu.org/software/bash/manual/html_node/Exit-Status.html[Official documentation on exit status handling in Bash]
 * Advanced Bash-Scripting Guide - Exit Codes - https://tldp.org/LDP/abs/html/exit-status.html[Comprehensive guide to exit codes and error handling in shell scripts]
 * ShellCheck Wiki - Error Handling - https://github.com/koalaman/shellcheck/wiki/Checks#error-handling[Best practices for error handling in shell scripts]

=== Standards

 * CWE-754: Improper Check for Unusual or Exceptional Conditions - https://cwe.mitre.org/data/definitions/754.html[Failure to properly handle exceptional conditions can lead to unexpected behavior]

