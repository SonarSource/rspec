This rule will suggest using DateTimeOffset instead of DateTime on projects targetting .NET Framework 2.0 or later.

== Why is this an issue?

The DateTimeOffset type includes all the functionality of the DateTime type and also includes the time offset from Coordinated Universal Time (UTC). It is the preferred alternative to the DateTime object for avoiding many of the potential problems, without relying on third-party solutions.
DateTimeOffset represents a point in time, typically expressed as a date and time of day, relative to UTC. It provides a greater degree of time zone awareness than the DateTime structure.

However, it's important to note that although DateTimeOffset contains more information than DateTime by storing the offset to UTC, it isn't tied to a specific time zone, and it doesn't reflect the actual time zone to which that offset belongs. This information must be stored separately to have a full picture of the moment in time.

Since the problems of DateTime were recognized early, a better alternative in the form of DateTimeOffset was introduced, and it has been the recommended variant since .NET 1.1. 
Despite this, developers often use DateTime (sometimes only because it appears earlier in IntelliSense), despite its numerous limitations and potential for errors.

== How to fix it
You can refer to Microsoft Documentation to learn how to convert DateTime to DateTimeOffset succesfully. 
Generically speaking, to migrate code to use DateTimeOffset, you can replace the DateTime variables with DateTimeOffset variables and use the DateTimeOffset properties.

Keep in mind that DateTimeOffset includes the time zone offset, whereas DateTime does not, so you may need to update any code that relies on the time zone to use the appropriate DateTimeOffset methods instead.

=== Code examples

==== Noncompliant code example

[source,csharp]
----
DateTime myDate = new DateTime(2008, 6, 19, 7, 0, 0); // Noncompliant
myDate = DateTime.SpecifyKind(myDate, DateTimeKind.Local); 
----

==== Compliant solution

[source,csharp]
----
DateTimeOffset myDate = new DateTimeOffset(2008, 6, 19, 7, 0, 0, TimeSpan.FromHours(-7)); // Compliant
----

=== Pitfalls
Common DateTime pitfalls include:

- When working with DateTime of kind Unknown, calling ToUniversalTime() presumes the DateTime.Kind is local and converts to UTC. When calling ToLocalTime(), it presumes the DateTime.Kind is universal and converts that to local. If you call ToUniversalTime(), it converts X hours in one direction, but if you call ToLocalTime() on it, it converts X hours in the opposite direction. Neither of these conversions can be considered correct.
- Once a comparison is done between two DateTimes, the user needs to ensure they are within the same time zone. DateTime doesnâ€™t consider UTC/Local when doing comparisons; it only cares about the number of Ticks on the objects.

== Resources

=== Documentation

- https://learn.microsoft.com/en-us/dotnet/standard/datetime/converting-between-datetime-and-offset?redirectedfrom=MSDN
- https://learn.microsoft.com/en-us/dotnet/standard/datetime/choosing-between-datetime
- https://learn.microsoft.com/en-us/dotnet/standard/datetime/performing-arithmetic-operations

=== Articles & blog posts

- https://blog.submain.com/4-common-datetime-mistakes-c-avoid/
- https://database.guide/datetime2-vs-datetimeoffset-in-sql-server-whats-the-difference/
