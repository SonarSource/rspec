<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Variables should be initialized before their use to avoid unexpected
behavior due to garbage values.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A local variable of any built-in type (such as <code>int</code>, <code>float</code>, and pointers),
declared without an initial value is not initialized to any particular value.
Consequently, if no value is assigned to such a variable first, the code that
uses it has no defined behavior.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">int addition() {
  int x;  // x is not initialized
  return x + 10; // Noncompliant: x has grabage value
}

int dereference() {
  int* p; // p is not initialized
  return *p; // Noncompliant: p has garbage value
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Similarly, structures that simply aggregate variables of built-in types, such as arrays or <code>struct</code>/<code>class</code>
types without a constructor, will not initialize their members when declared without
an initializer:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">struct Aggregate {
  int i;
  float f;
};

void aggregates() {
  int* intArray[5]; // each element of array is not initializer
  Aggregate aggr; // members aggr.i, agrr.f are not initialized
  Aggregate aggrArray[2]; // members of each element are not initialized
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, allocating objects of builtin or such aggregates types on the heap,
also does not initialize their values:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">void usingMalloc() {
  int* intArr = (int*)malloc(sizeof(int) * 10); // each of 10 allocated integers is not initialized
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This also applies when <code>new</code> is used in C&#43;&#43;:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">void usingNew() {
  Aggregate* aggrPtr = new Aggregate; // members of allocated Aggregate are not initialized
  Aggregate* aggrArr = new Aggregate[5]; // members of each of 5 Aggregate objects are not initialized
}</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_what_is_the_potential_impact">What is the potential impact?</h3>
<div class="paragraph">
<p>Using garbage values will cause the program to behave
nondeterministically at runtime.
The program may produce a different output or crash depending on the run.</p>
</div>
<div class="paragraph">
<p>In some situations, loading a variable may expose sensitive data,
such as a password that was previously stored in the same location,
leading to a vulnerability that uses such a defect
as a gadget for extracting information from the instance
of the program.</p>
</div>
<div class="paragraph">
<p>Finally, in C&#43;&#43;, outside of a few exceptions related to the uses of <code>unsigned char</code> or <code>std::byte</code>,
loading data from an uninitialized variable causes undefined behavior.
This means that the compiler is not bound by the language standard anymore,
and the program has no meaning assigned to it.
As a consequence,
the impact of such a defect is not limited to the use of garbage values.</p>
</div>
</div>
<div class="sect2">
<h3 id="_why_is_there_an_issue_for_a_class_with_a_default_constructor">Why is there an issue for a class with a default constructor?</h3>
<div class="paragraph">
<p>In C&#43;&#43;, a class can define a default constructor invoked when an
object of the given type is created. Such a constructor is called even
if a variable is declared without any initializer.
However, if the constructor code omits the initialization
of a member that itself does not have the default constructor,
the member will remain uninitialized  (See also <a data-rspec-id="S2107" class="rspec-auto-link">S2107</a>). And reading
from it will produce a garbage value:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">struct Partial {
  // x is not initialized
  Partial() : y(10.0) {}

  int x;
  float y;
};

int initialized() {
  Partial p; // constructor is called
  // or even Partial p{};
  return p.x; // Non-compliant: reading an uninitialized variable
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_exceptions">Exceptions</h3>
<div class="paragraph">
<p>This rule does not flag the variables with static storage duration, meaning:
global, static, and thread-local variables.</p>
</div>
<div class="paragraph">
<p>All the variables with static storage duration are zero-initialized before the initializer is evaluated.
As a consequence, any variable or member of such an object has a defined value even if no initializer is specified.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">int globInt;
int globTab[10];
Aggregate globAggr;
Partial globPart; // x member is zero-initialized

int uses() {
  static int staticInt;
  return globInt     // Compliant: all zero-initialized
       + globTab[2]
       + globAggr.f
       + globPart.x
       + staticInt;
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_fix_it">How to fix it</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Commonly, the use of an uninitialized object is an indication of a defect in the
code, where either variable initialization was skipped on some code paths, or
the object is used by mistake. Generally, you can address such problems by:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Initializing variables on the declaration with a valid value</p>
</li>
<li>
<p>Assigning to the variable on the code path(s) that was missing initialization</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Whenever possible, it is preferable to initialize a variable with its final
value on the declaration, as this eliminates the possibility of this defect
occurring.</p>
</div>
<div class="sect2">
<h3 id="_code_examples">Code examples</h3>
<div class="sect3">
<h4 id="_noncompliant_code_example">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">int function(int flag, int b) {
  int a;
  if (flag) {
    a = b;
  }
  return a; // Noncompliant: "a" has not been initialized in all paths
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution">Compliant solution</h4>
<div class="paragraph">
<p>Initializing variable on all code paths:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">int function(int flag, int b) {
  int a;
  if (flag) {
    a = b;
  } else {
    a = 10;
  }
  return a; // Compliant
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Skipping path that leads to the read of an uninitialized value:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">int function(int flag, int b) {
  int a;
  if (flag) {
    a = b;
  } else {
    return 10;
  }
  return a; // Compliant
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Providing a valid initial value:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">int function(int flag, int b) {
  int a = 10;
  if (flag) {
    a = b;
  }
  return a; // Compliant
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Initializing value in the definition:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">int function(int flag, int b) {
  int const a = flag ? b : 10;
  return a; // Compliant
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_pitfalls">Pitfalls</h3>
<div class="paragraph">
<p>Initializing the variable to zero at the declaration is not always the right
solution to fix the issue, as it may lead to logic errors if such a value
is not handled correctly. For example, setting an <code>age</code> field of an <code>Employee</code>
structure may break assumptions of retirement handling code. Or more commonly,
setting a pointer to <code>NULL</code> will turn dereference of an uninitialized value
into a null-pointer dereference.</p>
</div>
</div>
<div class="sect2">
<h3 id="_going_the_extra_mile">Going the extra mile</h3>
<div class="paragraph">
<p>With the addition of lambdas in C&#43;&#43;11, it is possible to initialize
variables on declaration without creating a separate function
to compute the value:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">int x = [&amp;] { // capture all context by reference
  if (someCondition())
    return computeVar1();
  /* perform more computations */
  return other;
}(); // invoke the lambda immediately (right after creation)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Such pattern is referred to as an <em>Immediately invoked function expression</em>
(IIFE) or <em>Imediately invoked lambda</em>.
Furthermore, with the addition of structured binding in C&#43;&#43;17, it is
possible to declare multiple variables whose values are coupled:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">auto [px, py, pz] = [&amp;] {
  if (x_dir) {
    return std::make_tuple(1, 0, 0);
  } else if (y_dir) {
    return std::make_tuple(0, 1, 0);
  } else {
    assert(z_dir);
    return std::make_tuple(0, 0, 1);
  }
}();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_documentation">Documentation</h3>
<div class="ulist">
<ul>
<li>
<p>C&#43;&#43; reference - <a href="https://en.cppreference.com/w/cpp/language/storage_duration">Storage class specifiers</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_external_coding_guidelines">External coding guidelines</h3>
<div class="ulist">
<ul>
<li>
<p>CWE - <a href="https://cwe.mitre.org/data/definitions/457">CWE-457 Use of Uninitialized Variable</a></p>
</li>
<li>
<p>MISRA C:2004, 9.1 - All automatic variables shall have been assigned a value before being used.</p>
</li>
<li>
<p>MISRA C&#43;&#43;:2008, 8-5-1 - All variables shall have a defined value before they are used.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_related_rules">Related rules</h3>
<div class="ulist">
<ul>
<li>
<p><a data-rspec-id="S2107" class="rspec-auto-link">S2107</a> detects fields being left uninitialized after the invocation of a constructor</p>
</li>
</ul>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_implementation_specification">Implementation Specification</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_message">Message</h3>
<div class="paragraph">
<p>Review the data-flow - possible use of uninitialized value.</p>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_comments_and_links">Comments And Links</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_is_related_to_s5523">is related to: <a data-rspec-id="S5523" class="rspec-auto-link">S5523</a></h3>

</div>
<div class="sect2">
<h3 id="_relates_to_s1258">relates to: <a data-rspec-id="S1258" class="rspec-auto-link">S1258</a></h3>

</div>
<div class="sect2">
<h3 id="_on_16_oct_2014_142021_ann_campbell_wrote">on 16 Oct 2014, 14:20:21 Ann Campbell wrote:</h3>
<div class="paragraph">
<p>\[~samuel.mercier] please provide a text description.</p>
</div>
</div>
<div class="sect2">
<h3 id="_on_16_oct_2014_142134_ann_campbell_wrote">on 16 Oct 2014, 14:21:34 Ann Campbell wrote:</h3>
<div class="paragraph">
<p>\[~freddy.mallet] see <a data-rspec-id="S1988" class="rspec-auto-link">RSPEC-1988</a>, which cites 3 CWE and 2 CERT rules</p>
</div>
</div>
<div class="sect2">
<h3 id="_on_14_jun_2016_091552_freddy_mallet_wrote">on 14 Jun 2016, 09:15:52 Freddy Mallet wrote:</h3>
<div class="paragraph">
<p>This rule seems to be also valuable in PHP, see http://php.vrana.cz/variable-initialization-in-php.php and https://code.google.com/archive/p/php-initialized/</p>
</div>
</div>
<div class="sect2">
<h3 id="_on_14_jun_2016_092301_freddy_mallet_wrote">on 14 Jun 2016, 09:23:01 Freddy Mallet wrote:</h3>
<div class="paragraph">
<p>And I have the feeling that even in Java or C# for instance for which the default values of primitive types is known, this is a kind of reliability issue to rely on some paths on the those default values. (cc [~ann.campbell.2])</p>
</div>
<div class="paragraph">
<p>Example in Java :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>public int compute(Strong something){
  int returnValue;
  if(something.equals("foo")) {
    returnValue = 4;
  }
  return returnValue;
}</pre>
</div>
</div>
</div>
</div>
</div>