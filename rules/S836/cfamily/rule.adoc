Variables should be initialized before their use to avoid unexpected
behaviors due to garbage values.

== Why is this an issue?

A local variable of the built-in type (like `int`, `float`, and also pointers),
declared without initial value, is not initialized to any particular value.
Consequently, code that uses such a variable without previously assigned to
them does not have defined behavior. For example:

[source,cpp]
----
int addition() {
  int x;  // x is not initialized
  return x + 10; // Noncompliant: x have grabage value
}

int derefence() {
  int* p; // p is not initialized
  return *p; // Noncompliant: p have garbage value
}
----

Similarly, structures that aggregate such variables, such as arrays or `struct`/`class`
types without a constructor, will not initialize thier members, when declared without
an initializer:

[source,cpp]
----
struct Aggregate {
  int i;
  float f;
};

void aggregates() {
  int* intArray[5]; // each element of array is not initializer
  Aggregate aggr; // members aggr.i, agrr.f are not initialized
  Aggregate aggrArray[2]; // members of each element are not initialied
}
----

Finally, allocatign objects of such builtin or aggregates types on heap, also does not
initialize their values:

[source,c]
----
void usingMalloc() {
  int* intArr = (int*)malloc(sizeof(int) * 10); // each of 10 allocated integers is not initialized
}
----

This also applies when `new` is used in `C++`:

[source,cpp]
----
void usingNew() {
  Aggregate* aggrPtr = new Aggregate; // members of allocated Aggregate are not initialized
  Aggregate* aggrArr = new Aggregate[5]; // members of each of 5 Aggregate objects are not initialized
}
----


=== What is the potential impact?

In the best-case scenario, using garbage value will cause the
program to behave non-deterministically at runtime.
The program may produce a different output or crash depending
on the run.

In some situations, loading a variable may expose a sensitive
data, like a password, that was previously stored in the same
location. Leading to vulnerability, where such defect
is used as a gadget for extracting information from the instance
of the program.

Finally, in {cpp}, outside a few exceptions related to the uses
of `unsinged char` or `std::byte`, loading data from an uninitialized
variable causes undefined behavior. This means that the compiler
is not bound by the language standard anymore, and the program
has no meaning assigned to it. As a consequence, the impact
of such a defect is not limited to uses of random value.


=== Why is the issue for class with default constructor?

In {cpp}, a class can define a default constructor invoked when an
object of given type is created. Such a constructor is called even
if the variable is declared without any initializer.
However, if the constructor code omits the initialization
of the member, which itself does not have the default constructor
, such a member will remain uninitialized. And reading
from it will produce garbage value:

[source,cpp]
----
struct Partial {
  // x is not initialized
  Partial() : y(10.0) {}

  int x;
  float y;
};

void initialized() {
  Partial p; // constructor is called
  // or even Partial p{};
  return p.x; // Non-complaint: reading uninitialized variable
}
----


=== Exceptions: global, static and thread local variables.

All the variables with static storage duration, meaning global, static,
or thread-local variables, are zero-initialized before the initializer
is evaluated. As consequence any such variable or member of such
object has a defined value, even if no initializer is specified.

[source,cpp]
----
int globInt;
int globTab[10];
Aggregate globAggr;
Partial globPart; // x member is zero-initialized

void uses() {
  static int staticInt;
  return globInt     // Compliant: all zero initialized
       + globTab[2]
       + globAggr.f
       + globPart.x
       + staticInt;
}
----

== How to fix it

Commonly, the use of an uninitialized object is an indication of a defect in code,
where either variable initialization was skipped on some code paths, or
the object is used by mistake. Generally, such problems can be addressed by:

* Initializing variable on the declaration with valid value
* Assigning to the variable on the code path(s) that was missing initialization

Whenever possible, it is preferable to initialize a variable with its final
value on the declaration, as this eliminates possiblity of this defect occuring.

=== Code examples

==== Noncompliant code example

[source,cpp,diff-id=1,diff-type=noncompliant]
----
int function(int flag, int b) {
  int a;
  if (flag) {
    a = b;
  }
  return a; // Noncompliant: "a" has not been initialized in all paths
}
----

==== Compliant solution

Initializing variable in all code paths:

[source,c,diff-id=1,diff-type=compliant]
----
int function(int flag, int b) {
  int a;
  if (flag) {
    a = b;
  } else {
    a = 10;
  }
  return a; // Complaint
}
----

Skipping path that leads to read of uninitialized value:

[source,c,diff-id=1,diff-type=compliant]
----
int function(int flag, int b) {
  int a;
  if (flag) {
    a = b;
  } else {
    return 10;
  }
  return a; // Complaint
}
----

Providing valid initial value:

[source,cpp]
----
int function(int flag, int b) {
  int a = 10;
  if (flag) {
    a = b;
  }
  return a; // Complaint
}
----

Initializing value in the defintion:

[source,cpp]
----
int function(int flag, int b) {
  int const a = flag ? b : 10;
  return a; // Complaint
}
----

=== Going the extra mile

With the addition of lambda in {cpp}11, it is possible to initialize
variable on declaration without creating a separate function
to compute value:

[source,cpp]
----
int x = [&] { // capture all context by reference
  if (someCondition())
    return computeVar1();
  /* peform more computations */
  return other;
}(); // invoke lambda just (immediately)  after creation
----

Such pattern is referred as _Immediately invoked function expression_
(IIFE) or _Imediately invoked lambda_.
Furthermore, with the addition of structured binding in {cpp}17, it is
possible to declare multiple variables whose values are coupled:

[source,cpp]
----
auto [px, py. pz] = [&] {
  if (x_dir) {
    return std::make_tuple(1.0, 0, 0);
  } else if (y_dir) {
    return std::make_tuple(0, 1.0, 0);
  } else {
    assert(z_dir);
    return std::make_tuple(0, 0, 1.0);
  }
}();
----

== Resources

=== Documentation

- C++ reference - https://en.cppreference.com/w/cpp/language/storage_duration[Storage class specifiers]

=== External coding guidelines

* https://cwe.mitre.org/data/definitions/457[MITRE, CWE-457] - Use of Uninitialized Variable
* MISRA C:2004, 9.1 - All automatic variables shall have been assigned a value before being used.
* MISRA {cpp}:2008, 8-5-1 - All variables shall have a defined value before they are used.

=== Related rules

* S2107 detect fields being left uninitialized after invocation of constructor


ifdef::env-github,rspecator-view[]

'''
== Implementation Specification
(visible only on this page)

=== Message

Review the data-flow - possible use of uninitialized value.


'''
== Comments And Links
(visible only on this page)

include::../comments-and-links.adoc[]

endif::env-github,rspecator-view[]
