The `@DirtiesContext` annotation configuration should make sense with the appropriate mode for the target scope.

== Why is this an issue?

The `@DirtiesContext` annotation marks the ApplicationContext as dirty and indicates that it should be cleared and recreated. 
This is important in tests that modify the context, such as altering the state of singleton beans or databases. 

Misconfiguring `@DirtiesContext` by selecting incorrect `classMode` and `methodMode` values will make the annotation have no effect. 
Setting the `methodMode` at the class level or the `classMode` at the method level does not have meaning and will not trigger the expected behavior.

This rule will raise an issue when the incorrect mode is configured on a @DirtiesContext annotation targeting a different scope.

== How to fix it

=== Code examples

==== Noncompliant code example

[source,java,diff-id=1,diff-type=noncompliant]
----
@ContextConfiguration
@DirtiesContext(methodMode = MethodMode.AFTER_METHOD) // Noncompliant, for class-level control, use classMode instead.
public class TestClass {
  @DirtiesContext(classMode = DirtiesContext.ClassMode.AFTER_CLASS) // Non compliant, for method-level control use methodMode instead
  public void test() {...}
}
----

==== Compliant solution

[source,java,diff-id=1,diff-type=compliant]
----
@ContextConfiguration
@DirtiesContext(classMode = DirtiesContext.ClassMode.AFTER_CLASS)
public class TestClass {
  @DirtiesContext(methodMode = MethodMode.AFTER_METHOD)
  public void test() {...}
}
----

== Resources

=== Documentation

* Spring documentation - https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/test/annotation/DirtiesContext.html[@DirtiesContext]