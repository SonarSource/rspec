This rule raises an issue when an Angular lifecycle method is declared but contains no implementation (empty body).

== Why is this an issue?

Angular lifecycle methods are special hooks that Angular calls at specific points in a component's or directive's lifecycle. When these methods are declared but left empty, they create several problems:

**Code Clarity Issues**

Empty lifecycle methods can confuse other developers. When someone sees a lifecycle method like `ngOnInit()` or `ngOnDestroy()`, they expect it to perform some initialization or cleanup logic. An empty method suggests that functionality was planned but never implemented, or that it was implemented and later removed.

**Unnecessary Performance Overhead**

Angular's change detection mechanism will still call empty lifecycle methods during the component lifecycle. While the performance impact is minimal for individual methods, it can add up in applications with many components that declare unnecessary empty lifecycle methods.

**Code Maintenance Burden**

Empty methods add visual noise to your codebase. They make classes longer and can distract from the actual business logic. During code reviews, developers might spend time wondering whether these empty methods are intentional placeholders or forgotten implementations.

**Interface Implementation Confusion**

Some developers mistakenly believe they must implement all lifecycle methods when implementing Angular interfaces like `OnInit` or `OnDestroy`. However, TypeScript interfaces only require you to implement methods you actually need.

=== What is the potential impact?

The impact is primarily on code maintainability and readability. Empty lifecycle methods create confusion about developer intent and add unnecessary visual clutter. There is also a minor performance impact as Angular will still invoke these empty methods during the component lifecycle.

=== How to fix in Angular?

Remove the empty lifecycle method entirely. If you're implementing a lifecycle interface, you only need to implement the methods you actually use.

==== Non-compliant code example

[source,typescript,diff-id=1,diff-type=noncompliant]
----
@Component()
class MyComponent implements OnInit {
  ngOnInit() {} // Noncompliant
}
----

==== Compliant code example

[source,typescript,diff-id=1,diff-type=compliant]
----
@Component()
class MyComponent {
  // No empty ngOnInit method needed
}
----

If you need the lifecycle method for future implementation, add a comment explaining the intention and implement the actual logic.

==== Non-compliant code example

[source,typescript,diff-id=2,diff-type=noncompliant]
----
@Component()
class MyComponent implements OnDestroy {
  ngOnDestroy() {} // Noncompliant
}
----

==== Compliant code example

[source,typescript,diff-id=2,diff-type=compliant]
----
@Component()
class MyComponent implements OnDestroy {
  ngOnDestroy() {
    // Clean up subscriptions
    this.subscription?.unsubscribe();
  }
}
----

Remove both the empty method and the unnecessary interface implementation if no lifecycle logic is needed.

==== Non-compliant code example

[source,typescript,diff-id=3,diff-type=noncompliant]
----
@Directive()
class MyDirective implements OnInit, OnDestroy {
  ngOnInit() {} // Noncompliant
  
  ngOnDestroy() {
    this.cleanup();
  }
}
----

==== Compliant code example

[source,typescript,diff-id=3,diff-type=compliant]
----
@Directive()
class MyDirective implements OnDestroy {
  ngOnDestroy() {
    this.cleanup();
  }
}
----

=== Documentation

 * Angular Lifecycle Hooks Guide - https://angular.io/guide/lifecycle-hooks[Official Angular documentation explaining lifecycle hooks and when to use them]
 * Angular Component Lifecycle - https://angular.io/guide/components/lifecycle[Detailed guide on Angular component lifecycle methods]

=== Related Rules

 * RSPEC-1186 - https://rules.sonarsource.com/javascript/RSPEC-1186/[Methods should not be empty]

