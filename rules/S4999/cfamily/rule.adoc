== Why is this an issue?

The behavior is undefined when `memcpy`, `memmove`, or `memset` are invoked with objects of non-trivially copyable types.

Trivially copyable types include:

 * scalar types
 * trivially copyable classes
 * arrays of these types
// Ignoring cv-qualified versions of these types here for brevity.

A class is trivially copyable when:

 * all its non-static data members and base classes are trivially copyable types,
 * it has no virtual functions or base classes,
 * its destructor is trival,
 * and one or more of the following special member functions is trivial, and the rest are deleted: copy constructor, move constructor, copy assignment operator, and move assignment operator.

_Note: a default implementation, either explicit (with `= default`) or implicit (if the special member function is omitted), is considered trivial._

=== How to fix it

`memcpy`, `memmove`, and `memset` should only be called on trivially-copyable objects.
Fixing this code defect may require non-trivial refactoring, as illustrated in the following example.

=== Noncompliant code example

Here, `copy` is incorrect because it calls `memcpy` on non-trivial objects.

[source,cpp,diff-id=1,diff-type=noncompliant]
----
class Resource {
  Handle* resource_handle;

public:
  Resource() {
    // Acquire the resource handle.
  }

  ~Resource() {
    // Release the resource handle.
  }
};

void copy(Resource* dest, Resource const* source) {
  memcpy(dest, source, sizeof(Resource)); // Noncompliant
}
----

=== Compliant solution

Instead, the `Resource` class can provide a copy assignment operator.

[source,cpp,diff-id=1,diff-type=compliant]
----
class Resource {
  Handle* resource_handle;

public:
  Resource() {
    // Acquire the resource handle.
  }

  ~Resource() {
    // Release the resource handle.
  }

  Resource& operator=(Resource const& other) {
    // Non-trivial copy assignement:
    // copy the handle and update the reference count, etc...
  }
};

void copy(Resource* dest, Resource const* source) {
  (*dest) = (*source);
}
----

== Resources

=== Related rules

* S5000 - "memcmp" should only be called with pointers to trivially copyable types with no padding

ifdef::env-github,rspecator-view[]

'''
== Implementation Specification
(visible only on this page)

=== Message

Use constructors or assignment operators, XXX is not trivially copyable.


'''
== Comments And Links
(visible only on this page)

=== on 6 Nov 2018, 20:32:24 Ann Campbell wrote:
Double-check my changes please, [~loic.joly]

endif::env-github,rspecator-view[]
