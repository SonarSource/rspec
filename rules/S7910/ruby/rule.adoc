This rule raises an issue when lambda functions in configuration contexts perform operations without proper exception handling or state validation.

== Why is this an issue?

Lambda functions used in configuration hashes (such as action handlers, callbacks, or operation definitions) are often executed in runtime contexts where failures can cause user-visible errors or application crashes.

When these lambda functions call methods on objects without defensive programming practices, several problems can occur:

* *Runtime exceptions*: If the underlying method fails (e.g., database constraints, validation errors), the exception propagates up and can crash the application or display error pages to users.
* *Invalid state operations*: Operations performed on records that are not persisted, have missing attributes, or are in invalid states can lead to unexpected behavior or data corruption.
* *Nil reference errors*: When objects or attributes are nil, method calls will raise `NoMethodError` exceptions.

These issues are particularly problematic in configuration contexts because:

* The lambda functions are often called from framework code that may not have proper error handling
* Failures occur during user interactions (like clicking buttons or performing actions)
* The errors may not be immediately obvious during development but surface in production with real data

Defensive programming practices help ensure that lambda functions handle edge cases gracefully and maintain application stability even when underlying operations fail or data is in unexpected states.

=== What is the potential impact?

Runtime failures can cause application crashes, display error pages to users, or result in inconsistent data states. In user-facing features like record ordering or status updates, unhandled exceptions create a poor user experience and may leave the application in an inconsistent state.

== How to fix it

Add exception handling using `rescue` to gracefully handle method failures and return safe default values.

=== Code examples

==== Noncompliant code example

[source,ruby,diff-id=1,diff-type=noncompliant]
----
actions: {
  higher: -> { record.move_higher }, # Noncompliant
  lower: -> { record.move_lower }   # Noncompliant
}
----

==== Compliant solution

[source,ruby,diff-id=1,diff-type=compliant]
----
actions: {
  higher: -> { record.move_higher rescue false },
  lower: -> { record.move_lower rescue false }
}
----

== Resources

=== Documentation

 * Ruby Exception Handling - https://ruby-doc.org/core/doc/syntax/exceptions_rdoc.html[Official Ruby documentation on exception handling with rescue clauses]

 * Safe Navigation Operator - https://ruby-doc.org/core/doc/syntax/calling_methods_rdoc.html#label-Safe+navigation+operator[Documentation on Ruby's safe navigation operator (&.) for handling nil values]
