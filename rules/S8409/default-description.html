<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This is an issue when a FastAPI route decorator includes a <code>response_model</code> parameter that duplicates the function&#8217;s return type annotation.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>FastAPI automatically infers the response model from a function&#8217;s return type annotation. When you specify the same type in both the return annotation and the <code>response_model</code> parameter, you create unnecessary duplication.</p>
</div>
<div class="paragraph">
<p>This duplication has several drawbacks:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Maintenance burden</strong>: When the response type needs to change, you must update it in two places, increasing the risk of inconsistencies.</p>
</li>
<li>
<p><strong>Code verbosity</strong>: The redundant parameter adds visual noise without providing additional value.</p>
</li>
<li>
<p><strong>Confusion</strong>: Developers might wonder if the two specifications serve different purposes or if they should be kept in sync.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>FastAPI&#8217;s automatic inference from return type annotations is the recommended approach. The <code>response_model</code> parameter exists for special cases where you need to override the default behavior, such as when returning a different model internally than what should be serialized in the response.</p>
</div>
<div class="sect2">
<h3 id="_what_is_the_potential_impact">What is the potential impact?</h3>
<div class="paragraph">
<p>This issue affects code maintainability and clarity. While it doesn&#8217;t cause runtime errors or security vulnerabilities, it makes the codebase harder to maintain and understand. Developers may waste time keeping redundant specifications synchronized or debugging issues caused by mismatches between the two declarations.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_fix_it_in_fastapi">How to fix it in FastAPI</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Remove the <code>response_model</code> parameter from the route decorator and rely solely on the function&#8217;s return type annotation. FastAPI will automatically use the return type annotation to generate the response schema and validate the response.</p>
</div>
<div class="sect2">
<h3 id="_code_examples">Code examples</h3>
<div class="sect3">
<h4 id="_noncompliant_code_example">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">@app.post("/items/", response_model=Item)  # Noncompliant
async def create_item(item: Item) -&gt; Item:
    return item</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">@app.post("/items/")
async def create_item(item: Item) -&gt; Item:
    return item</code></pre>
</div>
</div>
<div class="paragraph">
<p>For GET endpoints, the same principle applies. Remove the redundant <code>response_model</code> parameter and let FastAPI infer the response type from the return annotation.</p>
</div>
</div>
<div class="sect3">
<h4 id="_noncompliant_code_example_2">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">@app.get("/users/{user_id}", response_model=User)  # Noncompliant
def get_user(user_id: int) -&gt; User:
    return fetch_user(user_id)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution_2">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">@app.get("/users/{user_id}")
def get_user(user_id: int) -&gt; User:
    return fetch_user(user_id)</code></pre>
</div>
</div>
<div class="paragraph">
<p>When you need to return a different type internally than what should be serialized (a legitimate use case for <code>response_model</code>), keep the <code>response_model</code> parameter. This example shows when <code>response_model</code> is appropriate because the internal return type includes sensitive data that shouldn&#8217;t be exposed.</p>
</div>
</div>
<div class="sect3">
<h4 id="_noncompliant_code_example_3">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">@app.get("/users/{user_id}", response_model=UserPublic)
def get_user(user_id: int) -&gt; UserPublic:  # Noncompliant: types match
    user = fetch_user_with_password(user_id)
    return UserPublic(**user.dict())</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution_3">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">@app.get("/users/{user_id}", response_model=UserPublic)
def get_user(user_id: int) -&gt; UserInternal:
    # Returns UserInternal but serializes as UserPublic
    return fetch_user_with_password(user_id)</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_documentation">Documentation</h3>
<div class="ulist">
<ul>
<li>
<p>FastAPI Documentation - Response Model - <a href="https://fastapi.tiangolo.com/tutorial/response-model/">Official FastAPI documentation explaining response models and return type annotations</a></p>
</li>
<li>
<p>Ruff Rule FAST001 - <a href="https://docs.astral.sh/ruff/rules/fast-api-redundant-response-model/">Ruff linter rule documentation for detecting redundant response_model parameters</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>