== Why is this an issue?

_Type-constraints_ provide a terse way to express constraints on the type deduced for a given template parameter or auto placeholder.
In a situation when a type-constraint is applied to a forwarding reference parameter (`T&&`), the corresponding concept will be checked
against the _lvalue reference_ (if the argument is an _lvalue_) or the plain type (if the argument is an _rvalue_):

[source,cpp]
----
template <SomeConcept T> void func(T&& x);
void f() {
  func(SomeType{});  // Argument is an rvalue -> T is deduced as 'SomeType'
  SomeType obj;
  func(obj);  //  Argument is lvalue -> T is deduced as 'SomeType&'
}
----

Even if it is possible to write `SomeConcept` in a way that works for both plain types and references, it requires a dedicated effort and a
naive attempt may silently fail for one or the other.

Many standard-provided constraints change their behavior when the type is a reference. For instance, a `std::copyable` constraint is never
satisfied for references, regardless of the referenced type, while a `std::copy_constructible` constraint always is. Consider the following
examples:

[source,cpp]
----
template <std::copyable T> void func(T&& t);  // Overload #1.
template <typename T> void func(T&& t);  // Overload #2 (unconstrained).

void f() {
    // Call with an rvalue argument:
    // Calls #1 (no surprise): T is 'std::string', which satisfies 'std::copyable'.
    func(std::string{""});
    // Call with an lvalue argument:
    std::string s{""};
    // Calls #2! T is 'std::string&' which doesn't satisfy 'std::copyable'.
    func(s);
}
----

[source,cpp]
----
template <std::copy_constructible T> void func(T&& t);  // Overload #1.
template <typename T> void func(T&& t);  // Overload #2 (unconstrained).

int main() {
    // Call with an rvalue argument:
    // Calls #2 (no surprise): T is 'std::unique_ptr<int>', which doesn't satisfy 'std::copy_constructible'.
    func(std::make_unique<int>(42));
    // Call with an lvalue argument:
    auto i = std::make_unique<int>(42);
    // Calls #1! T is 'std::unique_ptr<int>&', which satisfies 'std::copy_constructible'.
    func(i);
}
----

Most standard-provided constraints are sensitive to references in their type arguments. On the other hand, the reference in the deduced
type of a forwarding reference is meant to encode information about the value category of the argument in the caller. This rule detects
forwarding reference parameters that are constrained by the standard-provided concepts using _type-constraint_ syntax.

=== Exceptions

The `std::ranges::range` concept and its refinements (like `std::ranges::forward_range`, `std::ranges::bidirectional_range`)
are designed to handle forwarding references parameters, and will not raise issues for this rule.

== How to fix it

Either wrap the deduced type in `std::remove_cvref_t` and apply the standard-provided constraint on the result in a `requires` clause, or
design a custom constraint that works equally for reference and non-reference types (in case you have to deal with this problem often for
a certain constraint).


=== Code examples

==== Noncompliant code example

[source,cpp,diff-id=1,diff-type=noncompliant]
----
auto func(std::copy_constructible auto&& arg)
{ /* … */ }
----
[source,cpp,diff-id=2,diff-type=noncompliant]
----
template<std::copyable T>
auto func2(T&& arg)
{ /* … */ }
----

==== Compliant solution

[source,cpp,diff-id=1,diff-type=compliant]
----
auto func(auto&& arg)
  requires std::copy_constructible<std::remove_cvref_t<decltype(arg)>>
{ /* … */ }
----
[source,cpp,diff-id=2,diff-type=compliant]
----
template<typename T>
  requires std::copyable<std::remove_cvref_t<T>>
auto func2(T&& arg)
{ /* … */ }
----


== Resources

=== Documentation

 * CPP reference - https://en.cppreference.com/w/cpp/language/reference#Forwarding_references[Forwarding references]
 * CPP reference - https://en.cppreference.com/w/cpp/concepts/copy_constructible[`std::copy_constructible` concept]
 * CPP reference - https://en.cppreference.com/w/cpp/concepts/copyable[`std::copyable` concept]