<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>One of the principles of a unit test is that it must have full control of the system under test. This is problematic when production code includes calls to static methods, which cannot be changed or controlled. Date/time functions are usually provided by system libraries as static methods.</p>
</div>
<div class="paragraph">
<p>This can be improved by wrapping the system calls in an object or service that can be controlled inside the unit test.</p>
</div>
<div class="sect2">
<h3 id="_noncompliant_code_example">Noncompliant code example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-csharp" data-lang="csharp">public class Foo
{
    public string HelloTime() =&gt;
        $"Hello at {DateTime.UtcNow}";
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_compliant_solution">Compliant solution</h3>
<div class="paragraph">
<p>There are different approaches to solve this problem. One of them is suggested below. There are also open source libraries (such as NodaTime) which already implement an <code>IClock</code> interface and a <code>FakeClock</code> testing class.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-csharp" data-lang="csharp">public interface IClock
{
    DateTime UtcNow();
}

public class Foo
{
    public string HelloTime(IClock clock) =&gt;
        $"Hello at {clock.UtcNow()}";
}

public class FooTest
{
    public record TestClock(DateTime now) : IClock
    {
        public DateTime UtcNow() =&gt; now;
    }

    [Fact]
    public void HelloTime_Gives_CorrectTime()
    {
        var dateTime = new DateTime(2017, 06, 11);
        Assert.Equal((new Foo()).HelloTime(new TestClock(dateTime)), $"Hello at {dateTime}");
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Another possible solution is using an adaptable static class, ideally supports an IDisposable method, that not only adjusts the time behaviour for the current thread only, but also for scope of the using.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-csharp" data-lang="csharp">public static class Clock
{
    public static DateTime UtcNow() { /* ... */ }
    public static IDisposable SetTimeForCurrentThread(Func&lt;DateTime&gt; time) { /* ... */ }
}

public class Foo
{
    public string HelloTime() =&gt;
        $"Hello at {Clock.UtcNow()}";
}

public class FooTest
{
    [Fact]
    public void HelloTime_Gives_CorrectTime()
    {
        var dateTime = new DateTime(2017, 06, 11);
        using (Clock.SetTimeForCurrentThread(() =&gt; dateTime))
        {
             Assert.Equal((new Foo()).HelloTime(), $"Hello at {dateTime}");
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://nodatime.org/3.0.x/api/NodaTime.Testing.html">NodaTime testing</a></p>
</div>
</div>
</div>