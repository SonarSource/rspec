== Why is this an issue?

To parametrize an algorithm with a function, you can use one of the following techniques:

* A function pointer (S5205 explains why it is an inferior solution)
* A typed-erased function wrapper such as `std::function` ({cpp}11) or `std::move_only_function` ({cpp}23)
* A template parameter

How do you select between a typed-erased function wrapper and a template parameter?

Thanks to type erasure, `std::function` offers the most flexibility. You can store them in variables, including containers such as ``++std::map<std::string, std::function<void(void)>>++``.
In other words, `std::function` can represent any kind of functor as long as their signatures are compatible. It also comes with a cost: due to this type erasure, a compiler will typically not be able to inline a call to a `std::function`.

`std::move_only_function` is very similar to `std::function`.
The main difference is that, as its name implies, it cannot be copied and has to be moved.

Template parameters, on the other hand, are less flexible. Each functor has its own type, which prevents storing several of them together even if they all have compatible signatures. But since each template instance knows the type of the functor, calls can be inlined, making this a zero-cost abstraction.

In conclusion, if the functor is known at compile-time, you should prefer using a template parameter; if it has to be dynamic, a typed-erased function wrapper gives you greater flexibility.

This rule detects function parameters of type `std::function` and `std::move_only_function` that will likely benefit from being replaced by a template parameter. It does so by looking at whether the functor is only called inside the function or if it participates in other operations.


=== Noncompliant code example

[source,cpp,diff-id=1,diff-type=noncompliant]
----
using Criterion = std::function<bool(DataPoint const&)>;
void filter(DataSet* data, Criterion criterion) { // Noncompliant
  for (auto& dataPoint : data) {
    if (criterion(dataPoint)) {
      data.markForRemoval(dataPoint);
    }
  }
}
----


=== Compliant solution

[source,cpp,diff-id=1,diff-type=compliant]
----
template <class Criterion>
void filter(DataSet* data, Criterion criterion) { // Compliant
  for (auto& dataPoint : data) {
    if (criterion(dataPoint)) {
      data.markForRemoval(dataPoint);
    }
  }
}
----


=== Exceptions

This rule ignores virtual functions because they don't work well with templates.

== Resources

=== Documentation

* {cpp} reference - https://en.cppreference.com/w/cpp/utility/functional/function[`std::function`]
* {cpp} reference - https://en.cppreference.com/w/cpp/utility/functional/move_only_function[`std::move_only_function`]

=== Related rules

* S5205 Function pointers should not be used as function parameters

