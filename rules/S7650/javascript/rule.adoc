This rule raises an issue when the `inputs` metadata property is used in `@Component` or `@Directive` decorators.

== Why is this an issue?

Using the `inputs` metadata property makes code harder to read and maintain. The metadata approach lacks type safety and IDE support compared to using `@Input()` decorators directly on class properties.

The `@Input()` decorator approach provides better:

* Type checking and IntelliSense support
* Code readability by keeping input definitions close to their properties
* Refactoring capabilities in modern IDEs
* Alignment with Angular's recommended coding style

=== What is the potential impact?

Using the metadata approach reduces code maintainability and developer productivity. It makes the codebase harder to understand and refactor, especially in larger applications.

=== How to fix?


Replace the `inputs` metadata property with `@Input()` decorators on class properties. This provides better type safety and follows Angular's style guide recommendations.

==== Non-compliant code example

[source,javascript,diff-id=1,diff-type=noncompliant]
----
@Component({
  inputs: ['name', 'id: userId'], // Noncompliant
  selector: 'app-user'
})
class UserComponent {
  name: string;
  userId: string;
}
----

==== Compliant code example

[source,javascript,diff-id=1,diff-type=compliant]
----
@Component({
  selector: 'app-user'
})
class UserComponent {
  @Input() name: string;
  @Input('userId') id: string;
}
----

=== Documentation

 * Angular Style Guide - Input and Output Properties - https://angular.dev/style-guide#style-05-12[Official Angular style guide recommendation against using inputs metadata property]
 * Angular Input Decorator - https://angular.dev/api/core/Input[Documentation for the @Input() decorator]

