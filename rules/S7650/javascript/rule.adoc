This rule raises an issue when the `inputs` metadata property is used in `@Component` or `@Directive` decorators.

== Why is this an issue?

Using the `inputs` metadata property in Angular components and directives is discouraged by the Angular Style Guide. This approach has several drawbacks compared to using `@Input()` decorators directly on class properties.

The `inputs` metadata property requires you to define input properties as strings in an array, which provides no compile-time type checking. This makes it easy to introduce typos or mismatched property names that won't be caught until runtime.

Additionally, using the metadata approach separates the input declaration from the actual property definition in the class. This makes the code harder to read and maintain, as developers need to look in multiple places to understand a component's inputs.

The `@Input()` decorator approach provides better IDE support with autocompletion, refactoring capabilities, and immediate feedback about type mismatches. It also keeps the input declaration close to the property definition, making the code more self-documenting and easier to understand.

=== What is the potential impact?

Using the `inputs` metadata property can lead to runtime errors due to typos in property names that aren't caught at compile time. It also reduces code maintainability and makes refactoring more error-prone, as changes to property names may not be automatically updated in the metadata array.

=== How to fix in Angular?

Replace the `inputs` metadata property with `@Input()` decorators on the class properties. This provides better type safety and follows Angular best practices.

==== Non-compliant code example

[source,typescript,diff-id=1,diff-type=noncompliant]
----
@Component({
  inputs: ['id: foo', 'name'],  // Noncompliant
  selector: 'app-test'
})
class Test {
  id: string;
  name: string;
}
----

==== Compliant code example

[source,typescript,diff-id=1,diff-type=compliant]
----
@Component({
  selector: 'app-test'
})
class Test {
  @Input('foo') id: string;
  @Input() name: string;
}
----

For directives, the same principle applies - use `@Input()` decorators instead of the `inputs` metadata property.

==== Non-compliant code example

[source,typescript,diff-id=2,diff-type=noncompliant]
----
@Directive({
  inputs: ['disabled', 'value: inputValue'],  // Noncompliant
  selector: '[appTest]'
})
class TestDirective {
  disabled: boolean;
  value: any;
}
----

==== Compliant code example

[source,typescript,diff-id=2,diff-type=compliant]
----
@Directive({
  selector: '[appTest]'
})
class TestDirective {
  @Input() disabled: boolean;
  @Input('inputValue') value: any;
}
----

=== Documentation

 * Angular Style Guide - Input and Output Properties - https://angular.dev/style-guide#style-05-12[Official Angular style guide recommendation against using inputs metadata property]
 * Angular Input Decorator Documentation - https://angular.dev/api/core/Input[Official documentation for the @Input() decorator]

