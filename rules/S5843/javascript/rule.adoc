== Why is this an issue?

Overly complicated regular expressions are hard to read and maintain and can easily cause hard-to-find bugs.

To determine the complexity of a regular expression, each of the following operators increases the complexity by an amount equal to the current nesting level and also increases the current nesting level by one for its arguments:

* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Regular_expressions/Disjunction[Disjunctions (``++|++``)]: when multiple ``++|++`` operators are used together, the subsequent ones only increase the complexity by 1
* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions/Quantifiers[Quantifiers] (``++*++``, ``+``, ``++?++``, ``++{n,m}++``, ``++{n,}++`` or ``++{n}++``)
* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Regular_expressions/Lookahead_assertion[Lookahead] and https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Regular_expressions/Lookbehind_assertion[lookbehind] assertions

Additionally, each use of a https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions/Character_classes[character class] and https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions/Groups_and_backreferences[backreferences] increase the complexity by 1 regardless of nesting.

This rule will raise an issue when total complexity is above the given `maxComplexity` (20 by default).

[source,javascript,diff-id=1,diff-type=noncompliant]
----
const datePattern = /^(?:(?:31(\/|-|\.)(?:0?[13578]|1[02]))\1|(?:(?:29|30)(\/|-|\.)(?:0?[13-9]|1[0-2])\2))(?:(?:1[6-9]|[2-9]\d)?\d{2})$|^(?:29(\/|-|\.)0?2\3(?:(?:(?:1[6-9]|[2-9]\d)?(?:0[48]|[2468][048]|[13579][26])|(?:(?:16|[2468][048]|[3579][26])00))))$|^(?:0?[1-9]|1\d|2[0-8])(\/|-|\.)(?:(?:0?[1-9])|(?:1[0-2]))\4(?:(?:1[6-9]|[2-9]\d)?\d{2})$/; //Noncompliant: move some validation logic to regular code
if (dateString.match(datePattern)) {
    handleDate(dateString);
}
----

If a regex is too complicated, you should consider replacing (partially or completely) it with regular code. Alternatively, split it apart into multiple patterns. If a regular expression is split among multiple variables, the complexity is calculated for each variable individually, not for the whole regular expression.

[source,javascript,diff-id=1,diff-type=compliant]
----
const datePattern = /^\d{1,2}([-/.])\d{1,2}\1\d{1,4}$/;
if (dateString.match(datePattern)) {
    const dateParts = dateString.split(/[-/.]/);
    const day = parseInt(dateParts[0]);
    const month = parseInt(dateParts[1]);
    const year = parseInt(dateParts[2]);
    // Put logic to validate and process the date based on its integer parts here
}
----

== Resources
=== Documentation
* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions[MDN - Regular expressions]
* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp[MDN - `RegExp`]
* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Regular_expressions/Disjunction[MDN - Disjunction: ``++|++``]
* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions/Quantifiers[MDN - Quantifiers]
* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Regular_expressions/Lookahead_assertion[MDN - Lookahead assertion: ``++(?=...), (?!...)++``]
* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Regular_expressions/Lookbehind_assertion[MDN - Lookbehind assertion: ``++(?<=...), (?<!...)++``]
* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions/Character_classes[MDN - Character classes]
* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions/Groups_and_backreferences[MDN - Groups and backreferences]


ifdef::env-github,rspecator-view[]

'''
== Implementation Specification
(visible only on this page)

include::../message.adoc[]

include::../parameters.adoc[]

include::../highlighting.adoc[]

endif::env-github,rspecator-view[]
