This rule raises issues for overloaded binary mathematical and relation operators that are non declared as hidden friend.

== Why is this an issue?

When overloading an binary or relation operators, it is recommended to declared the as hidden friends of the class.
A hidden friend, i.e. friend function defined in-class body, provides following benefits:

* in contrast to member function, it allows conversion to be applied to both operands
* in contrast to free functions, it is considered only if one operands is class type

This rule raises issues for all overloaded binary:
 * mathematical operators: `+`, `-`, `*`, `/`, `%`, `^`, `&`, `|`, `<<`, `>>`
 * until {cpp}20, all relational operators: `==`, `!=`, `<`, `>`, `<=`, `>=`
 * since {cpp}20, non-members key relational operators: `==`, `<=>` 

=== Noncompliant code example

[source,cpp,diff-id=1,diff-type=noncompliant]
----
struct MyClass {
  MyClass operator+(const MyClass& rhs) // Noncompliant
  { /* ... */ }
};

bool operator==(const MyClass &lhs, const MyClass& rhs) // Noncompliant
{ /* ... */ }
----

=== Compliant solution

[source,cpp,diff-id=1,diff-type=compliant]
----
sturct MyClass {
  friend MyClass operator+(const MyClass &lhs, const MyClass& rhs); // Compliant
  { /* ... */ }
  friend bool operator==(const MyClass &lhs, const MyClass& rhs);   // Compliant
  { /* ... */ }
};
----

=== Why hidden friends are preffered over free functions?

The overloaded operators that are declared as hidden friends, are found only by argument-dependent lookup (ADL) for given class.
Approximately, this means that the hidden friend of class `C` is considered as candidate,
only if one of the arguments of the call is object of type `C` or one derived from it.
In contrast a free functions, will be considered an class for any class declared in same namespace.

For illustration, lets consider following class:
[source,cpp,diff-id=2,diff-type=noncompliant]
----
namespace lib {
  struct Path {
    Path(char const*);
    Path(std::string_view);
    Path& operator/=(Path const&);
  };

  Path operator/(Path const& lhs, Path const& rhs) {
    auto result = lhs;
    result /= rhs;
    return lhs;
  }
}
----

The `operator/` will considered as candiate for any call `a / b` where either `a` or `b` is namespace `lib`.
This no only makes compilation slower, but also list the function as candidate in case of the compilation error,
making such message less redable.

Furthermore, when such opeator is visible via normal lookup, it may be invoked when both argument is of type that is convertible to `lib::Path`.
This may happen for code in `lib` namespace, or after using `using namespace lib;`.
However, such code will not compile or (even worse) select different overload when placed in different namespace.

[source,cpp]
----
namespace lib {
  void insideLib(std::string_view sv) {
    sv / "dir"; // Compiles, converts both arg to lib::Path
  }
} // namespace lib

namespace otherNS {
  void withoutUsing(std::string_view sv) {
    sv / "dir"; // Either does not compile or calls different operator
  }
  void withUsing(std::string_view sv) {
    using namespace lib;
    sv / "dir"; // Compiles, converts both arg to lib::Path
  }
} // namespace otherNS
----

Such conversion for both arguments will not be allowed when function is declared as hidden friend,
as non of the operands are of `lib::Path` type:

[source,cpp,diff-id=2,diff-type=compliant]
----
namespace lib {
  struct Path {
    Path(char const*);
    Path(std::string_view);
    Path& operator/=(Path const&);

    friend Path operator/(Path const& lhs, Path const& rhs) {
      auto result = lhs;
      result /= rhs;
      return lhs;
    }
  };
}
----

=== Why hidden friends are preffered over member functions?


=== Why relational operators are treated differently since {cpp}20?

The {cpp}20 have introduced an tree-way comparision operator `<=>` (also know as spaceship),
in addition to the mechanism that consideres additional function when interpreting relational operations:
 * `a < b` (or `>`, `<=`, `>=`) is also interpeted as `operator<=>(a, b) < 0`, `a.operator<=>(b) < 0`, or `0 < operator<=>(b, a)`, `0 < b.operator<=>(a)`,
 * `a != b` is also intepreted as `!operator==(a, b)`, `!a.operator==(b)`, or `!operator==(b, a)`, `!b.opeator==(a)`,
 * `a == b` is also intepreted as `operator==(a, b)`, `a.operator==(b)`, or  `operator==(b, a)`, `b.opeator==(a)`.

Above mechanism, makes overloads for `!=`, `<`, `>`, `<=`, `>=` redundant, and can be replaced with `<=>` and `==` (see S6187).
As this overloads usually can be removed, we do not suggest replacing them with hidden friends.

Additionally, such rewrites consider calls of overloads with the order of argument as spelled (`a`, `b`), and reversed (`b`, `a`).
This makes behavior of expression consistient regardless of the order of argument.
Given the following example:

[source,cpp]
----
struct MyString {
  MyString(char const* cstr);
  bool operator==(MyString const& other) const;                  // Compliant since {cpp}20: see below
  std::strong_ordering operator<=>(MyString const& other) const; // Compliant: only available since {cpp}20
};

const MySting ms;
----

The expression `ms == "Some string"` and `"SomeString" == ms` will both compile, 
and the later will call `operator==` with argument reversed. 
This removes the drawbacks of declaring such operators as members, 
and the issue is not raised in {cpp}20 or later mode in such case.

Note, that hidden friends are still preffered over free functions even if {cpp}20:
[source,cpp]
----
struct MyString {
  MyString(char const* cstr);
};

bool operator==(MyString const& lhs, MyString const& rhs) const                   // Noncompliant
{ /* ... */ }
std::strong_ordering operator<=>(MyString const& lhs, MyString const& rhs) const  // Noncompliant
{ /* ... */ }
----

== How to fix it

// out of line
// templates

== Resources

=== Documentation

* {cpp} reference - https://en.cppreference.com/w/cpp/language/adl[Argument-dependent lookup]

=== External coding guidelines

* {cpp} Core Guidelines - https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c161-use-non-member-functions-for-symmetric-operators[C.161: Use non-member functions for symmetric operators]

=== Related rules

* S6187 suggest replacing overloads of relation operators with `<=>`

ifdef::env-github,rspecator-view[]

'''
== Implementation Specification
(visible only on this page)

=== Message

Make this a free function, potentially "friend".


'''
== Comments And Links
(visible only on this page)

Exception for member `operator<<` and `operator>>` that looks like streaming is ommitted on purpose.
I do not think any user will be confused about not having issue there, when they write stream
(this happens only for member).

=== on 17 Nov 2015, 09:01:34 Evgeny Mandrikov wrote:
\[~ann.campbell.2] could you please help me update this RSPEC - operators ``++=++``, ``++[]++`` and ``++->++`` can't be overloaded as friend functions.

=== on 17 Nov 2015, 14:01:38 Ann Campbell wrote:
See what you think [~evgeny.mandrikov]

=== on 17 Nov 2015, 20:38:54 Evgeny Mandrikov wrote:
\[~ann.campbell.2] LGTM

endif::env-github,rspecator-view[]
