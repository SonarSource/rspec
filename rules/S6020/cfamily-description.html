<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When they were first introduced in the language, type traits, defined in header <code>&lt;type_traits&gt;,</code> required to use nested types (with <code>::type</code>) or nested values (with <code>::value</code>) to access the result of the trait. Since then, the language introduced templated alias declaration and variable templates that allow to define traits in a more direct and readable way.</p>
</div>
<div class="paragraph">
<p>Even if the old variant still exists, the new one, which uses <code>_t</code> (C&#43;&#43;14) and <code>_v</code> (C&#43;&#43;17) suffixes as discriminant, should be preferred.</p>
</div>
<div class="sect2">
<h3 id="_noncompliant_code_example">Noncompliant code example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">template&lt;class T&gt;
void f(T t) {
  static_assert (std::is_arithmetic&lt;T&gt;::value); // Noncompliant
  using rawType = std::remove_cv&lt;T&gt;::type; // Noncompliant
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_compliant_solution">Compliant solution</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">template&lt;class T&gt;
void f(T t) {
  static_assert (std::is_arithmetic_v&lt;T&gt;); // Compliant, C++17
  using rawType = std::remove_cv_t&lt;T&gt;; // Compliant, C++14
}</code></pre>
</div>
</div>
</div>
</div>
</div>