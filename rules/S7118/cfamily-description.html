<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>std::string</code> methods should be preferred over operations on the result of <code>c_str()</code> or <code>data()</code> when manipulating a standard string.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When manipulating standard strings, it is recommended to use their methods, rather than accessing the underlying char array representation with low-level C methods. The string methods are clearer in their purpose, less error-prone, and will sometimes be more performant.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">void func(std::string const&amp; param1, std::string const&amp; param2) {
  int size = strlen(param1.data()); // Noncompliant
  bool same = (strcmp(param1.c_str(), param2.c_str()) == 0); // Noncompliant
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_fix_it">How to fix it</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_size_calculation">size calculation</h3>
<div class="paragraph">
<p>Using <code>strlen</code> to calculate the size of a string will necessitate finding its null terminator. The string already stores its own size and can return it for free.</p>
</div>
<div class="sect3">
<h4 id="_noncompliant_code_example">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">int size = strlen(string.c_str()); // Noncompliant</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">int size = string.size(); // Compliant</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_embedded_null_terminator_detection">Embedded null-terminator detection</h3>
<div class="paragraph">
<p>Note that as mentioned in the "Pitfalls" part, <code>size()</code> will return the full size,
 including embedded null characters. If the goal of the call to <code>c_str()</code> is to detect
 the presence of embedded null-terminators, more explicit methods like <code>std::string::find()</code> or <code>std::string::contains()</code> should be used.</p>
</div>
<div class="sect3">
<h4 id="_noncompliant_code_example_2">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">if (string.size() != strlen(string.c_str())) // Noncompliant
{
  // ...
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution_2">Compliant solution</h4>
<div class="paragraph">
<p>In C++23 <code>std::string::contains()</code> is the best solution.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">if (string.contains('\0')) // Compliant
{
  // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Before that, <code>std::string::find()</code> is an alternative.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">if (string.find('\0') != std::string::npos) // Compliant
{
  // ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_string_comparison">string comparison</h3>
<div class="paragraph">
<p>Testing the equality between two full strings can be directly performed using the equality operator. For other comparisons, <code>std::string::compare</code> is more readable.</p>
</div>
<div class="sect3">
<h4 id="_noncompliant_code_example_3">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">void comparisons(std::string const&amp; s1, std::string const&amp; s2) {
  bool equal = strcmp(s1.c_str(), s2.c_str()) == 0; // Noncompliant
  int comparePart = strncmp(s1.c_str() + 2, s2.c_str() + 3, 10); // Noncompliant
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution_3">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">void comparisons(std::string const&amp; s1, std::string const&amp; s2) {
  bool equal = s1 == s2; // Compliant
  int comparePart = s1.compare(2, 10, s2, 3, 10); // Compliant
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>With C++17 and higher, substring comparison can also be done through <code>std::string_view</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">auto comparePart = std::string_view(s1).substr(2, 10) &lt;=&gt; std::string_view(s2).substr(3, 10);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_searching_a_substring">Searching a substring</h3>
<div class="paragraph">
<p>Either searching a substring or a single character inside a string can be done with <code>std::string::find()</code>.</p>
</div>
<div class="sect3">
<h4 id="_noncompliant_code_example_4">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">void search(std::string const&amp; string) {
  char const* sub = strstr(string.c_str(), "substring"); // Noncompliant
  char const* dot = strchr(string.c_str(), '.'); // Noncompliant
  // ...
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution_4">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">void search(std::string const&amp; string) {
  size_t sub = string.find("substring"); // Compliant
  size_t dot = string.find('.'); // Compliant
  // ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_searching_one_of_many_characters">Searching one of many characters</h3>
<div class="paragraph">
<p>Four methods allow searching for any character from a list inside a string: <code>find_first_of</code>, <code>find_first_not_of</code>, <code>find_last_of</code>, and <code>find_last_not_of</code>. They are better alternatives than <code>strspn</code>, <code>strcspn</code>, and <code>strpbrk</code> when manipulating strings.</p>
</div>
<div class="sect3">
<h4 id="_noncompliant_code_example_5">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">void search(std::string const&amp; string) {
  size_t firstNonNumeric = strspn(string.c_str(), "0123456789"); // Noncompliant
  size_t firstSeparator = strcspn(string.c_str(), ",. ;"); // Noncompliant
  // ...
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution_5">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">void search(std::string const&amp; string) {
  size_t firstNonNumeric = string.find_first_not_of("0123456789"); // Compliant
  size_t firstSeparator = string.find_first_of(",. ;"); // Compliant
  // ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_pitfalls">Pitfalls</h3>
<div class="paragraph">
<p>Using string methods instead of the result of <code>c_str()</code> (or <code>data()</code>) will have different results when the string contains embedded null terminators in its content. Operations on <code>c_str()</code> will stop at the first null-terminator while string methods will apply to the whole content.</p>
</div>
<div class="paragraph">
<p>Most of the time, operating on the whole content is the intended behavior, but in cases where it isn&#8217;t, using methods might be less straightforward. It is still recommended to fix the code, to make this pitfall clear to other maintainers.</p>
</div>
<div class="paragraph">
<p>If the goal is to only keep the first part, the string can be cropped in place using <code>std::string::resize()</code> or <code>std::string::erase()</code>.
Calling <code>strlen(string.c_str())</code> inside a call to resize or erase is compliant by exception because it is the simplest way to crop a string like that.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">string.resize(strlen(string.c_str())); // Compliant by exception</code></pre>
</div>
</div>
<div class="paragraph">
<p>Otherwise, if working with C&#43;&#43;17 or higher and if the goal is to just query the content, a good approach is to create a <code>std::string_view</code> and use its methods, which mirror those of <code>std::string</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">std::string_view beginning{string.c_str()};
// Use string_view methods afterward
// ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Otherwise, if working with older C&#43;&#43; versions or if the resulting string will be modified, doing a full copy also works.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">std::string beginning{string.c_str()};
// Use beginning and its methods afterward
// ...</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_going_the_extra_mile">Going the extra mile</h3>
<div class="paragraph">
<p>Direct replacement of one C function with the corresponding string method may not lead to the best code overall. When replacing a C function call, you should consider what overall functionality this call is part of and whether your C&#43;&#43; version allows to implement that functionality more easily and effectively.</p>
</div>
<div class="paragraph">
<p>For example using ranges (<code>std::ranges::views::split</code>, <code>std::ranges::views::chunk</code>), using algorithms, using <code>std::istringstream</code> or <code>std::ispanstream</code>, using <code>std::string_view</code>.</p>
</div>
<div class="paragraph">
<p>An example of a function splitting words in a moddern way could be as follow.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">void treatWord(std::string_view word);

void treatAllWords(std::string_view text) {
  constexpr std::string_view delim{" "};
  for (const auto word : std::views::split(text, delim))
    treatWord(std::string_view{word});
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_documentation">Documentation</h3>
<div class="ulist">
<ul>
<li>
<p>C&#43;&#43; reference - <a href="https://en.cppreference.com/w/cpp/string/basic_string">Native functions for std::string</a></p>
</li>
<li>
<p>C&#43;&#43; reference - <a href="https://en.cppreference.com/w/cpp/ranges#Range_adaptors">ranges documentation</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>