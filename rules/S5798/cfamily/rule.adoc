== Why is this an issue?

If a buffer contains sensitive data, such as passwords or access tokens, it is good practice to overwrite the buffer before releasing the memory. This ensures that the sensitive data is not available when that memory is reallocated. The ``++memset++`` function is commonly used for this purpose.

The C language specification allows the compiler to optimize away (remove) code that does not have any effect. For example, memory writes can be removed if the target memory is not used again before it is released.

When the ``++memset++`` function is used to clear sensitive data from memory and that memory is released immediately afterwards, the compiler is allowed to optimize away the ``++memset++`` call. The sensitive data will therefore remain in memory.

This rule raises an issue when a call to ``++memset++`` is followed by the destruction of the buffer.

== How to fix it

The function https://en.cppreference.com/w/c/string/byte/memset[``++memset_s++``] behaves similarly to ``++memset++``. The main difference is that it cannot be optimized away and the memory will be overwritten in all cases. You should use this function to clear security-sensitive data.

The ``++memset_s++`` function is defined in annex K of C11 and is optional for C11 compilers. It will be available if the macro ``++__STDC_LIB_EXT1__++`` is defined, and you must be enabled by defining the macro ``++__STDC_WANT_LIB_EXT1__++`` before including ``++<string.h>++``.

Other platform specific functions can perform the same operation, such as https://docs.microsoft.com/en-us/previous-versions/windows/desktop/legacy/aa366877(v=vs.85)?redirectedfrom=MSDN[SecureZeroMemory] (Windows) or https://www.freebsd.org/cgi/man.cgi?query=explicit_bzero[explicit_bzero] (FreeBSD).


=== Noncompliant code example

[source,C++,diff-id=1,diff-type=noncompliant]
----
#include <string>

void f(char *password, size_t bufferSize) {
  char localToken[256];
  init(localToken, password);
  memset(password, 0, strlen(password));  // Noncompliant
  memset(localToken, 0, strlen(localToken));  // Noncompliant
  free(password);
}
----

The ``memset`` calls may be optimized away because ``password`` is about to be freed and ``localToken`` is about to go out of scope.

=== Compliant solution

[source,C++,diff-id=1,diff-type=compliant]
----
#define __STDC_WANT_LIB_EXT1__
#include <string>

void f(char *password, size_t bufferSize) {
  char localToken[256];
  init(localToken, password);
  memset_s(password, bufferSize, 0, strlen(password));
  memset_s(localToken, sizeof(localToken), 0, strlen(localToken));
  free(password);
}
----


== Resources

=== Standards

* OWASP - https://www.owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure[Top 10 2017 Category A3 - Sensitive Data Exposure]
* MITRE - https://cwe.mitre.org/data/definitions/14[CWE-14 - Compiler Removal of Code to Clear Buffers]


ifdef::env-github,rspecator-view[]

'''
== Implementation Specification
(visible only on this page)

=== Message

Use "memset_s" if you want to scrub memory, or remove this useless operation


endif::env-github,rspecator-view[]
