<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>C+11 introduced “Uniform initialization”/"list initialization". It is a way to initialize an object from a braced-init-list. This adds a third way to initialize objects in C&#43;&#43; on top of parentheses and equal signs.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>int a{1}; // braces initialization
int b(1); // parentheses initialization
int c=1; // equal sign initialization</pre>
</div>
</div>
<div class="paragraph">
<p>“Uniform initialization” was introduced to address the confusion of the many initialization syntaxes in C&#43;&#43; and to give a syntax that, in concept, can be used in all initialization scenarios. It helps to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Initialize container in a way that wasn&#8217;t possible before:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>// Before
std::vector&lt;int&gt; v;
v.push_back(1);
v.push_back(2);
// After
std::vector&lt;int&gt;{1,2,3};</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Avoid narrowing:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>double d=2.5;
int i{d}; // Compilation error</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Avoid the most vexing parse:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>class A{};
A a();  // Compilation error declares a function named a that returns A.
A a{}; // Call A constructor</pre>
</div>
</div>
<div class="paragraph">
<p>That is why “Uniform initialization” should be preferred.</p>
</div>
<div class="sect2">
<h3 id="_noncompliant_code_example">Noncompliant code example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">struct A {
  A(int i, int j, int z) {
    ...
  }
};

void f() {
  A a(1,2,3); // Noncompliant
}

struct B {
  A a = A(1, 2, 3); // Noncompliant
};</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_compliant_solution">Compliant solution</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">struct A {
  A(int i, int j, int z) {
    ...
  }
};

void f() {
  A a{1,2,3};
}

struct B {
  A a{1, 2, 3};
};</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_exceptions">Exceptions</h3>
<div class="ulist">
<ul>
<li>
<p>In some situations, “Uniform initialization” has surprising behavior. for example, in constructor overload resolution, “Uniform initialization” prefers the constructor with "std::initializer_list" as a parameter if possible, even if another constructor seems like a better match. Like in the "std::vector" case, you might need to go back to parentheses in order to call the non "intializer_list" constructor:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">vector&lt;int&gt; v1(5, 10); //  5 copies of the value 10</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>When "=" is after "auto". This might be needed to enforce deduction to initializer_list:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">auto i1 {1}; // int with the value 1
auto i2 = {1}; //  std::initializer_list&lt;int&gt; with an element equal to 1</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>In single argument cases, "=" is okay:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">int i = 39;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>When the braces are after the "=":</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">vector&lt;int&gt; v = { 1, 2, 4 };</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>C&#43;&#43; Core Guidelines - <a href="https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es23-prefer-the--initializer-syntax">ES.23: Prefer the <code>{}</code>-initializer syntax</a></p>
</li>
</ul>
</div>
<hr>
</div>
</div>
<div class="sect1">
<h2 id="_comments_and_links">Comments And Links</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_on_11_may_2020_090555_geoffray_adde_wrote">on 11 May 2020, 09:05:55 Geoffray Adde wrote:</h3>
<div class="ulist">
<ul>
<li>
<p>The description is crystal clear! I love the summary about initialization.</p>
</li>
<li>
<p>In single argument cases, "=" is okay:  &#8658;  maybe builtin single argument case ?</p>
</li>
<li>
<p>In some situations, “Uniform initialization” has surprising behavior. &#8658; somehow to me, it makes sense because the curly braces syntax seems to indicate initializer list.</p>
</li>
<li>
<p>Do we need more examples?</p>
</li>
</ul>
</div>
</div>
</div>
</div>