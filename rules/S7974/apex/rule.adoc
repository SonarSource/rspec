This rule raises an issue when a class contains multiple conditional branches (if-else or switch statements) that select between different algorithms, instead of using the Strategy pattern with a common interface.

== Why is this an issue?

The Strategy pattern is a behavioral design pattern that defines a family of algorithms through a common interface, allowing the selection of the appropriate algorithm at runtime.

When developers implement algorithm selection using conditional statements (if-else chains or switch statements), they create several problems:

**Violation of the Open/Closed Principle**: Adding new algorithms requires modifying existing code, making the system less maintainable and more prone to bugs.

**Code duplication and complexity**: Algorithm selection logic becomes scattered throughout the codebase, leading to duplicated conditional statements and increased complexity.

**Poor testability**: Testing individual algorithms becomes difficult when they are embedded within larger conditional structures.

**Reduced flexibility**: Runtime algorithm selection becomes cumbersome, and the code becomes tightly coupled to specific algorithm implementations.

The Strategy pattern solves these issues by encapsulating each algorithm in a separate class that implements a common interface. This approach promotes loose coupling, makes the code more modular, and allows for easy extension with new algorithms without modifying existing code.

=== What is the potential impact?

Using conditional statements instead of the Strategy pattern can lead to:

* **Maintenance difficulties**: Adding new algorithms requires modifying existing code in multiple places
* **Increased bug risk**: Changes to algorithm selection logic can inadvertently affect other algorithms
* **Poor code organization**: Business logic becomes scattered and harder to understand
* **Testing challenges**: Individual algorithms cannot be easily isolated for unit testing
* **Reduced code reusability**: Algorithms cannot be easily reused in different contexts

== How to fix it

Replace conditional algorithm selection with the Strategy pattern by creating a common interface and implementing each algorithm as a separate class.

=== Code examples

==== Noncompliant code example

[source,apex,diff-id=1,diff-type=noncompliant]
----
public class PaymentProcessor {
    public void processPayment(String type, Decimal amount) {
        if (type == 'credit') {
            // credit card processing logic
            System.debug('Processing credit card payment');
        } else if (type == 'paypal') { // Noncompliant
            // PayPal processing logic
            System.debug('Processing PayPal payment');
        } else if (type == 'bank') { // Noncompliant
            // Bank transfer logic
            System.debug('Processing bank transfer');
        }
    }
}
----

==== Compliant solution

[source,apex,diff-id=1,diff-type=compliant]
----
public interface PaymentStrategy {
    void processPayment(Decimal amount);
}

public class CreditCardStrategy implements PaymentStrategy {
    public void processPayment(Decimal amount) {
        // credit card processing logic
        System.debug('Processing credit card payment');
    }
}

public class PayPalStrategy implements PaymentStrategy {
    public void processPayment(Decimal amount) {
        // PayPal processing logic
        System.debug('Processing PayPal payment');
    }
}

public class PaymentProcessor {
    private PaymentStrategy strategy;
    
    public void setStrategy(PaymentStrategy strategy) {
        this.strategy = strategy;
    }
    
    public void processPayment(Decimal amount) {
        strategy.processPayment(amount);
    }
}
----

== Resources

=== Documentation

 * Apex Design Patterns - Strategy Pattern - https://www.apexhours.com/strategy-design-pattern-in-apex/[Comprehensive guide to implementing the Strategy pattern in Apex]

 * Salesforce Apex Developer Guide - Interfaces - https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/apex_classes_interfaces.htm[Official documentation on using interfaces in Apex]

=== Standards

 * SOLID Principles - Open/Closed Principle - https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle[Software entities should be open for extension but closed for modification]
