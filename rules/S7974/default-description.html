<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This rule raises an issue when a class contains multiple conditional branches (if-else or switch statements) that select between different algorithms, instead of using the Strategy pattern with a common interface.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Strategy pattern is a behavioral design pattern that defines a family of algorithms through a common interface, allowing the selection of the appropriate algorithm at runtime.</p>
</div>
<div class="paragraph">
<p>When developers implement algorithm selection using conditional statements (if-else chains or switch statements), they create several problems:</p>
</div>
<div class="paragraph">
<p><strong>Violation of the Open/Closed Principle</strong>: Adding new algorithms requires modifying existing code, making the system less maintainable and more prone to bugs.</p>
</div>
<div class="paragraph">
<p><strong>Code duplication and complexity</strong>: Algorithm selection logic becomes scattered throughout the codebase, leading to duplicated conditional statements and increased complexity.</p>
</div>
<div class="paragraph">
<p><strong>Poor testability</strong>: Testing individual algorithms becomes difficult when they are embedded within larger conditional structures.</p>
</div>
<div class="paragraph">
<p><strong>Reduced flexibility</strong>: Runtime algorithm selection becomes cumbersome, and the code becomes tightly coupled to specific algorithm implementations.</p>
</div>
<div class="paragraph">
<p>The Strategy pattern solves these issues by encapsulating each algorithm in a separate class that implements a common interface. This approach promotes loose coupling, makes the code more modular, and allows for easy extension with new algorithms without modifying existing code.</p>
</div>
<div class="sect2">
<h3 id="_what_is_the_potential_impact">What is the potential impact?</h3>
<div class="paragraph">
<p>Using conditional statements instead of the Strategy pattern can lead to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Maintenance difficulties</strong>: Adding new algorithms requires modifying existing code in multiple places</p>
</li>
<li>
<p><strong>Increased bug risk</strong>: Changes to algorithm selection logic can inadvertently affect other algorithms</p>
</li>
<li>
<p><strong>Poor code organization</strong>: Business logic becomes scattered and harder to understand</p>
</li>
<li>
<p><strong>Testing challenges</strong>: Individual algorithms cannot be easily isolated for unit testing</p>
</li>
<li>
<p><strong>Reduced code reusability</strong>: Algorithms cannot be easily reused in different contexts</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_fix_it">How to fix it</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Replace conditional algorithm selection with the Strategy pattern by creating a common interface and implementing each algorithm as a separate class.</p>
</div>
<div class="sect2">
<h3 id="_code_examples">Code examples</h3>
<div class="sect3">
<h4 id="_noncompliant_code_example">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-apex" data-lang="apex">public class PaymentProcessor {
    public void processPayment(String type, Decimal amount) {
        if (type == 'credit') {
            // credit card processing logic
            System.debug('Processing credit card payment');
        } else if (type == 'paypal') { // Noncompliant
            // PayPal processing logic
            System.debug('Processing PayPal payment');
        } else if (type == 'bank') { // Noncompliant
            // Bank transfer logic
            System.debug('Processing bank transfer');
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-apex" data-lang="apex">public interface PaymentStrategy {
    void processPayment(Decimal amount);
}

public class CreditCardStrategy implements PaymentStrategy {
    public void processPayment(Decimal amount) {
        // credit card processing logic
        System.debug('Processing credit card payment');
    }
}

public class PayPalStrategy implements PaymentStrategy {
    public void processPayment(Decimal amount) {
        // PayPal processing logic
        System.debug('Processing PayPal payment');
    }
}

public class PaymentProcessor {
    private PaymentStrategy strategy;

    public void setStrategy(PaymentStrategy strategy) {
        this.strategy = strategy;
    }

    public void processPayment(Decimal amount) {
        strategy.processPayment(amount);
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_documentation">Documentation</h3>
<div class="ulist">
<ul>
<li>
<p>Apex Design Patterns - Strategy Pattern - <a href="https://www.apexhours.com/strategy-design-pattern-in-apex/">Comprehensive guide to implementing the Strategy pattern in Apex</a></p>
</li>
<li>
<p>Salesforce Apex Developer Guide - Interfaces - <a href="https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/apex_classes_interfaces.htm">Official documentation on using interfaces in Apex</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_standards">Standards</h3>
<div class="ulist">
<ul>
<li>
<p>SOLID Principles - Open/Closed Principle - <a href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle">Software entities should be open for extension but closed for modification</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>