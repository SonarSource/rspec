This is an issue when different packages share the same import path, creating ambiguity about which package is being imported.

== Why is this an issue?

Go's import system relies on the fundamental principle that each import path uniquely identifies a specific package. When different packages share the same import path, it creates several problems:

**Build Ambiguity**: The Go build system cannot determine which package should be used for a given import path. This leads to unpredictable build behavior where different parts of your application might end up using different versions or implementations of what appears to be the same package.

**Dependency Confusion**: Developers reading the code cannot tell which specific package is being imported. An import statement like `import "github.com/example/lib"` should always refer to the same package, but when paths are reused, it becomes unclear which implementation will actually be loaded.

**Tool Compatibility Issues**: Go tools like `go mod`, IDEs, and static analysis tools rely on import path uniqueness to function correctly. When this principle is violated, these tools may provide incorrect information, fail to resolve dependencies properly, or produce inconsistent results.

This problem commonly occurs when using vendor directories, replace directives in go.mod files, or when manually managing dependencies without proper version control.

=== What is the potential impact?

Import path conflicts can cause builds to fail unexpectedly, lead to runtime errors when the wrong package implementation is loaded, and make dependency management extremely difficult to debug. In production environments, this can result in applications using unintended package versions, potentially introducing security vulnerabilities or breaking functionality.

== How to fix it

Use semantic import versioning to differentiate between major versions of the same package. Include the major version number in the import path for versions v2 and above.

=== Code examples

==== Noncompliant code example

[source,go,diff-id=1,diff-type=noncompliant]
----
// go.mod
module myapp

require (
    github.com/example/lib v1.2.0
    github.com/example/lib v2.1.0 // Noncompliant: same import path, different versions
)
----

==== Compliant solution

[source,go,diff-id=1,diff-type=compliant]
----
// go.mod
module myapp

require (
    github.com/example/lib v1.2.0
    github.com/example/lib/v2 v2.1.0
)

// main.go
import (
    libv1 "github.com/example/lib"
    libv2 "github.com/example/lib/v2"
)
----

== Resources

=== Documentation

 * Go Modules Reference - https://go.dev/ref/mod[Official documentation on Go modules and import path management]

 * Go Blog: Package Versioning Proposal - https://go.dev/blog/versioning-proposal[Detailed explanation of semantic import versioning and import uniqueness]

 * Go Modules Wiki - https://github.com/golang/go/wiki/Modules[Community wiki with practical guidance on Go modules]

=== Standards

 * Go Import Compatibility Rule - https://go.dev/doc/go1compat[Go's compatibility promise and import path guidelines]
