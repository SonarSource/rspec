<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This rule raises an issue when methods are accessed from empty instances like <code>[]</code> or <code>{}</code> instead of from their prototypes like <code>Array.prototype</code> or <code>Object.prototype</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When you need to "borrow" a method from built-in objects like Array or Object, accessing it through an empty instance is less clear and less efficient than accessing it directly from the prototype.</p>
</div>
<div class="paragraph">
<p>Creating empty instances like <code>[]</code> or <code>{}</code> just to access their methods introduces unnecessary object creation. This approach also makes the code less explicit about the intent - when you see <code>[].slice.apply()</code>, it&#8217;s not immediately clear that you&#8217;re borrowing the Array slice method.</p>
</div>
<div class="paragraph">
<p>Using <code>Array.prototype.slice.apply()</code> instead makes your intent crystal clear: you&#8217;re using the Array slice method on some other object. This pattern is commonly used when working with array-like objects (like <code>arguments</code> or NodeLists) that don&#8217;t have Array methods but can benefit from them.</p>
</div>
<div class="paragraph">
<p>The prototype approach is also more performant because it avoids creating temporary objects that will need to be garbage collected.</p>
</div>
<div class="sect2">
<h3 id="_what_is_the_potential_impact">What is the potential impact?</h3>
<div class="paragraph">
<p>This issue affects code readability and performance. While the performance impact is usually minimal, the clarity improvement is significant. Code that explicitly uses prototypes is easier to understand and maintain, especially for developers who may not be familiar with method borrowing patterns.</p>
</div>
</div>
<div class="sect2">
<h3 id="_how_to_fix">How to fix?</h3>
<div class="paragraph">
<p>Replace empty array instances with Array.prototype when borrowing Array methods.</p>
</div>
<div class="sect3">
<h4 id="_non_compliant_code_example">Non-compliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">const array = [].slice.apply(arrayLike); // Noncompliant</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_code_example">Compliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">const array = Array.prototype.slice.apply(arrayLike);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_documentation">Documentation</h3>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/sindresorhus/eslint-plugin-unicorn#readme">eslint-plugin-unicorn</a> - Rule <a href="https://github.com/sindresorhus/eslint-plugin-unicorn/blob/HEAD/docs/rules/prefer-prototype-methods.md">prefer-prototype-methods</a></p>
</li>
<li>
<p>MDN - Function.prototype.call() - <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call">Documentation on using call() to invoke methods with different contexts</a></p>
</li>
<li>
<p>MDN - Function.prototype.apply() - <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply">Documentation on using apply() to invoke methods with array arguments</a></p>
</li>
<li>
<p>MDN - Array.prototype - <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype">Documentation on Array prototype methods</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>