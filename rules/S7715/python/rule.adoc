This is an issue when routes are defined directly on the main FastAPI instance instead of using APIRouter for modular organization, or when routers are included without appropriate prefixes or with conflicting paths.

== Why is this an issue?

FastAPI applications benefit from modular organization using APIRouter to separate concerns and improve maintainability.

When all routes are defined directly on the main FastAPI instance, the application becomes harder to maintain as it grows. This approach creates a monolithic structure where related functionality is not properly grouped, making the codebase difficult to navigate and understand.

APIRouter provides a way to organize endpoints into logical modules that can be developed and maintained independently. Each router can focus on a specific domain or feature area, making the code more organized and easier to test.

Additionally, when including routers in the main application, using meaningful prefixes helps create a clear API structure. Prefixes like `/api/v1/users` or `/admin` make the API more intuitive for consumers and help avoid path conflicts.

Including the same router multiple times with identical prefixes creates path conflicts and unpredictable behavior, as FastAPI cannot determine which route handler should respond to a request.

=== What is the potential impact?

Poor application organization leads to reduced maintainability and developer productivity. As the application grows, it becomes increasingly difficult to locate and modify specific functionality. Path conflicts from duplicate router inclusions can cause runtime errors or unpredictable API behavior, potentially breaking client applications.

== How to fix it in FastAPI

Use APIRouter to organize related endpoints into separate modules instead of defining all routes on the main FastAPI instance.

=== Code examples

==== Noncompliant code example

[source,python,diff-id=1,diff-type=noncompliant]
----
# main.py
from fastapi import FastAPI

app = FastAPI()

@app.get("/users/")  # Noncompliant
def read_users():
    return [{"username": "Rick"}]

@app.get("/items/")  # Noncompliant
def read_items():
    return [{"item_id": "Foo"}]
----

==== Compliant solution

[source,python,diff-id=1,diff-type=compliant]
----
# main.py
from fastapi import FastAPI
from .routers import users, items

app = FastAPI()
app.include_router(users.router, prefix="/api/v1")
app.include_router(items.router, prefix="/api/v1")

# routers/users.py
from fastapi import APIRouter

router = APIRouter()

@router.get("/users/")
def read_users():
    return [{"username": "Rick"}]
----

When including the same router multiple times, use different prefixes to avoid path conflicts.

=== Code examples

==== Noncompliant code example

[source,python,diff-id=2,diff-type=noncompliant]
----
from fastapi import APIRouter, FastAPI

router = APIRouter()
app = FastAPI()

@router.get("/items/")
def read_items():
    return []

app.include_router(router)
app.include_router(router, prefix="/api/v1")  # Noncompliant
----

==== Compliant solution

[source,python,diff-id=2,diff-type=compliant]
----
from fastapi import APIRouter, FastAPI

router = APIRouter()
app = FastAPI()

@router.get("/items/")
def read_items():
    return []

app.include_router(router, prefix="/api/v1")
app.include_router(router, prefix="/api/v2")
----

== Resources

=== Documentation

 * FastAPI Bigger Applications - Multiple Files - https://fastapi.tiangolo.com/tutorial/bigger-applications/[Official FastAPI documentation on organizing larger applications using APIRouter]

 * FastAPI APIRouter - https://fastapi.tiangolo.com/reference/apirouter/[APIRouter class reference documentation]
