This is an issue when `Access-Control-Allow-Origin` is set to `*` (wildcard) while `Access-Control-Allow-Credentials` is set to `true`.

== Why is this an issue?

Cross-Origin Resource Sharing (CORS) is a security mechanism that controls which origins can access resources from a different domain. When credentials are involved (cookies, authorization headers, or client certificates), browsers enforce stricter security rules.

Using a wildcard (`*`) for `Access-Control-Allow-Origin` while enabling credentials creates a fundamental security vulnerability. This configuration would allow any website on the internet to make authenticated requests to your server on behalf of your users.

Browsers prevent this dangerous combination by rejecting requests when both conditions are present:

* `Access-Control-Allow-Origin: *`
* `Access-Control-Allow-Credentials: true`

The browser will throw an error like "Cannot use wildcard in Access-Control-Allow-Origin when credentials flag is true" and block the request entirely.

Even if browsers allowed this combination, it would create severe security risks:

* **Cross-Site Request Forgery (CSRF)**: Malicious websites could make authenticated requests using the user's credentials
* **Data theft**: Any origin could access sensitive user data through authenticated API calls
* **Session hijacking**: Attackers could potentially manipulate user sessions across different domains

The solution is to explicitly specify trusted origins instead of using wildcards when credentials are required.

=== What is the potential impact?

This misconfiguration will cause browsers to block cross-origin requests entirely, breaking application functionality. If browsers allowed this combination, it would create severe security vulnerabilities including CSRF attacks, unauthorized data access, and potential session hijacking.

== How to fix it

When setting CORS headers manually, use specific origins instead of wildcards when credentials are enabled.

=== Code examples

==== Noncompliant code example

[source,python,diff-id=1,diff-type=noncompliant]
----
from flask import Flask, Response

app = Flask(__name__)

@app.after_request
def after_request(response):
    response.headers['Access-Control-Allow-Origin'] = '*'  # Noncompliant
    response.headers['Access-Control-Allow-Credentials'] = 'true'
    return response
----

==== Compliant solution

[source,python,diff-id=1,diff-type=compliant]
----
from flask import Flask, Response

app = Flask(__name__)

@app.after_request
def after_request(response):
    response.headers['Access-Control-Allow-Origin'] = 'https://trusted-domain.com'
    response.headers['Access-Control-Allow-Credentials'] = 'true'
    return response
----

== How to fix it in Flask-CORS

Replace the wildcard origin with specific trusted origins when credentials are enabled.

=== Code examples

==== Noncompliant code example

[source,python,diff-id=2,diff-type=noncompliant]
----
from flask import Flask
from flask_cors import CORS

app = Flask(__name__)
CORS(app, origins='*', supports_credentials=True)  # Noncompliant
----

==== Compliant solution

[source,python,diff-id=2,diff-type=compliant]
----
from flask import Flask
from flask_cors import CORS

app = Flask(__name__)
CORS(app, origins=['https://trusted-domain.com'], supports_credentials=True)
----

== How to fix it in Django

Configure django-cors-headers to use specific origins instead of allowing all origins when credentials are enabled.

=== Code examples

==== Noncompliant code example

[source,python,diff-id=3,diff-type=noncompliant]
----
# settings.py
CORS_ALLOW_ALL_ORIGINS = True  # Noncompliant
CORS_ALLOW_CREDENTIALS = True
----

==== Compliant solution

[source,python,diff-id=3,diff-type=compliant]
----
# settings.py
CORS_ALLOW_ALL_ORIGINS = False
CORS_ALLOWED_ORIGINS = [
    'https://trusted-domain.com',
    'https://another-trusted-domain.com',
]
CORS_ALLOW_CREDENTIALS = True
----

== How to fix it in FastAPI

Specify exact origins in the CORSMiddleware configuration when allowing credentials.

=== Code examples

==== Noncompliant code example

[source,python,diff-id=4,diff-type=noncompliant]
----
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware

app = FastAPI()
app.add_middleware(
    CORSMiddleware,
    allow_origins=['*'],  # Noncompliant
    allow_credentials=True
)
----

==== Compliant solution

[source,python,diff-id=4,diff-type=compliant]
----
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware

app = FastAPI()
app.add_middleware(
    CORSMiddleware,
    allow_origins=['https://trusted-domain.com'],
    allow_credentials=True
)
----

== Resources

=== Documentation

 * MDN - CORS - https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS[Comprehensive guide to Cross-Origin Resource Sharing]

 * MDN - Access-Control-Allow-Credentials - https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials[Documentation for the Access-Control-Allow-Credentials header]

 * Flask-CORS Documentation - https://flask-cors.readthedocs.io/en/latest/[Official documentation for Flask-CORS extension]

 * Django CORS Headers - https://github.com/adamchainz/django-cors-headers[Django package for handling CORS headers]

=== Standards

 * CWE-346: Origin Validation Error - https://cwe.mitre.org/data/definitions/346.html[Weakness related to improper validation of request origins]

 * OWASP Top 10:2021-A05-Security Misconfiguration - https://owasp.org/Top10/A05_2021-Security_Misconfiguration/[Security misconfiguration including improper CORS setup]

=== Related rules

 * RSPEC-5122 - https://rules.sonarsource.com/javascript/RSPEC-5122/[Same rule for JavaScript applications]
