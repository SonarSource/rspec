Unused assignments should be removed.

== Why is this an issue?

Assigning a value to a local variable that is not read by any subsequent instruction is called a _dead store_.

The following code snippet depicts a dead store.

[source,cpp]
----
int bar();
int buz();

int foo(bool b) {
  int x = 0;
  if (b) {
    x = bar();
    return x;
  }
  // More code ...
  if (x != 0) {
    // Noncompliant: the following two lines of code (and their enclosing if 
    // statement) are superfluous since `y`'s value is never read.
    int y = buz();
    y += 9001; // Noncompliant: dead store.
  }
  return x;
}
----

Computing or retrieving a value only to then immediately overwrite it or throw it away indicates serious logic errors in the code.
Even if the unnecessary operations do not do any harm in terms of the program's correctness, they are---at best---a waste of computing resources.
Therefore, unused values and superfluous code should be removed to prevent logic errors.


== What is the potential impact?

Not only do unused values and superfluous code make the program unnecessary complex, but also indicate significant logic errors.
And even in the absence of logic errors, they waste computing resources in case the compiler is not able to optimize them away.

Unused values typically showcase a discrepancy between what a developer intended and what is specified in the code and should be removed to uncover and eventually prevent logic errors.


== How to fix it

Remove unused values and superfluous code.


=== Code examples

==== Noncompliant code example

[source,cpp,diff-id=1,diff-type=noncompliant]
----
int bar();
int buz();

int foo(bool b) {
  int x = 0;
  if (b) {
    x = bar();
    return x;
  }
  if (x != 0) {
    int y = buz();
    y += 9001; // Noncompliant: dead store
  }
  return x;
}
----

==== Compliant solution

[source,cpp,diff-id=1,diff-type=compliant]
----
int bar();
int buz();

int foo(bool b) {
  int x = 0;
  if (b) {
    x = bar();
    return x;
  }
  // Compliant: no more dead stores and superfluous code
  return x;
}
----

[source,cpp,diff-id=2,diff-type=noncompliant]
----
long factorial(const long n) {
  long f = 1;
  for (long i = 1; i <= n; ++i) {
    f *= i;
  }
  return f;
}

long foo(long n) {
  // Noncompliant: `factorial`'s return value is unused and `factorial` has no side effects
  factorial(n);
}
----

==== Compliant solution

[source,cpp,diff-id=2,diff-type=compliant]
----
#include <iostream>
#include <format>

long factorial(const long n) {
  long f = 1;
  for (long i = 1; i <= n; ++i) {
    f *= i;
  }
  return f;
}

long foo(long n) {
  long f = factorial(n); // Compliant: return value of `factorial` is used
  std::cout << std::format("factorial({}) is {}\n", n, f);
  return f;
}
----


== Resources

=== Standards

* CERT - https://wiki.sei.cmu.edu/confluence/x/39UxBQ[MSC13-C. Detect and remove unused values]
* CERT - https://wiki.sei.cmu.edu/confluence/x/9DZGBQ[MSC56-J. Detect and remove superfluous code and values]
* CWE - https://cwe.mitre.org/data/definitions/563[563 - Assignment to Variable without Use ('Unused Variable')]

=== Related rules

* S1763 detects unreachable code
* S2583 ensures that conditionally executed code is reachable
* S2589 detects gratuitous boolean expressions
* S3516 ensures that function returns are not invariant
* S3626 identifies redundant jump statements


ifdef::env-github,rspecator-view[]

'''
== Implementation Specification
(visible only on this page)

include::../message.adoc[]

'''
== Comments And Links
(visible only on this page)

include::../comments-and-links.adoc[]

endif::env-github,rspecator-view[]
