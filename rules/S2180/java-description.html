<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Concurrent maps are used for thread-safety, but the use of such maps alone does not ensure thread-safety; they must also be <em>used</em> in a thread-safe manner. Specifically, retrieving a key&#8217;s value from a map, and then using <code>put</code> to add a map element if the value is <code>null</code> is not performed in an atomic manner. Here&#8217;s what can happen</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Thread1 cmap.get("key") =&gt; null
Thread2 cmap.get("key") =&gt; null
Thread1 cmap.put("key", new Value())
Thread2 cmap.put("key", new Value())</pre>
</div>
</div>
<div class="paragraph">
<p>Note that this example is written as though the threads take turns performing operations, but that&#8217;s not necessarily the case.</p>
</div>
<div class="paragraph">
<p>Instead of <code>put</code>, <code>putIfAbsent</code> should be used.</p>
</div>
<div class="sect2">
<h3 id="_noncompliant_code_example">Noncompliant code example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">private static final ConcurrentMap&lt;String,MyClass&gt; cmap = new ConcurrentHashMap&lt;String,MyClass&gt;();

public void populateMyClass(String key, String mcProp) {
  MyClass mc = cmap.get(key);
  if (mc == null) {
    mc = new MyClass();
    cmap.put(key, mc);  // Noncompliant
  }
  mc.setProp(mcProp);  // could be futile since mc may have been replaced in another thread!
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_compliant_solution">Compliant solution</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">private static final ConcurrentMap&lt;String,MyClass&gt; cmap = new ConcurrentHashMap&lt;String,MyClass&gt;();

public void populateMyClass(String key, String mcProp) {
  MyClass mc = cmap.get(key);
  if (mc == null) {
    mc = new MyClass();
    cmap.putIfAbsent(key, mc);
    mc = cmap.get(key); // re-retrieve value since another thread could have beaten this one to the "put"
  }
  mc.setProp(mcProp);
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a href="https://wiki.sei.cmu.edu/confluence/x/8jdGBQ">CERT, VNA03-J.</a> - Do not assume that a group of calls to independently atomic methods is atomic</p>
</li>
</ul>
</div>
<hr>
</div>
</div>
<div class="sect1">
<h2 id="_implementation_specification">Implementation Specification</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_message">Message</h3>
<div class="paragraph">
<p>Use "putIfAbsent" instead of "put".</p>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_comments_and_links">Comments And Links</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_on_22_oct_2014_145653_ann_campbell_wrote">on 22 Oct 2014, 14:56:53 Ann Campbell wrote:</h3>
<div class="paragraph">
<p>\[~nicolas.peru] note that in the code sample I also demonstrate that you must re-retrieve the value from the map before modifications. I think re-retrieval is also worthy of checking, but I don&#8217;t know if you&#8217;d want to include it in this rule or have a separate rule for that.</p>
</div>
</div>
<div class="sect2">
<h3 id="_on_27_feb_2015_104919_nicolas_peru_wrote">on 27 Feb 2015, 10:49:19 Nicolas Peru wrote:</h3>
<div class="paragraph">
<p>Your question shall be answered by implementer.</p>
</div>
</div>
</div>
</div>