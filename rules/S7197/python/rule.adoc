This rule reports circular dependencies between source modules, including indirect cycles spanning multiple modules caused by circular imports.

== Why is this an issue?

Circular dependencies occur when two or more modules import each other, either directly or indirectly.
This creates a dependency structure that lacks a clear hierarchy, making the codebase harder to understand and maintain.
Additionally, the order in which circular imports are resolved is not guaranteed, which can lead to unpredictable behavior and runtime errors.

=== What is the potential impact?

Circular dependencies increase the complexity of the code architecture, reducing readability, extensibility, and maintainability.
As the project grows, these dependencies can spread, further complicating the architecture and increasing technical debt.
Over time, resolving these dependencies becomes increasingly difficult.

== How to fix it

1. **Refactor shared functionality**: If multiple modules share similar functionality, consider moving that functionality to a separate module that both can import. This allows each module to depend on the shared module rather than on each other.

2. **Use dependency inversion:** Instead of directly importing modules that create circular dependencies, use dependency inversion by passing necessary functions or objects as parameters. This breaks the circular reference and makes the code more modular and testable.

3. **Split responsibilities**: Evaluate whether each file is handling too many responsibilities. If so, break them down into smaller, more focused modules. This reduces circular dependencies and ensures that your code is easier to manage and extend.

=== Code examples

==== Noncompliant code example

The following code contains a circular dependency: `order.py` &rarr; `customer.py` &rarr; `order.py`, and `order.py` &rarr; `product.py` &rarr; `order.py`.
Both cycles are connected through `order.py`, forming a tangle of two cycles.

[source,python,diff-id=1,diff-type=noncompliant]
----
# order.py
from customer import Customer
from product import Product

class Order:
    def __init__(self):
        self.customer = Customer()
        self.products = []

# customer.py
from order import Order

class Customer:
    def __init__(self):
        self.orders = []

# product.py
from order import Order

class Product:
    def __init__(self):
        self.orders = []
----

==== Compliant solution

The issue can be resolved by refactoring the structure.
Two service functions can replace the dependencies `customer.py` &rarr; `order.py` and `product.py` &rarr; `order.py`.

[source,python,diff-id=1,diff-type=compliant]
----
# order.py
from customer import Customer
from product import Product

class Order:
    def __init__(self):
        self.customer = Customer()
        self.products = []

# customer.py
from order import Order

class Customer:
    def __init__(self):
        self.orders = []

# product.py
from order import Order

class Product:
    def __init__(self):
        self.orders = []
----

== Resources

- Wikipedia - https://en.wikipedia.org/wiki/Acyclic_dependencies_principle[Acyclic dependencies principle]
- STAN - https://stan4j.com/advanced/adp/[Acyclic dependencies principle]
- RSPEC - https://sonarsource.github.io/rspec/#/rspec/S7091/java[S7091: Circular dependencies between classes across package boundaries should be resolved]
