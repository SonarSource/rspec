<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This rule reports circular dependencies between source files, including indirect cycles spanning multiple files caused by circular imports.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Circular dependencies occur when two or more source files import each other, either directly or indirectly.
This creates a dependency structure that lacks a clear hierarchy, making the codebase harder to understand and maintain.
Additionally, the order in which circular imports are resolved is not guaranteed, which can lead to unpredictable behavior and runtime errors.</p>
</div>
<div class="sect2">
<h3 id="_what_is_the_potential_impact">What is the potential impact?</h3>
<div class="paragraph">
<p>Circular dependencies increase the complexity of the code architecture, reducing readability, extensibility, and maintainability.
As the project grows, these dependencies can spread, further complicating the architecture and increasing technical debt.
Over time, resolving these dependencies becomes increasingly difficult.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_fix_it">How to fix it</h2>
<div class="sectionbody">
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Refactor shared functionality</strong>: If multiple files share similar functionality, consider moving that functionality to a separate module that both can import. This allows each file to depend on the shared module rather than on each other.</p>
</li>
<li>
<p><strong>Use dependency inversion:</strong> Instead of directly importing modules that create circular dependencies, use dependency inversion by passing necessary functions or objects as parameters. This breaks the circular reference and makes the code more modular and testable.</p>
</li>
<li>
<p><strong>Split responsibilities</strong>: Evaluate whether each file is handling too many responsibilities. If so, break them down into smaller, more focused modules. This reduces circular dependencies and ensures that your code is easier to manage and extend.</p>
</li>
</ol>
</div>
<div class="sect2">
<h3 id="_code_examples">Code examples</h3>
<div class="sect3">
<h4 id="_noncompliant_code_example">Noncompliant code example</h4>
<div class="paragraph">
<p>The following code contains a circular dependency: <code>order.js</code> &rarr; <code>customer.js</code> &rarr; <code>order.js</code>, and <code>order.js</code> &rarr; <code>product.js</code> &rarr; <code>order.js</code>.
Both cycles are connected through <code>order.js</code>, forming a tangle of two cycles.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">// order.js
import { Customer } from './customer.js';
import { Product } from './product.js';

export class Order {
    constructor() {
        this.customer = new Customer();
        this.products = [];
    }
}

// customer.js
import { Order } from './order.js';

export class Customer {
    constructor() {
        this.orders = [];
    }
}

// product.js
import { Order } from './order.js';

export class Product {
    constructor() {
        this.orders = [];
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution">Compliant solution</h4>
<div class="paragraph">
<p>The issue can be resolved by refactoring the structure.
Two service functions can replace the dependencies <code>customer.js</code> &rarr; <code>order.js</code> and <code>product.js</code> &rarr; <code>order.js</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">// order.js
import { Customer } from './customer.js';
import { Product } from './product.js';

export class Order {
    constructor() {
        this.customer = new Customer();
        this.products = [];
    }
}

// customer.js
export class Customer { }

// product.js
export class Product { }

// orderService.js
export function getOrdersByCustomer(customer) {
    // Implementation to get orders by customer
}

export function getOrdersByProduct(product) {
    // Implementation to get orders by product
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>Wikipedia - <a href="https://en.wikipedia.org/wiki/Acyclic_dependencies_principle">Acyclic dependencies principle</a></p>
</li>
<li>
<p>STAN - <a href="https://stan4j.com/advanced/adp/">Acyclic dependencies principle</a></p>
</li>
<li>
<p>RSPEC - <a href="https://sonarsource.github.io/rspec/#/rspec/S7091/java">S7091: Circular dependencies between classes across package boundaries should be resolved</a></p>
</li>
</ul>
</div>
</div>
</div>