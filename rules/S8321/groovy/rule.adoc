This is an issue when a method accepts a `Closure` parameter and delegates calls to a specific object without using the `@DelegatesTo` annotation.

== Why is this an issue?

When building Domain-Specific Languages (DSLs) in Groovy, methods often accept closures and delegate method calls to specific objects using the builder pattern. Without the `@DelegatesTo` annotation, several problems arise:

**IDE Support Issues**: IDEs cannot provide intelligent code completion within closure bodies because they don't know which methods are available on the delegate object. Developers lose valuable tooling support when writing DSL code.

**Static Type Checking Problems**: When using `@TypeChecked` or `@CompileStatic`, the compiler cannot verify that method calls within the closure are valid. This leads to compilation errors even for correct code, or forces developers to disable static checking for DSL code.

**Documentation Gap**: Without explicit annotation, there's no clear indication of what object the closure delegates to, making the API harder to understand and maintain.

The `@DelegatesTo` annotation was specifically introduced in Groovy 2.1 to solve these problems by providing compile-time hints about delegation strategy and delegate types.

=== What is the potential impact?

Missing `@DelegatesTo` annotations can significantly impact developer productivity and code quality:

* **Reduced IDE Support**: Developers lose code completion, method suggestions, and error highlighting within DSL closures
* **Compilation Issues**: Static type checking fails on valid DSL code, forcing developers to either disable type checking or add unnecessary type casts
* **Poor Developer Experience**: Writing DSL code becomes more error-prone without proper tooling support
* **Maintenance Difficulties**: APIs become harder to understand and document without explicit delegation information

== How to fix it

Add the @DelegatesTo annotation to closure parameters, specifying both the delegation strategy and the target class. Include the strategy parameter when using non-default delegation strategies like DELEGATE_ONLY.

=== Code examples

==== Noncompliant code example

[source,groovy,diff-id=1,diff-type=noncompliant]
----
def email(Closure cl) {
    def email = new EmailSpec()
    def code = cl.rehydrate(email, this, this)
    code.resolveStrategy = Closure.DELEGATE_ONLY // Noncompliant
    code()
}
----

==== Compliant solution

[source,groovy,diff-id=1,diff-type=compliant]
----
def email(@DelegatesTo(strategy=Closure.DELEGATE_ONLY, value=EmailSpec) Closure cl) {
    def email = new EmailSpec()
    def code = cl.rehydrate(email, this, this)
    code.resolveStrategy = Closure.DELEGATE_ONLY
    code()
}
----

== Resources

=== Documentation

 * Groovy Documentation - @DelegatesTo - https://docs.groovy-lang.org/latest/html/documentation/core-domain-specific-languages.html#section-delegatesto[Official Groovy documentation explaining @DelegatesTo annotation and its various modes]

 * Groovy DSL Guide - http://groovy-lang.org/dsls.html[Comprehensive guide to building Domain-Specific Languages in Groovy]
