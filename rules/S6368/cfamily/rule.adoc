In contrast to normal functions, a coroutine can suspend and later resume its execution.
Therefore, it cannot keep all of its local variables on the stack and must place them on the heap-allocated storage.

The use of heap storage is unavoidable for variables that are accessed across the suspension points. 
The stack storage is still suitable for variables whose lifetime doesn't span over any suspension point (i.e. there is no suspension point between their construction and destruction).
Moreover, a variable that is visible after the final suspension point, but never actually referenced after it, requires heap storage 
to ensure its destructor will properly run at the end of its scope.
While in some situations the compiler may still be able to optimize such a variable by calling its destructor earlier,
manually adjusting its scope declaration by placing it inside a nested block guarantees this effect.

This rule raises an issue, for variables that are not visible but not used after a coroutine is suspended.

== Noncompliant Code Example

----
generator<std::string> generatePermutation(std::string start) {
  std::array<std::string, 100> precomputed = precomputeElements<100>(start); // Noncompliant
  for (auto const& p : precomputed) {
    co_yield p;
  }

  std::string last = std::move(precompted.back());
  std::array<std::string, 20> context;
  for (;;) {
    last = computeNext(context, last); 
    co_yield last;
  }
  // precomputed and context are available here
  // potentially requring heap space
}
----

== Compliant Solution

----
generator<std::string> generatePermutation(std::string start) {
{
   std::string last;
   {
     std::array<int, 100> precomputed = precomputeElements<100>(start);
     for (auto const& p : precomputed) {
       co_yield p;
     last = std::move(precomputed.back());
   }

   std::array<int, 20> context;
   for (;;) {
     last = computeNext(context, last); 
     co_yield last;
   }
}
----
