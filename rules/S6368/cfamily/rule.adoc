In contrast to normal functions, a coroutine can suspend and later resume its execution. i
Therefore, it cannot keep all of its local variables on the stack and place them on the heap-allocated storage. 

The use of heap storage is unavoidable for variables that are accessed across the suspension points. 
The stack storage is still suitable for the variables that are created and destroyed before the coroutine is suspended again.
Finally, a variable that is visible after suspension, but never actually referenced after it, requires heap storage, 
so destructor that will run at the end scope can access it.
While in some situations, the compiler may still be able to optimize such variable, by calling it destruct earlier,
manually adjusting scope declaration by placing it inside the nested block, guarantees this effect.

This rule raises an issue, for variables that are not visible but not used after a coroutine is suspended.

== Noncompliant Code Example

----
generator<std::string> generatePermutation(std::string start) {
  std::array<std::string, 100> precomputed = precomputeElements<100>(start); // Noncompliant
  for (auto const& p : precomputed) {
    co_yield p;
  }

  std::string last = std::move(precompted.back());
  std::array<std::string, 20> context;
  for (;;) {
    last = computeNext(context, last); 
    co_yield last;
  }
  // precomputed and context are available here
  // potentially requring heap space
}
----

== Compliant Solution

----
generator<std::string> generatePermutation(std::string start) {
{
   std::string last;
   {
     std::array<int, 100> precomputed = precomputeElements<100>(start);
     for (auto const& p : precomputed) {
       co_yield p;
     last = std::move(precomputed.back());
   }

   std::array<int, 20> context;
   for (;;) {
     last = computeNext(context, last); 
     co_yield last;
   }
}
----
