In contrast to normal functions, a coroutine can suspend and later resume its execution.
Therefore, it cannot keep all of its local variables on the stack and must place them on the heap-allocated storage.

The use of heap storage is unavoidable for variables that are accessed across the suspension points. 
The stack storage is still suitable for variables whose lifetime doesn't span over any suspension point (i.e., there is no suspension point between their construction and destruction).
Moreover, a variable that is visible after the final suspension point, but never actually referenced after it, requires heap storage 
to ensure its destructor will properly run at the end of its scope.
While in some situations, the compiler may still be able to optimize such a variable by calling its destructor earlier,
manually adjusting its scope declaration by placing it inside a nested block guarantees this effect.

This rule raises an issue for variables that are visible but not used starting after a
suspension point (`co_await` or `co_yield` expressions).

== Noncompliant Code Example

----
task<void> serveRequest(Socket& socket) {
  std::string reqData = co_await read_request(socket); // Noncompliant
  Request req = Request::parse(reqData); // Noncompliant
  Response res = prepareResponse(req); // Noncompliant
  std::string responseData = Response::serialize(res);
  co_await send_response(socket, responseData);
}

generator<std::string> generatePermutation(std::string start) {
  std::array<std::string, 100> precomputed = precomputeElements<100>(start); // Noncompliant
  for (auto const& p : precomputed) {
    co_yield p;
  }

  std::string last = std::move(precompted.back());
  std::array<std::string, 20> context;
  for (;;) {
    last = computeNext(context, last); 
    co_yield last;
  }
  // precomputed and context are available here
  // potentially requring heap space
}
----

== Compliant Solution

----
task<void> serveRequest(Socket& socket) {
  std::string responseData;
  {
    std::string reqData = co_await read_request(socket);
    Request req = Request::parse(reqData);
    Response res = prepareResponse(req);
    responseData = Response::serialize(res);
  }
  co_await send_response(socket, responseData);
}

generator<std::string> generatePermutation(std::string start) {
{
   std::string last;
   {
     std::array<std::string, 100> precomputed = precomputeElements<100>(start);
     for (auto const& p : precomputed) {
       co_yield p;
     last = std::move(precomputed.back());
   }

   std::array<std::string, 20> context;
   for (;;) {
     last = computeNext(context, last); 
     co_yield last;
   }
   // precomputed and context can use the same heap storage, reducing the memory footprint
}
----
