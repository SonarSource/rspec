<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In contrast to normal functions, a coroutine can suspend and later resume its execution.
Therefore, it cannot keep all of its local variables on the stack and must place them on the heap-allocated storage.</p>
</div>
<div class="paragraph">
<p>The use of heap storage is unavoidable for variables that are accessed across the suspension points.
The stack storage is still suitable for variables whose lifetime doesn&#8217;t span over any suspension point (i.e., there is no suspension point between their construction and destruction).
Moreover, a variable that is visible after the final suspension point, but never actually referenced after it, requires heap storage
to ensure its destructor will properly run at the end of its scope.
While in some situations, the compiler may still be able to optimize such a variable by calling its destructor earlier,
manually adjusting its scope declaration by placing it inside a nested block guarantees this effect.</p>
</div>
<div class="paragraph">
<p>This rule raises an issue for variables that are visible but not used starting after a
suspension point (<code>co_await</code> or <code>co_yield</code> expressions).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_noncompliant_code_example">Noncompliant Code Example</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre>task&lt;void&gt; serveRequest(Socket&amp; socket) {
  std::string reqData = co_await read_request(socket); // Noncompliant
  Request req = Request::parse(reqData); // Noncompliant
  Response res = prepareResponse(req); // Noncompliant
  std::string responseData = Response::serialize(res);
  co_await send_response(socket, responseData);
}

generator&lt;std::string&gt; generatePermutation(std::string start) {
  std::array&lt;std::string, 100&gt; precomputed = precomputeElements&lt;100&gt;(start); // Noncompliant
  for (auto const&amp; p : precomputed) {
    co_yield p;
  }

  std::string last = std::move(precompted.back());
  std::array&lt;std::string, 20&gt; context;
  for (;;) {
    last = computeNext(context, last);
    co_yield last;
  }
  // precomputed and context are available here
  // potentially requring heap space
}</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_compliant_solution">Compliant Solution</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre>task&lt;void&gt; serveRequest(Socket&amp; socket) {
  std::string responseData;
  {
    std::string reqData = co_await read_request(socket);
    Request req = Request::parse(reqData);
    Response res = prepareResponse(req);
    responseData = Response::serialize(res);
  }
  co_await send_response(socket, responseData);
}

generator&lt;std::string&gt; generatePermutation(std::string start) {
{
   std::string last;
   {
     std::array&lt;std::string, 100&gt; precomputed = precomputeElements&lt;100&gt;(start);
     for (auto const&amp; p : precomputed) {
       co_yield p;
     last = std::move(precomputed.back());
   }

   std::array&lt;std::string, 20&gt; context;
   for (;;) {
     last = computeNext(context, last);
     co_yield last;
   }
   // precomputed and context can use the same heap storage, reducing the memory footprint
}</pre>
</div>
</div>
</div>
</div>