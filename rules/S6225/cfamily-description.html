<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>For the integration with the C or just older APIs, it may be useful to convert a contiguous iterator to a raw pointer to the element.
In C&#43;&#43;20 <code>std::to_address</code> was introduced to perform this operation on both iterators and smart pointers, which supersedes non-portable and potentially buggy workarounds, that were required before:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The first option was to take the address of the element pointed by the iterator: <code>&amp;*it</code>. However, this operation has undefined behavior if the iterator is not pointing to any element. This may happen for the iterator returned by a call to <code>end()</code> on the container. This may also be the case when we need the address to construct a new object (via placement new) at the location pointed to by the iterator. <code>std::to_address(it)</code> works in such cases.</p>
</li>
<li>
<p>The second option was to exploit the nature of <code>operator-&gt;</code> overloading and call it explicitly on the iterator: <code>it.operator-&gt;()</code>. This option avoids the pitfalls of the previous one, at the cost of not being portable. It would fail on the implementations that use raw-pointers as iterators for contiguous ranges like <code>std::vector</code> or <code>std::span</code>. Moreover, it is confusing, as this functional notation syntax for operators is rarely used.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>While both <code>std::to_address</code> and above workarounds, can be always used to get the address of the element that the iterator is pointing to (if any), incrementing or decrementing may have undefined behavior.
Performing pointer arithmetic on pointer to elements is safe only in the case of contiguous iterators (e.g. iterators of <code>std::vector</code>, <code>std::array</code>, <code>std::span</code>, <code>std::string</code> or <code>std::string_view</code>).</p>
</div>
<div class="paragraph">
<p>This rule raises an issue when dereferencing a pointer-like object is immediately followed by taking the address of the result (<code>&amp;*x</code> or <code>std::addressof(*x)</code>) or when <code>operator-&gt;</code> is called through an explicit functional notation (<code>x.operator-&gt;()</code>).</p>
</div>
<div class="sect2">
<h3 id="_noncompliant_code_example">Noncompliant code example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">void check(int* b, int* e);

void func1(std::vector&lt;int&gt;&amp; v) {
    check(v.begin().operator-&gt;(), v.end().operator-&gt;()); // Noncompliant
}

void func2(span&lt;int&gt; s) {
     check(&amp;*s.begin(), &amp;*s.end()); // Noncompliant
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_compliant_solution">Compliant solution</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">void func1(std::vector&lt;int&gt;&amp; v) {
    check(std::to_address(v.begin()), std::to_address(v.end()));
}

void func2(span&lt;int&gt; s) {
     check(std::to_address(s.begin()), std::to_address(s.end()));
}</code></pre>
</div>
</div>
</div>
</div>
</div>