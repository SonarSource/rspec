<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When inheritance is used, the code of the class becomes less clear, as the declarations of members used in the implementation are not visible from the class declaration and requires inspection of the class hierarchy. This is even more prominent in the case of templates that derive from their parameters, as the members of the base are unknown until the template is instantiated.</p>
</div>
<div class="paragraph">
<p>In the case of private inheritance, those drawbacks are usually not offset by the benefits of runtime polymorphism: this class cannot be passed to functions accepting base class, and children of this class cannot access the base class features. As a consequence, replacing a private base class with a named member of the same type often improves the clarity of the code.</p>
</div>
<div class="paragraph">
<p>However, one of the reasons for using private inheritance instead of composition is that it allows the compiler to not allocate additional space for the empty member - this is known as Empty Base Optimization (EBO). Since C&#43;&#43;20, the same effect can be achieved, more clearly, by declaring members with the <code>[[no_unique_address]]</code> attribute. Therefore, using private inheritance just for this space optimization is no longer required.</p>
</div>
<div class="paragraph">
<p>This rule reports an issue on classes that has private bases class that can be replaced with a member.</p>
</div>
<div class="sect2">
<h3 id="_noncompliant_code_example">Noncompliant code example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">struct Thingy {
  /* .... */
};

struct Widget : private Thingy { // Noncompliant
   /* .... */
};

template&lt;typename Value, typename Alloc&gt;
class Vector :  Alloc { // Noncompliant
   /* .... */
};</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_compliant_solution">Compliant solution</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">/* ... */

struct Widget {
   /* .... */
private:
   Thingy thingy;
};

template&lt;typename Value, typename Alloc&gt;
class Vector {
   /* .... */
   [[no_unique_address]] Alloc alloc;
};</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_exceptions">Exceptions</h3>
<div class="paragraph">
<p>In a situation when the derived class overrides virtual member functions of the base class (to customize its behavior), it is not possible to eliminate inheritance itself. The rule does not raise issues in such cases, as writing alternative code that would avoid private inheritance is less straightforward and has fewer benefits.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a data-rspec-id="S6226" class="rspec-auto-link">S6226</a> - Empty class members should be marked as "[[no_unique_address]]"</p>
</li>
</ul>
</div>
<hr>
</div>
</div>
<div class="sect1">
<h2 id="_comments_and_links">Comments And Links</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_relates_to_s6226">relates to: <a data-rspec-id="S6226" class="rspec-auto-link">S6226</a></h3>

</div>
</div>
</div>