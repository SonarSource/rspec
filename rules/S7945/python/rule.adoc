This rule raises an issue when `isinstance()` checks are used to differentiate between string parts and `Interpolation` objects while processing template strings, instead of using structural pattern matching with `match`/`case` statements.

== Why is this an issue?

When processing template strings introduced in PEP 750, using `isinstance()` checks to handle different types of template components results in verbose and less readable code. PEP 750 specifically recommends using structural pattern matching as the best practice for template processing.

Structural pattern matching with `match`/`case` statements provides several advantages:

* **Cleaner syntax**: The pattern matching syntax is more concise and expressive than multiple `isinstance()` checks
* **Better readability**: The intent is clearer when using pattern matching to handle different types
* **Follows PEP recommendations**: PEP 750 explicitly recommends this approach as the expected best practice
* **More Pythonic**: Pattern matching is the modern Python way to handle type-based dispatching

Using `isinstance()` checks makes the code more verbose and harder to maintain, especially when processing complex templates with multiple types of components.

=== What is the potential impact?

Using `isinstance()` checks instead of structural pattern matching when processing template strings results in more verbose, less readable code that doesn't follow the recommended patterns from PEP 750. While functionally equivalent, it makes the codebase harder to maintain and understand.

=== How to fix?


Replace `isinstance()` checks with structural pattern matching using `match`/`case` statements. Use type patterns like `str()` and `Interpolation()` to handle different template components.

==== Non-compliant code example

[source,python,diff-id=1,diff-type=noncompliant]
----
def process_template(template):
    result = []
    for item in template:
        if isinstance(item, str):  # Noncompliant
            result.append(item.lower())
        elif isinstance(item, Interpolation):  # Noncompliant
            result.append(str(item.value).upper())
    return ''.join(result)
----

==== Compliant code example

[source,python,diff-id=1,diff-type=compliant]
----
def process_template(template):
    result = []
    for item in template:
        match item:
            case str() as s:
                result.append(s.lower())
            case Interpolation() as interp:
                result.append(str(interp.value).upper())
    return ''.join(result)
----

=== Documentation

 * PEP 750 - Template Strings - https://peps.python.org/pep-0750/[The official PEP introducing template strings and recommending structural pattern matching for processing]
 * PEP 634 - Structural Pattern Matching - https://peps.python.org/pep-0634/[The PEP that introduced structural pattern matching to Python]
 * Python Pattern Matching Documentation - https://docs.python.org/3/tutorial/controlflow.html#match-statements[Official Python documentation on match statements and pattern matching]

