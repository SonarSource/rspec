This rule raises an issue when an identity comparison operator is used to compare objects of different types.

== Why is this an issue?

Operators https://docs.python.org/3/reference/expressions.html#is-not[``++is++``] and https://docs.python.org/3/reference/expressions.html#is-not[``++is not++``] check if their operands point to the same instance, thus they will always return respectively True and False when they are used to compare objects of different types. Such comparisons can only be bugs.

=== Code examples

==== Noncompliant code example

[source,python,diff-id=1,diff-type=noncompliant]
----
a = 1
b = "1"
value = a is b  # Noncompliant. Always False
value = a is not b  # Noncompliant. Always True
----

==== Compliant solution

[source,python,diff-id=1,diff-type=compliant]
----
a = 1
b = 1
value = a is b
value = a is not b
----

== Resources

=== Documentation

* Python documentation - https://docs.python.org/3/reference/expressions.html#is-not[Identity comparisons]

ifdef::env-github,rspecator-view[]

'''
== Implementation Specification
(visible only on this page)

=== Message

Remove this ["is"|"is not"] check between types X and Y; it will always be [False|True].


include::../highlighting.adoc[]

'''
== Comments And Links
(visible only on this page)

include::../comments-and-links.adoc[]

endif::env-github,rspecator-view[]
