<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Starting <code>C&#43;&#43;17</code>, you can use <code>auto</code> and <code>decltype(auto)</code> to declare non-type template parameters. This new feature provides a way to write generic code for non-type parameters of different types. Also, it allows, by using variadic templates, to make a template take a list of non-type template parameters of different types: <code>template&lt;auto... VS&gt; class A</code>.</p>
</div>
<div class="paragraph">
<p>If the type is used in the template definition, you can replace it with <code>auto</code>, or <code>decltype</code> if you want to underline that the type is the same as of the template parameter. Note, that you can use <code>template &lt;class T&gt; T packed_t(T...);</code> to get the type of arguments in the <code>auto...</code> pack (see the "Compliant Solution" section below).</p>
</div>
<div class="paragraph">
<p>This rule detects the common pattern where a type template parameter is introduced only to be used as a type for the next non-type template parameter(s).</p>
</div>
<div class="sect2">
<h3 id="_noncompliant_code_example">Noncompliant code example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">template &lt;typename T, T value&gt;
struct A { // Noncompliant
  inline static auto field = value;
  typedef T type;
  static T anotherField;
};

template &lt;typename T, T... values&gt;
struct MultiA { // Noncompliant
  inline static std::vector vec = { values... };
};

template &lt;typename T, T defaultVal&gt;
T foo(T arg) {
  return arg &gt; 0 ? arg : defaultVal;
}

void f() {
  A&lt;int, 1&gt; a1;
  A&lt;bool, false&gt; a2;
  MultiA&lt;int, 1, 2, 3, 4&gt; multiA1;
  MultiA&lt;char, 'a', 'b'&gt; multiA2;
  foo&lt;int, 1&gt;(-1);
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_compliant_solution">Compliant solution</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">template &lt;auto value&gt;
struct A { // Compliant
  inline static auto field = value;
  typedef decltype(value) type;
  static type anotherField;
};

template &lt;auto ... values&gt;
struct MultiA { // Compliant
  inline static std::vector vec = { values... };
};

template &lt;auto defaultVal&gt;
auto foo(decltype(defaultVal) arg) {
  return arg &gt; 0 ? arg : defaultVal;
}

void f() {
  A&lt;1&gt; a1;
  A&lt;false&gt; a2;
  MultiA&lt;1, 2, 3, 4&gt; multiA1;
  MultiA&lt;'a', 'b'&gt; multiA2;
  foo&lt;1&gt;(-1);
}

// Get the type out of auto... declaration
template &lt;class T&gt;
T packed_t(T...);

template &lt;auto... Is&gt;
std::vector&lt;std::string&gt; name_copy(std::map&lt;decltype(packed_t(Is...)), std::string&gt; names) {
  return {names[Is]...};
}</code></pre>
</div>
</div>
</div>
</div>
</div>