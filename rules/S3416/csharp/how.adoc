== How to fix it

When the logger name is defined by a generic type parameter:

[source,csharp]
----
class EnclosingType
{
    private readonly ILogger _logger;

    public EnclosingType(ILoggerFactory loggerFactory)
    {
        _logger = loggerFactory.CreateLogger<AnotherType>();   // Noncompliant
        _logger = loggerFactory.CreateLogger<EnclosingType>(); // Compliant
    }
}
----

When the logger name is defined by an input parameter of type `Type`:

[source,csharp]
----
class EnclosingType
{
    private readonly ILogger _logger;

    public EnclosingType(ILoggerFactory loggerFactory)
    {
        _logger = loggerFactory.CreateLogger(typeof(AnotherType));   // Noncompliant
        _logger = loggerFactory.CreateLogger(typeof(EnclosingType)); // Compliant
        _logger = loggerFactory.CreateLogger(GetType());             // Compliant
    }
}
----

When the logger name is a string, derived from a `Type`:

[source,csharp]
----
class EnclosingType
{
    private readonly ILogger _logger;

    public EnclosingType(ILoggerFactory loggerFactory)
    {
        _logger = loggerFactory.CreateLogger(typeof(AnotherType).Name);       // Noncompliant        
        _logger = loggerFactory.CreateLogger(typeof(AnotherType).FullName);   // Noncompliant
        _logger = loggerFactory.CreateLogger(nameof(AnotherType));            // Noncompliant
        // Fix by referring to the right type
        _logger = loggerFactory.CreateLogger(typeof(EnclosingType).Name);     // Compliant
        _logger = loggerFactory.CreateLogger(typeof(EnclosingType).FullName); // Compliant
        _logger = loggerFactory.CreateLogger(nameof(EnclosingType));          // Compliant
        // or by retrieving the right type dynamically
        _logger = loggerFactory.CreateLogger(GetType().FullName);             // Compliant
    }
}
----

