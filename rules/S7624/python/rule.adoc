This rule raises an issue when JUnit 5 tests use try-catch blocks, generic exception types, or deprecated annotation parameters for exception testing instead of the appropriate assertion methods.

== Why is this an issue?

JUnit 5 provides dedicated assertion methods like `assertThrows` and `assertDoesNotThrow` that are specifically designed for exception testing. These methods offer several advantages over older approaches:

Using try-catch blocks with `fail()` calls makes the test intent less clear and requires more boilerplate code. The test logic becomes scattered across multiple lines, making it harder to understand what behavior is being verified.

Generic exception types like `Exception.class` or `RuntimeException.class` in `assertThrows` create overly broad assertions that can hide unexpected exceptions. If the code throws a different exception than intended, the test will still pass, potentially masking real issues.

JUnit 4 annotation parameters like `@Test(expected=Exception.class)` are not supported in JUnit 5 and will cause compilation errors. Additionally, these annotations don't allow for validation of exception properties like messages or causes.

The `assertThrows` method returns the caught exception, enabling additional assertions on the exception's properties. This capability is lost when using try-catch blocks or when ignoring the return value of `assertThrows`.

=== What is the potential impact?

Using outdated exception testing patterns can lead to several problems:

* *Reduced test reliability*: Generic exception types may allow unexpected exceptions to pass tests, hiding bugs in the application code.
* *Poor maintainability*: Try-catch blocks with `fail()` calls create verbose, hard-to-read test code that is more difficult to maintain and understand.
* *Compilation errors*: Using JUnit 4 annotation parameters in JUnit 5 will prevent the code from compiling.
* *Missed validation opportunities*: Not capturing exception properties means important details like error messages or root causes go unverified, reducing test coverage quality.

=== How to fix in JUnit 5?

Replace try-catch blocks with assertThrows and capture the exception to validate its properties.

==== Non-compliant code example

[source,java,diff-id=1,diff-type=noncompliant]
----
@Test
void testException() {
    try {
        Integer.parseInt("1a");
        fail("Expected NumberFormatException"); // Noncompliant
    } catch (NumberFormatException e) {
        assertTrue(e.getMessage().contains("For input string"));
    }
}
----

==== Compliant code example

[source,java,diff-id=1,diff-type=compliant]
----
@Test
void testException() {
    NumberFormatException exception = assertThrows(NumberFormatException.class, () -> {
        Integer.parseInt("1a");
    });
    assertTrue(exception.getMessage().contains("For input string"));
}
----

Use assertDoesNotThrow instead of try-catch blocks when testing that no exception is thrown.

==== Non-compliant code example

[source,java,diff-id=2,diff-type=noncompliant]
----
@Test
void testNoException() {
    try {
        Integer.parseInt("100");
    } catch (Exception e) {
        fail("Unexpected exception: " + e.getMessage()); // Noncompliant
    }
}
----

==== Compliant code example

[source,java,diff-id=2,diff-type=compliant]
----
@Test
void testNoException() {
    assertDoesNotThrow(() -> {
        Integer.parseInt("100");
    });
}
----

Use specific exception types instead of generic ones to make tests more precise.

==== Non-compliant code example

[source,java,diff-id=3,diff-type=noncompliant]
----
@Test
void testGenericException() {
    assertThrows(Exception.class, () -> { // Noncompliant
        Integer.parseInt("1a");
    });
}
----

==== Compliant code example

[source,java,diff-id=3,diff-type=compliant]
----
@Test
void testSpecificException() {
    assertThrows(NumberFormatException.class, () -> {
        Integer.parseInt("1a");
    });
}
----

Replace JUnit 4 annotation parameters with JUnit 5 assertion methods.

==== Non-compliant code example

[source,java,diff-id=4,diff-type=noncompliant]
----
@Test(timeout = 1000) // Noncompliant
void testWithTimeout() {
    // test code
}
----

==== Compliant code example

[source,java,diff-id=4,diff-type=compliant]
----
@Test
void testWithTimeout() {
    assertTimeout(Duration.ofMillis(1000), () -> {
        // test code
    });
}
----

=== Documentation

 * JUnit 5 User Guide - Assertions - https://junit.org/junit5/docs/current/user-guide/#writing-tests-assertions[Official JUnit 5 documentation covering all assertion methods including exception testing]
 * Baeldung - Assert an Exception is Thrown in JUnit 4 and 5 - https://www.baeldung.com/junit-assert-exception[Comprehensive guide comparing exception testing approaches in JUnit 4 and JUnit 5]
 * JUnit 5 Migration Guide - https://junit.org/junit5/docs/current/user-guide/#migrating-from-junit4[Official migration guide from JUnit 4 to JUnit 5 covering assertion changes]

=== Standards

 * OWASP ASVS-14.2.1: Unit Test Coverage - https://owasp.org/www-project-application-security-verification-standard/[Emphasizes the importance of comprehensive unit testing with proper assertion practices]

=== Related Rules

 * RSPEC-5783 - https://rules.sonarsource.com/java/RSPEC-5783/[JUnit 5 @Test annotation should not have any parameters]
 * RSPEC-5785 - https://rules.sonarsource.com/java/RSPEC-5785/[JUnit 5 tests should use Assertions class for assertions]

