This rule raises an issue when a Component, Directive, or Pipe explicitly sets `standalone: false` in its decorator configuration.

== Why is this an issue?

Angular's standalone feature simplifies application architecture by eliminating the need for NgModules in many scenarios. Standalone components, directives, and pipes can be used directly without being declared in an NgModule, making the codebase more modular and easier to maintain.

When you explicitly set `standalone: false`, you're opting out of this modern approach and forcing the use of the older NgModule-based architecture. This creates unnecessary complexity and goes against Angular's current best practices.

Standalone architecture offers several benefits:

* Reduced boilerplate code by eliminating NgModule declarations
* Better tree-shaking and smaller bundle sizes
* Simplified testing with fewer dependencies
* More intuitive component composition
* Easier migration path for future Angular versions

=== What is the potential impact?

Using `standalone: false` unnecessarily increases application complexity and maintenance overhead. It forces developers to manage NgModule declarations and imports, which can lead to circular dependencies and harder-to-debug issues. Additionally, it may result in larger bundle sizes due to less effective tree-shaking.

=== How to fix in Angular?

Remove the `standalone: false` property to use the default standalone behavior, or explicitly set it to `true`.

==== Non-compliant code example

[source,typescript,diff-id=1,diff-type=noncompliant]
----
@Component({
  standalone: false, // Noncompliant
  template: '<div>Hello</div>'
})
class MyComponent {}
----

==== Compliant code example

[source,typescript,diff-id=1,diff-type=compliant]
----
@Component({
  template: '<div>Hello</div>'
})
class MyComponent {}

// Or explicitly set to true
@Component({
  standalone: true,
  template: '<div>Hello</div>'
})
class MyComponent {}
----

For Directives, remove `standalone: false` to enable standalone architecture.

==== Non-compliant code example

[source,typescript,diff-id=2,diff-type=noncompliant]
----
@Directive({
  selector: '[myDirective]',
  standalone: false // Noncompliant
})
class MyDirective {}
----

==== Compliant code example

[source,typescript,diff-id=2,diff-type=compliant]
----
@Directive({
  selector: '[myDirective]'
})
class MyDirective {}
----

For Pipes, remove `standalone: false` to use standalone architecture.

==== Non-compliant code example

[source,typescript,diff-id=3,diff-type=noncompliant]
----
@Pipe({
  name: 'myPipe',
  standalone: false // Noncompliant
})
class MyPipe {}
----

==== Compliant code example

[source,typescript,diff-id=3,diff-type=compliant]
----
@Pipe({
  name: 'myPipe'
})
class MyPipe {}
----

=== Documentation

* https://github.com/angular-eslint/angular-eslint[Angular ESLint] - Rule https://github.com/angular-eslint/angular-eslint/blob/main/packages/eslint-plugin/docs/rules/prefer-standalone.md[prefer-standalone]
 * Angular Standalone Components Guide - https://angular.dev/guide/components/importing[Official Angular documentation on standalone components and their benefits]
 * Angular Standalone APIs - https://angular.dev/guide/standalone-components[Comprehensive guide to Angular's standalone APIs and migration strategies]

