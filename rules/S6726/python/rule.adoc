This rule raises an issue when an iteration with a condition is used instead of ``++np.where++``.

== Why is this an issue?

Computation over NumPy arrays can be executed more efficiently than computation over Pythonâ€™s built-in sequences. This is due to the nature of the NumPy array (fixed size and homogeneous) as well as operations on these arrays that can be done with compiled code.

When executing an operation on each elements of an array depending on a condition it is preferable to use NumPy ``++np.where++`` function instead, which can benefit from NumPy broadcasting.

//=== What is the potential impact?

== How to fix it
//== How to fix it in FRAMEWORK NAME

=== Code examples

==== Noncompliant code example

[source,text,diff-id=1,diff-type=noncompliant]
----
FIXME
----

==== Compliant solution

[source,text,diff-id=1,diff-type=compliant]
----
FIXME
----

//=== How does this work?

//=== Pitfalls

//=== Going the extra mile


//== Resources
//=== Documentation
//=== Articles & blog posts
//=== Conference presentations
//=== Standards
//=== External coding guidelines
//=== Benchmarks
