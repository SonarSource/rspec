This rule raises an issue when an iteration with a condition is used instead of ``++np.where++``.

== Why is this an issue?

Computation over NumPy arrays can be executed more efficiently than computation over Pythonâ€™s built-in sequences. 
This is due to the nature of the NumPy arrays (fixed size and homogeneous) as well as operations on these arrays which can be done with compiled code.

When executing an operation on each element of an array depending on a condition,
it is preferable to use the NumPy ``++np.where++`` function instead. 
``++np.where++`` provides better performance by benefiting from NumPy broadcasting operations.

Broadcasting is the term used to describe how NumPy treats arrays of different shape during arithmetic operations. 
When applying an operation on two arrays of the same shape NumPy will work on each element of the arrays one by one. 

[source,python]
----
import numpy as np
a = np.array([1, 2, 3])

b = np.array([2, 3, 4])
a + b # result: [3, 5, 7]
----

A good way to think of what happens in the example above is that, first, a list of tuples is created for each pair of elements from each array, 
i.e. ``++[(1,2),(2,3),(3,4)]++`` then for each of these pair the ``+++++`` operation is applied.

Here is a similar example, except the operation is performed on arrays of different shapes:

[source,python]
----
import numpy as np

a = np.array([1, 2, 3])
b = np.array(5)
a + b # result: [6, 7, 8]
----

This is a concrete example of broadcasting where the variable ``++b++`` is broadcasted to the size of the array ``++a++``. 
If we use the same intermediate representation as before it would look like this: ``++[(1,5),(2,5),(3,5)]++``.
NumPy "stretched" the variable ``++b++`` from a single value ``++5++`` to an array of 3 elements, resulting in the following array ``++[5, 5, 5]++``. 
The arithmetic operation can then be applied on two arrays of the same size.
When a value is broadcasted, it allows NumPy to run array operations in C instead of Python, 
thus allowing for better performance.


== How to fix it

To fix this issue replace the iteration and condition with the ``++np.where++`` function.

=== Code examples

==== Noncompliant code example

[source,python,diff-id=1,diff-type=noncompliant]
----
import numpy as np

def divide_by_two(arr: np.ndarray):
  for i in range(len(arr)):
    if (arr[i] % 2) == 0:
        arr[i] = arr[i] / 2 # Noncompliant: this computation can be done more efficiently with the np.where function
    else:
        arr[i] = 0

  return arr 
----

==== Compliant solution

[source,python,diff-id=1,diff-type=compliant]
----
import numpy as np

def divide_by_two(arr: np.ndarray):
   return (np.where((arr % 2 == 0), arr / 2, 0)) # Compliant
----


== Resources

=== Documentation

* NumPy Documentation - https://numpy.org/doc/stable/reference/generated/numpy.where.html#numpy-where[numpy.where]

=== Articles & blog posts

* POP Article - https://co-design.pop-coe.eu/best-practices/numba-numpy-python-serial-efficiency.html[numba-numpy-python-serial-efficiency]

//=== Conference presentations
//=== Standards
//=== External coding guidelines
//=== Benchmarks
