This rule raises an issue when an iteration with a condition is used instead of ``++np.where++``.

== Why is this an issue?

Computation over NumPy arrays can be executed more efficiently than computation over Pythonâ€™s built-in sequences. 
This is due to the nature of the NumPy array (fixed size and homogeneous) as well as operations on these arrays which can be done with compiled code.

When executing an operation on each element of an array depending on a condition,
it is preferable to use NumPy ``++np.where++`` function instead. 
``++np.where++`` provides better performances by benefiting from NumPy broadcasting operations.


== How to fix it

To fix this issue replace the iteration and condition with the ``++np.where++`` function.

=== Code examples

==== Noncompliant code example

[source,python,diff-id=1,diff-type=noncompliant]
----
import numpy as np

def divide_by_two(arr: np.ndarray):
  for i in range(len(arr)):
    if (arr[i] % 2) == 0:
        arr[i] = arr[i] / 2 # Noncompliant: this computation can be done more efficiently with the np.where function
    else:
        arr[i] = 0

  return arr 
----

==== Compliant solution

[source,python,diff-id=1,diff-type=compliant]
----
import numpy as np

def divide_by_two(arr: np.ndarray):
   return (np.where((arr % 2 == 0), arr / 2, 0)) # Compliant
----


== Resources

=== Documentation

NumPy Documentation - https://numpy.org/doc/stable/reference/generated/numpy.where.html#numpy-where[numpy.where]

=== Articles & blog posts

POP Article - https://co-design.pop-coe.eu/best-practices/numba-numpy-python-serial-efficiency.html[numba-numpy-python-serial-efficiency]

//=== Conference presentations
//=== Standards
//=== External coding guidelines
//=== Benchmarks
