It is a best practice to make lambda return types implicit whenever possible.
First and foremost, doing so avoids implicit conversions, which could result in data or precision loss.
Second, omitting the return type helps future-proof the code.

The issue is raised when the explicitly specified return type is equivalent to the one that would be deduced by the compiler.

== Exceptions

There are a few exceptions to this rule.
First, it does not trigger on coroutine lambdas because their return type cannot be deduced.
Also, it does not trigger on explicit template-dependent or constrained return types since they can be helpful for readability or maintainability.
Finally, it does not trigger if removing the explicit return type would result in ill-formed programs.

== Noncompliant Code Example

[source,cpp]
----
// Noncompliant: the return type is redundant
[](int i) -> int { return i + 42; }

// Noncompliant: the return type is redundant
[]() -> auto { return foo(); }

// Noncompliant: the return type is redundant
[](int x) -> std::vector<int> {
    x = std::max(0, std::min(100, x));
    return std::vector<int>{ x };
}
----


== Compliant Solution

[source,cpp]
----
// Compliant: no explicit return type.
[](int i) { return i + 42; }

// Compliant: no explicit return type.
[]() { return foo(); }

// Compliant: no explicit return type.
[](int x) {
    x = std::max(0, std::min(100, x));
    return std::vector<int>{ x };
}

// Compliant: type deduction wouldn't work.
[](int x) -> std::vector<int> { return { x }; }

// Compliant: type deduction wouldn't work.
[](Base* ptr) -> Derived* {
    if (auto* derived = dynamic_cast<Derived*>(ptr)) {
        actOnDerived(derived);
        return derived;
    }

    return nullptr;
}

// Compliant: enforce "process" returns a reference.
[](auto x) -> auto& { return process(x); }

// Compliant: for example, ensure the lambda returns a reference when "f" does.
[f](auto arg) -> decltype(f(arg)) { return f(arg); }

// Compliant: the return type restricts possible input types.
[](auto x) -> std::enable_if_t<std::is_integral_v<decltype(x)>> { process(x); }

template <typename T>
T getGlobalProperty(std::string_view name, T defaultValue) { /* ... */ }

// Compliant: the return type is constrained (C++20) and can help maintainability.
auto getProperty = [](std::string_view name) -> std::totally_ordered auto {
    return getGlobalProperty(name, 0);
}

// Compliant: removing this return type would result in a different signature.
[](int x) -> int { throw std::runtime_error("No more eggs"); }

 // Compliant: coroutine lambdas cannot rely on type deduction.
[]() -> Task { co_await std::suspend_always{}; }
----

