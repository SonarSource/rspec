<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>It is a best practice to make lambda return types implicit whenever possible.
First and foremost, doing so avoids implicit conversions, which could result in data or precision loss.
Second, omitting the return type often helps future-proof the code.</p>
</div>
<div class="paragraph">
<p>The issue is raised when explicit return types are used.</p>
</div>
<div class="sect2">
<h3 id="_noncompliant_code_example">Noncompliant code example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">// Noncompliant: the explicit return types are redundant.
[](int i) -&gt; int { return i + 42; }
[]() -&gt; auto { return foo(); }
[](int x) -&gt; std::vector&lt;int&gt; { return std::vector&lt;int&gt;{ x }; }</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_compliant_solution">Compliant solution</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">// Compliant: no explicit return type.
[](int i) { return i + 42; }
[]() { return foo(); }
[](int x) { return std::vector&lt;int&gt;{ x }; }</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_exceptions">Exceptions</h3>
<div class="paragraph">
<p>There are a few exceptions to this rule.</p>
</div>
<div class="paragraph">
<p>First, no issue is raised when the compiler is not deducing the same type by itself.
This can happen when a conversion is requested.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">// Compliant: the compiler would deduce a different return type.
[](int x) -&gt; double { return x; }
[](float x) -&gt; int { return x; } // Precision loss, see S5276.</code></pre>
</div>
</div>
<div class="paragraph">
<p>The compiler also deduces a different type when there are no <code>return</code> statements and the explicit return type is not <code>void</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">// Compliant: removing these explicit return types would result in a different signature.
[](int x) -&gt; int { throw std::runtime_error("No more eggs"); }
[](int x) -&gt; int { std::terminate(); }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Another similar situation is when references are involved: instead, the compiler deduces a value without an explicit return type.
This can have an impact on both correctness and performance.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">// Compliant: removing the explicit return type would return a copy.
[](std::vector&lt;int&gt;&amp; data) -&gt; auto&amp; {
    std::sort(data.begin(), data.end());
    return data;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Additionally, no issues are raised when the deduction of the return type is not available.
This is the case with C&#43;&#43;20 coroutines in their lambda form.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">// Compliant: coroutine lambdas cannot rely on type deduction.
[]() -&gt; Task { co_await std::suspend_always{}; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>In some other cases, removing the explicit return type would result in ill-formed programs.
This is the case when using initializer lists or aggregate initializations.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">// Compliant: type deduction wouldn't work.
[](int x) -&gt; std::vector&lt;int&gt; { return { x }; }
[]() -&gt; std::array&lt;int, 4&gt; { return { 1, 2, 3, 4 }; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Removing the explicit return type when a lambda has multiple <code>return</code> statements of different types would also result in ill-formed programs.
Here are two examples where the explicit return type introduces useful implicit conversions.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">// Compliant: omitting the return type would result in a compilation error.
[](Base* ptr) -&gt; Derived* {
    if (auto* derived = dynamic_cast&lt;Derived*&gt;(ptr)) {
        actOnDerived(derived);
        return derived;
    }

    // "nullptr_t" mismatches the previous return type "Derived*".
    return nullptr;
}

// Compliant: omitting the return type would result in a compilation error.
[](std::string_view request) -&gt; std::variant&lt;Error, Data&gt; {
    if (!isRequestValid(request)) {
        return Error{ "invalid request" };
    }

    auto reader = readRequest(request);
    // "Data" mismatches the previous return type "Error".
    return Data{ reader.data(), reader.size() };
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, this rule does not trigger on explicit template-dependent or constrained return types since they can have a use of their own, help readability or improve maintainability.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">// Compliant: enforce "process()" returns a reference.
[](auto x) -&gt; auto&amp; { return process(x); }

// Compliant: ensure the lambda returns a reference when "f()" does.
[f](auto arg) -&gt; decltype(f(arg)) { return f(arg); }

// Compliant: the return type restricts possible input types.
[](auto x) -&gt; std::enable_if_t&lt;std::is_integral_v&lt;decltype(x)&gt;&gt; { process(x); }

template &lt;typename T&gt;
T getGlobalProperty(std::string_view name, T defaultValue) { /* ... */ }

// Compliant: the return type is constrained (C++20) and can help maintainability.
auto getProperty = [](std::string_view name) -&gt; std::totally_ordered auto {
    return getGlobalProperty(name, 0);
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a data-rspec-id="S5276" class="rspec-auto-link">S5276</a>: Implicit casts should not lower precision</p>
</li>
</ul>
</div>
</div>
</div>