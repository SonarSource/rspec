<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In JavaScript, a promise is an object representing the eventual completion or failure of an asynchronous operation. It is a way to handle asynchronous operations more elegantly and avoid the "callback hell".</p>
</div>
<div class="paragraph">
<p>A promise can be in one of three states:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Pending: The initial state of a promise. It represents that the asynchronous operation is still ongoing and has not yet been fulfilled or rejected.</p>
</li>
<li>
<p>Fulfilled: The state of a promise when the asynchronous operation has been successfully completed. It represents that the promised value is available and can be consumed.</p>
</li>
<li>
<p>Rejected: The state of a promise when the asynchronous operation encounters an error or fails to complete. It represents that an error has occurred and the promised value is not available.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The basic syntax for creating a promise in JavaScript is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">const myPromise = new Promise((resolve, reject) =&gt; {
  // Asynchronous operation
  // If the operation is successful, call resolve(value)
  // If the operation fails, call reject(error)
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>However, when it comes to immediately resolving or rejecting states, creating a new promise with the <code>Promise</code> constructor and manually calling <code>resolve</code> or <code>reject</code> makes the code verbose and more difficult to read.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">const result = new Promise(resolve =&gt; resolve(42)); // Noncompliant: Redundant to explicitly create a promise to resolve 42
result.then(value =&gt; {
  console.log(value); // Output: 42
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>Instead, a promise can be created with <code>Promise.resolve</code>. It is typically used when you want to create a new promise that is already resolved with a certain value. It is commonly used to wrap synchronous values or functions into promises.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_fix_it">How to fix it</h2>
<div class="sectionbody">
<div class="paragraph">
<p>If you already have a synchronous value that you want to convert into a promise, using <code>Promise.resolve</code> is more concise and straightforward. It immediately creates a promise that is already resolved with the provided value.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">const result = Promise.resolve(42);
result.then(value =&gt; {
  console.log(value); // Output: 42
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>Similarly, if you have an error or an exceptional condition and want to create a promise that is immediately rejected with that error, using <code>Promise.reject</code> is more straightforward. It creates a promise in the rejected state with the provided error.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">const error = new Error('Something went wrong');
const promise = Promise.reject(error);</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you have a condition and want to create a promise that is either resolved or rejected based on that condition, using <code>Promise.resolve</code> or <code>Promise.reject</code> helps make the code more readable and concise.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">function fetchData() {
  if (cache) {
    return Promise.resolve(cache);
  } else if (shouldFetchData()) {
    return fetchDataFromServer()
        .then(data =&gt; {
            cache = data;
            return data;
        });
  } else {
    return Promise.reject(new Error('Data fetch is not required'));
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When you have a promise chain and want to introduce an intermediate step with an immediately resolved value, using <code>Promise.resolve</code> allows you to continue the chain without introducing unnecessary complexity.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">const data = cache ? cache : fetchData();

return Promise.resolve(data) // data may be a Promise or not, we need to wrap it
    .then(data =&gt; {
        return sanitizeData(data);
    })</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using <code>Promise.resolve</code> and <code>Promise.reject</code> is particularly useful when you want to simplify the creation of promises with immediately resolved or rejected states. They provide a cleaner and more direct approach compared to creating a new promise with the <code>Promise</code> constructor and manually calling <code>resolve</code> or <code>reject</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_documentation">Documentation</h3>
<div class="ulist">
<ul>
<li>
<p>MDN web docs - <a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous">Asynchronous JavaScript</a></p>
</li>
<li>
<p>MDN web docs - <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise</a></p>
</li>
<li>
<p>MDN web docs - <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then">Promise.prototype.then()</a></p>
</li>
<li>
<p>MDN web docs - <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve">Promise.resolve()</a></p>
</li>
<li>
<p>MDN web docs - <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/reject">Promise.reject()</a></p>
</li>
</ul>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_implementation_specification">Implementation Specification</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_message">Message</h3>
<div class="paragraph">
<p>Replace this trivial promise with "[Promise.resolve(XXX)|Promise.reject(XXX)]".</p>
</div>
</div>
<div class="sect2">
<h3 id="_highlighting">Highlighting</h3>
<div class="paragraph">
<p>entire "new Promise" expression</p>
</div>
</div>
</div>
</div>