<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The primary purpose of classes that implement indexed access operators is that of element access,
like this is the case for arrays, lists, maps, or sets.
When a class implements indexed access operators, they should be used as operators instead of calling them as functions,
because this is the intention of the designer of the API.</p>
</div>
<div class="sect2">
<h3 id="_what_is_the_potential_impact">What is the potential impact?</h3>
<div class="sect3">
<h4 id="_readability_and_understanding">Readability and Understanding</h4>
<div class="paragraph">
<p>This change makes it easier to understand what a function does,
because the semantics of indexed access operators is evident to the reader,
while for a function call, the reader would need to know what the called function does.</p>
</div>
</div>
<div class="sect3">
<h4 id="_java_interop">Java interop</h4>
<div class="paragraph">
<p>The issue is also raised when Java API is used as a Kotlin compiler treats all <code>get(.)</code> methods as possible index access operators. Use <code>CompletableFuture[timeout, unit]</code> instead of <code>CompletableFuture.get(timeout, unit)</code> when accessing Java&#8217;s <code>CompletableFuture</code>.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_fix_it">How to fix it</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Replace <code>instance.get(index)</code> with <code>instance[index]</code>.</p>
</div>
<div class="paragraph">
<p>Replace <code>instance.set(index, value)</code> with <code>instance[index] = value</code>.</p>
</div>
<div class="paragraph">
<p>This also works with multi-index access operators.</p>
</div>
<div class="sect2">
<h3 id="_code_examples">Code examples</h3>
<div class="sect3">
<h4 id="_noncompliant_code_example">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">interface Grid {
    operator fun get(row: Int, column: Int): Int
    operator fun set(row: Int, column: Int, value: Int)
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">fun indexedAccess(list: MutableList&lt;Int&gt;, map: MutableMap&lt;String, Int&gt;, grid: Grid) {
    list.get(1) // Noncompliant
    list.set(1, 42) // Noncompliant
    map.get("b") // Noncompliant
    map.set("b", 42) // Noncompliant
    grid.get(1, 2) // Noncompliant
    grid.set(1, 2, 42) // Noncompliant
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">fun indexedAccess(list: MutableList&lt;Int&gt;, map: MutableMap&lt;String, Int&gt;, grid: Grid) {
    list[1] // Compliant
    list[1] = 42 // Compliant
    map["b"] // Compliant
    map["b"] = 42 // Compliant
    grid[1, 2] // Compliant
    grid[1, 2] = 42 // Compliant
    list.getOrNull(2) // Compliant, because function is not an operator
    list.getOrElse(3) {42} // Compliant, because function is not an operator
    map.getValue("a") // Compliant, because function is not an operator
    map.getOrElse("c") {42} // Compliant, because function is not an operator
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_documentation">Documentation</h3>
<div class="ulist">
<ul>
<li>
<p><a href="https://kotlinlang.org/docs/operator-overloading.html#indexed-access-operator">Kotlin Docs, Indexed access operator</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>