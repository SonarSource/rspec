<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Coroutines, introduced in C&#43;&#43;20, are functions in which execution can be suspended and resumed. When a coroutine resumes, it takes over where it left thanks to the <em>coroutine state</em>.</p>
</div>
<div class="paragraph">
<p>A <em>coroutine state</em> is an object which contains all the information a coroutine needs to resume its execution correctly: local variables, copy of the parameters&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>This means that if the coroutine has a parameter that is a reference to an object, this object must exist as long as the coroutine is not destroyed. Otherwise, the reference stored in the <em>coroutine state</em> will become a dangling reference and will lead to undefined behavior when the coroutine resumes.</p>
</div>
<div class="paragraph">
<p>This rule detects when a coroutine parameter becomes a dangling reference.</p>
</div>
<div class="paragraph">
<p>To fix this, you can either pass the parameter by value or extend the lifetime of the parameter.</p>
</div>
<div class="sect2">
<h3 id="_noncompliant_code_example">Noncompliant code example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">generator&lt;char&gt; spell(const std::string&amp; m) {
    for (char letter : m) {
        co_yield letter;
    }
}

void print() {
    for (char letter : spell("hello world")) { // Noncompliant, parameter becomes a dangling reference
        std::cout &lt;&lt; letter &lt;&lt; '\n';
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_compliant_solution">Compliant solution</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">generator&lt;char&gt; spell(const std::string m) { // Either pass the argument by copy...
    for (char letter : m) {
        co_yield letter;
    }
}

void print() {
    for (char letter : spell("hello world")) {
        std::cout &lt;&lt; letter &lt;&lt; '\n';
    }
}

// Or

generator&lt;char&gt; spell(const std::string&amp; m) {
    for (char letter : m) {
        co_yield letter;
    }
}

void print() {
    std::string message = "hello world";
    for (char letter : spell(message)) { // ... Or increase the lifetime of the parameter
        std::cout &lt;&lt; letter &lt;&lt; '\n';
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>