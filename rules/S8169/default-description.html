<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This rule raises an issue when the same set of locks are acquired in different orders across different code paths in your program.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When multiple goroutines need to acquire the same set of locks, acquiring them in different orders can lead to deadlocks.</p>
</div>
<div class="paragraph">
<p>A deadlock occurs when two or more goroutines are blocked forever, each waiting for the other to release a lock. This happens when:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Goroutine A holds Lock 1 and waits for Lock 2</p>
</li>
<li>
<p>Goroutine B holds Lock 2 and waits for Lock 1</p>
</li>
<li>
<p>Both goroutines wait indefinitely</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This creates a circular dependency where no goroutine can proceed. The application becomes unresponsive and may need to be forcefully terminated.</p>
</div>
<div class="paragraph">
<p>Deadlocks are particularly dangerous because:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>They cause complete application freezes</p>
</li>
<li>
<p>They are often intermittent and hard to reproduce</p>
</li>
<li>
<p>They typically occur under load when timing conditions align</p>
</li>
<li>
<p>They can be difficult to debug without proper tooling</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Consistent lock ordering eliminates this problem by ensuring all goroutines acquire locks in the same sequence, preventing circular wait conditions.</p>
</div>
<div class="sect2">
<h3 id="_what_is_the_potential_impact">What is the potential impact?</h3>
<div class="paragraph">
<p>Deadlocks cause complete application hangs, making the system unresponsive. This leads to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Service outages and downtime</p>
</li>
<li>
<p>Poor user experience</p>
</li>
<li>
<p>Potential data loss if transactions are interrupted</p>
</li>
<li>
<p>Difficult debugging sessions, especially in production environments</p>
</li>
<li>
<p>Resource waste as blocked goroutines consume memory indefinitely</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_fix_it">How to fix it</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Always acquire locks in the same order across all code paths. A common approach is to order locks by their memory address or by a consistent identifier.</p>
</div>
<div class="sect2">
<h3 id="_code_examples">Code examples</h3>
<div class="sect3">
<h4 id="_noncompliant_code_example">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-go" data-lang="go">// Thread A
accountA.mutex.Lock()
accountB.mutex.Lock() // Noncompliant
// ... transfer logic
accountB.mutex.Unlock()
accountA.mutex.Unlock()

// Thread B
accountB.mutex.Lock()
accountA.mutex.Lock() // Noncompliant: different order
// ... transfer logic
accountA.mutex.Unlock()
accountB.mutex.Unlock()</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-go" data-lang="go">// Both threads use consistent ordering
func transfer(from, to *Account, amount int) {
    // Always lock accounts in ID order
    if from.ID &lt; to.ID {
        from.mutex.Lock()
        defer from.mutex.Unlock()
        to.mutex.Lock()
        defer to.mutex.Unlock()
    } else {
        to.mutex.Lock()
        defer to.mutex.Unlock()
        from.mutex.Lock()
        defer from.mutex.Unlock()
    }
    // ... safe transfer logic
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_documentation">Documentation</h3>
<div class="ulist">
<ul>
<li>
<p>Go Memory Model - Synchronization - <a href="https://golang.org/ref/mem#tmp_2">Official Go documentation on memory model and synchronization primitives</a></p>
</li>
<li>
<p>Effective Go - Concurrency - <a href="https://golang.org/doc/effective_go#concurrency">Best practices for concurrent programming in Go</a></p>
</li>
<li>
<p>Go Race Detector - <a href="https://golang.org/doc/articles/race_detector.html">Tool for detecting race conditions and concurrency issues</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_standards">Standards</h3>
<div class="ulist">
<ul>
<li>
<p>CWE-833: Deadlock - <a href="https://cwe.mitre.org/data/definitions/833.html">Common weakness enumeration for deadlock conditions</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>