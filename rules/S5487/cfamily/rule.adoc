Failing to properly initialize or destroy a `pthread` mutex can lead to undefined behavior.

== Why is this an issue?

_Mutexes_ are synchronization primitives that allow managing concurrency.

Their use requires following a well-defined life cycle.

* _Mutexes_ need to be initialized (``++pthread_mutex_init++``) before being used. Once it is initialized, a _mutex_ is in an _unlocked_ state.
* _Mutexes_ need to be destroyed (``++pthread_mutex_destroy++``) to free the associated internal resources. Only _unlocked_ _mutexes_ can be safely destroyed.

Before the initialization or after destruction, a mutex is in an uninitialized state.

During this life cycle,
the following patterns should be avoided as they result in undefined behavior:

* trying to initialize an already initialized _mutex_
* trying to destroy an initialized _mutex_ that is in a _locked_ state
* trying to destroy an uninitialized _mutex_
* trying to lock an uninitialized _mutex_
* trying to unlock an uninitialized _mutex_

In {cpp}11 and higher, `std::mutex` is less error-prone and is supported by more platforms.

In {cpp}03, it is recommended to wrap mutex creation/destruction in an RAII class, as well as mutex lock/unlock. Those RAII classes will perform the right operations, even in the presence of exceptions.

=== What is the potential impact?

Failing to properly initialize or destroy a POSIX Thread Mutex leads to *undefined behavior*.

For programs that exercise undefined behavior, the compiler is no longer bound by the language specification.
The application may crash or, even worse, the application may appear to execute correctly while losing data or producing incorrect results.
In a multi-threaded context, additionally the application may experience spurious deadlocks or data races.


== How to fix it

=== Code examples

==== Noncompliant code example

[source,c]
----
pthread_mutex_t mtx1;

void double_initialization(void)
{
  pthread_mutex_init(&mtx1, NULL);
  pthread_mutex_init(&mtx1, NULL); // Noncompliant: initializing an already initialized mutex
}

void destroy_locked(void)
{
  pthread_mutex_init(&mtx1, NULL);
  pthread_mutex_lock(&mtx1);
  pthread_mutex_destroy(&mtx1); // Noncompliant: destroying a locked mutex
}

void double_destruction(void)
{
  pthread_mutex_init(&mtx1, NULL);
  pthread_mutex_destroy(&mtx1);
  pthread_mutex_destroy(&mtx1); // Noncompliant: destroying an uninitialized mutex
}

void lock_destroyed(void)
{
  pthread_mutex_init(&mtx1, NULL);
  pthread_mutex_destroy(&mtx1);
  pthread_mutex_lock(&mtx1); // Noncompliant: locking an uninitialized mutex
}

void unlock_destroyed(void)
{
  pthread_mutex_init(&mtx1, NULL);
  pthread_mutex_destroy(&mtx1);
  pthread_mutex_unlock(&mtx1); // Noncompliant: unlocking an uninitialized mutex
}
----


==== Compliant solution

C solution:

[source,c]
----
pthread_mutex_t mtx1;

void destroy_initialized(void)
{
  pthread_mutex_init(&mtx1, NULL);
  pthread_mutex_destroy(&mtx1);
}

void use_and_destroy_initialized(void)
{
  pthread_mutex_init(&mtx1, NULL);
  pthread_mutex_lock(&mtx1);
  pthread_mutex_unlock(&mtx1);
  pthread_mutex_destroy(&mtx1);
}
----

For static mutex variables:

[source,c]
----
pthread_mutex_t mtx1 = PTHREAD_MUTEX_INITIALIZER;

void use_statically_initialized(void)
{
  pthread_mutex_lock(&mtx1); // Compliant: mutex is initialized statically
  pthread_mutex_unlock(&mtx1);
}
----

{cpp}11 and higher solution:

[source,cpp]
----
std::mutex mtx1;

void use_lock_guard(bool condition) {
  std::lock_guard<std::mutex> lock(mtx1);
  if (condition) {
    // Compliant: mutex will unlock automatically even in case of an exception
    throw std::invalid_argument("Expected false");
  }
  // Compliant: mutex will unlock automatically at the end of the scope
}
----

{cpp}03 solution:

[source,cpp]
----
pthread_mutex_t mtx1;

class Mutex {
public:
  Mutex(pthread_mutex_t* mtx) : pmtx(mtx) {
    pthread_mutex_init(pmtx, NULL);
  }
  ~Mutex() {
    pthread_mutex_destroy(pmtx);
  }
  pthread_mutex_t* pmtx;
private:
  // Forbid the copying of the mutex to avoid double-free
  Mutex(Mutex const& other);
  Mutex& operator=(Mutex const& other);
};

struct LockGuard {
  LockGuard(Mutex &m) : mtx(m) {
    pthread_mutex_lock(mtx.pmtx);
  }
  ~LockGuard() {
    pthread_mutex_unlock(mtx.pmtx);
  }
  Mutex &mtx;
}

void destroy_initialized()
{
  Mutex m(&mtx1);
  // Compliant: mtx1 will be properly initialized and destroyed
}

void use_and_destroy_initialized()
{
  Mutex m(&mtx1);
  {
    LockGuard lock(m);
    // Compliant: mutex will unlock automatically at the end of the scope
  }
  // Compliant: mtx1 will be destroyed properly
}
----

== Resources

=== Related rules

* S5486 enforces the proper locking and unlocking of `pthread` mutexes.
* S5489 enforces unlocking multiple held `pthread` mutexes in reverse order.

=== Documentation

* The Open Group - https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_mutex_init.html[``++pthread_mutex_init++``, ``++pthread_mutex_destroy++``]
* {cpp} Reference - https://en.cppreference.com/w/cpp/thread/lock_guard[`std::lock_guard`]


ifdef::env-github,rspecator-view[]
'''
== Comments And Links
(visible only on this page)

=== on 13 Oct 2023, Arseniy Zaostrovnykh wrote:

(Tomek's suggestion)As a further improvement possibility
"Going the extra mile" could explain how the modern ({cpp}17, {cpp}20) std::locks are implemented so that people could reimplement them in C++11 if necessary.

=== relates to: S5486

=== relates to: S5489

=== is related to: S5486

=== is related to: S5489

=== on 6 Nov 2019, 23:33:11 Lo√Øc Joly wrote:
\[~geoffray.adde] Can you please review my changes?

endif::env-github,rspecator-view[]
