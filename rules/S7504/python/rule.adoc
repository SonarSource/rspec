This rule raises an issue when `list()` calls are applied to types that are already directly iterable with for-loops.

== Why is this an issue?

Using `list()` on already iterable objects adds meaningless code clutter that doesn't provide any functional value when wrapping an already iterable object. Additionally, it creates unnecessary overhead by generating an intermediate list in memory, which inefficiently consumes memory resources and can degrade performance, especially with large data structures. Iterating directly over the original object is cleaner and more efficient.

== How to fix it

Remove the redundant `list()` call and iterate directly over the original iterable.

=== Code examples

==== Noncompliant code example

[source,python,diff-id=1,diff-type=noncompliant]
----
some_list = range(10)
for i in list(some_list): # Noncompliant: unnecessary list() call
    print(i)
----

==== Compliant solution

[source,python,diff-id=1,diff-type=compliant]
----
some_list = range(10)
for i in some_list: # Compliant
    print(i)
----

== Resources
=== Documentation

* Python Documentation - https://docs.python.org/3/glossary.html#term-iterable[Iterable Glossary Entry]
* Python Documentation - https://docs.python.domainunion.de/3/library/stdtypes.html#list[list()]

ifdef::env-github,rspecator-view[]
'''
== Implementation Specification
(visible only on this page)

=== Message

Remove this unnecessary `list()` call on an already iterable object.

=== Highlighting

The `list()` call applied to the iterable.
endif::env-github,rspecator-view[]
