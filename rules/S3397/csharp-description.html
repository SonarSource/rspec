<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>object.Equals()</code> overrides can be optimized by checking first for reference equality between <code>this</code> and the parameter. This check can be implemented by calling <code>object.ReferenceEquals()</code> or <code>base.Equals()</code>, where <code>base</code> is <code>object</code>. However, using <code>base.Equals()</code> is a maintenance hazard because while it works if you extend <code>Object</code> directly, if you introduce a new base class that overrides <code>Equals</code>, it suddenly stops working.</p>
</div>
<div class="paragraph">
<p>This rule raises an issue if <code>base.Equals()</code> is used but <code>base</code> is not <code>object</code>.</p>
</div>
<div class="sect2">
<h3 id="_noncompliant_code_example">Noncompliant code example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">class Base
{
  private int baseField;

  public override bool Equals(object other)
  {
    if (base.Equals(other)) // Okay; base is object
    {
      return true;
    }

    return this.baseField == ((Base)other).baseField;
  }
}

class Derived : Base
{
  private int derivedField;

  public override bool Equals(object other)
  {
    if (base.Equals(other))  // Noncompliant
    {
      return true;
    }

    return this.derivedField == ((Derived)other).derivedField;
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_compliant_solution">Compliant solution</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">class Base
{
  private int baseField;

  public override bool Equals(object other)
  {
    if (object.ReferenceEquals(this, other))  // base.Equals is okay here, but object.ReferenceEquals is better
    {
      return true;
    }

    return this.baseField == ((Base)other).baseField;
  }
}

class Derived : Base
{
  private int derivedField;

  public override bool Equals(object other)
  {
    if (object.ReferenceEquals(this, other))
    {
      return true;
    }

    return base.Equals(other) &amp;&amp; this.derivedField == ((Derived)other).derivedField;
  }
}</code></pre>
</div>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_implementation_specification">Implementation Specification</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_message">Message</h3>
<div class="paragraph">
<p>Change this guard condition to call "object.ReferenceEquals".</p>
</div>
</div>
<div class="sect2">
<h3 id="_highlighting">Highlighting</h3>
<div class="paragraph">
<p>invocation syntax</p>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_comments_and_links">Comments And Links</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_on_18_nov_2015_171747_tamas_vajk_wrote">on 18 Nov 2015, 17:17:47 Tamas Vajk wrote:</h3>
<div class="paragraph">
<p>\[~ann.campbell.2] Could you check this specification? Thanks</p>
</div>
</div>
<div class="sect2">
<h3 id="_on_18_nov_2015_200353_ann_campbell_wrote">on 18 Nov 2015, 20:03:53 Ann Campbell wrote:</h3>
<div class="paragraph">
<p>I&#8217;ve made some minor edits, but I&#8217;m confused by your "raises an issue" sentence. First, there&#8217;s nothing previously mentioned in the description about base vs object. Are you saying the rule only raises an issue for classes that aren&#8217;t direct extensions of <code>Object</code>? Second, don&#8217;t you want to raise an issue <em>any time</em> a reference check isn&#8217;t done? Even if you&#8217;re writing the method for a class that extends <code>Object</code> it seems that an immediate reference check is a good idea&#8230;&#8203;?</p>
</div>
</div>
<div class="sect2">
<h3 id="_on_19_nov_2015_083054_tamas_vajk_wrote">on 19 Nov 2015, 08:30:54 Tamas Vajk wrote:</h3>
<div class="paragraph">
<p>\[~ann.campbell.2] I changed the SQALE characteristics and the labels on the rule.</p>
</div>
<div class="paragraph">
<p>Yes, the aim was to say that the rule only raises an issue for classes that aren&#8217;t direct extensions of <code>Object</code>. More specifically it raises issues on <code>base.Equals</code> calls in <code>if (base.Equals(other)){return true;}</code> that are inside an <code>override bool Equals</code> in classes that aren&#8217;t direct extensions of <code>Object</code>.</p>
</div>
<div class="paragraph">
<p>I don&#8217;t think that we should add a rule to check for the existence of this reference equality check. There are multiple ways of doing it, so we might not be able to recognize all patterns, and also, MSDN suggests another way of implementing <code>Equals</code> override. However, this pattern is found in several places, and it&#8217;s error-prone, because it works if you extend <code>Object</code> directly, but if you introduce a new base class, then it suddenly fails to work.</p>
</div>
</div>
<div class="sect2">
<h3 id="_on_19_nov_2015_194440_ann_campbell_wrote">on 19 Nov 2015, 19:44:40 Ann Campbell wrote:</h3>
<div class="paragraph">
<p>\[~tamas.vajk] I&#8217;ve updated both the description and the code samples.</p>
</div>
</div>
<div class="sect2">
<h3 id="_on_20_nov_2015_084812_tamas_vajk_wrote">on 20 Nov 2015, 08:48:12 Tamas Vajk wrote:</h3>
<div class="paragraph">
<p>Thanks [~ann.campbell.2], it looks good.</p>
</div>
</div>
</div>
</div>