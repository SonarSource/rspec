This rule reports when a class or depends on another class in violation of the intended architectural design.

== Why is this an issue?

As by decision of the software architect, some classes and packages should not depend on each other.
These decisions reflect the intended structure of the software and responsibilities of code components (classes, packages, modules).
The reported dependency violates these design decisions.

=== What is the potential impact?

When new code violates design decisions, the project's structure gradually drift away from its intended architecture.
As these violations accumulate, the code becomes more complex and less consistent with the architectâ€™s original design, making future development and maintenance increasingly challenging.

== How to fix it

Remove or refactor the prohibited dependency.
This may involve replacing the dependency with an allowed one, moving code to appropriate classes or packages, or introducing new abstractions. The exact solution depends on your project's architecture and the code violating the intended design.

=== Code examples

==== Noncompliant code example

If the intended design prohibits classes in package `com.example.panels` to depend on classes in `com.example.repo`, then the following code example is noncompliant:

[source,java,diff-id=1,diff-type=noncompliant]
----
package com.example.panels;

import com.example.repos.CustomerRepo;

class ShowCustomersPanel extends Panel {

    CustomerRepo customerRepo = ...;

    List<Customer> customers = customerRepo.findAll();
}
----

==== Compliant solution

A solution could be to call into the service layer instead.

[source,java,diff-id=1,diff-type=compliant]
----
package com.example.panels;

import com.example.services.CustomerService;

class ShowCustomersPanel extends Panel {

    CustomerService customerService = ...;

    List<Customer> customers = customerService.getAllCustomers();
}
----
