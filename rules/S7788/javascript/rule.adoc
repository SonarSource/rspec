This rule reports when a source file depends on another source file in violation of the intended architectural design.

== Why is this an issue?

As by decision of the software architect, some files and directories should not depend on each other.
These decisions reflect the intended structure of the software and responsibilities of code components (files, directories).
The reported dependency violates these design decisions.

=== What is the potential impact?

When new code violates design decisions, the project's structure gradually drift away from its intended architecture.
As these violations accumulate, the code becomes more complex and less consistent with the architectâ€™s original design, making future development and maintenance increasingly challenging.

== How to fix it

Remove or refactor the prohibited dependency.
This may involve replacing the dependency with an allowed one, moving code to appropriate files or directories, or introducing new abstractions. The exact solution depends on your project's architecture and the code violating the intended design.

=== Code examples

==== Noncompliant code example

If the intended design prohibits files in the `panels/` directory from depending on files in the `repos/` directory, then the following code example is noncompliant:

[source,javascript,diff-id=1,diff-type=noncompliant]
----
// panels/ShowCustomersPanel.js

import { CustomerRepo } from '../repos/CustomerRepo.js';

export class ShowCustomersPanel {
  constructor() {
    this.customerRepo = ...;
    this.customers = this.customerRepo.findAll();
  }
}
----

==== Compliant solution

A solution could be to call into the service layer instead.

[source,javascript,diff-id=1,diff-type=compliant]
----
// panels/ShowCustomersPanel.js

import { CustomerService } from '../services/CustomerService.js';

export class ShowCustomersPanel {
  constructor() {
    this.customerService = ...;
    this.customers = this.customerService.getAllCustomers();
  }
}
----