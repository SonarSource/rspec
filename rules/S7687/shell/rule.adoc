This rule raises an issue when conditional expressions in shell scripts combine multiple test conditions with logical operators, making them hard to read and understand.

== Why is this an issue?

Complex conditional expressions with multiple logical operators can be difficult to read and understand at first glance. When you see a condition like `[ "$#" -ge "1" ] && [ "$1" = '-h' ] || [ "$1" = '--help' ]`, you need to mentally parse the logic to understand what it's checking for.

Extracting complex conditions into well-named functions serves multiple purposes:

* **Self-documenting code**: A function name like `help_wanted()` immediately tells you what the condition is checking for, without needing to read the implementation details.
* **Improved readability**: The main logic flow becomes clearer when you can read `if help_wanted "$@"` instead of parsing multiple test conditions.
* **Reusability**: The extracted function can be used in multiple places throughout the script.
* **Easier testing**: Individual functions can be tested separately, making your script more maintainable.
* **Reduced cognitive load**: Developers can focus on the high-level logic without getting bogged down in the details of each condition.

This practice follows the principle of writing code that expresses intent clearly, making your shell scripts more maintainable and easier for other developers (including your future self) to understand.

=== What is the potential impact?

Complex conditional expressions reduce code readability and maintainability. They increase the cognitive load required to understand the script's logic, making it harder to debug, modify, or extend the code. This can lead to bugs when conditions are misunderstood or incorrectly modified.

=== How to fix?


Extract the complex conditional expression into a function with a meaningful name that describes what the condition is checking for. Call this function in your if statement instead of using the complex expression directly.

==== Non-compliant code example

[source,shell,diff-id=1,diff-type=noncompliant]
----
if [ "$#" -ge "1" ] && [ "$1" = '-h' ] || [ "$1" = '--help' ]; then  # Noncompliant
  usage
fi
----

==== Compliant code example

[source,shell,diff-id=1,diff-type=compliant]
----
help_wanted() {
  [ "$#" -ge "1" ] && [ "$1" = '-h' ] || [ "$1" = '--help' ]
}

if help_wanted "$@"; then
  usage
fi
----

=== Documentation

 * Bash Functions - https://www.gnu.org/software/bash/manual/html_node/Shell-Functions.html[Official Bash manual section on shell functions]
 * Bash Best Practices - https://bertvv.github.io/cheat-sheets/Bash.html[Comprehensive guide to Bash scripting best practices]

=== Standards

 * Clean Code: Functions - https://clean-code-developer.com/grades/grade-1-red/#Functions_should_be_small[Clean Code principles for writing small, focused functions]

