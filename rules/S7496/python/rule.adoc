This rule raises an issue when calls to `tuple()`, `list()`, `set()`, or `dict()` 
are done with an argument that is already a collection literal or a comprehension that produces either the target type or an intermediate type. 

== Why is this an issue?

Python provides direct ways to create common data structures like tuples, lists, and dictionaries using literals (e.g., `()`, `(1,2)`, `[]`, `[1,2]`, `{}`, `{'a':1}`) 
and comprehensions (e.g., `[x for x in y]`, `{k:v for k,v in y}`).
Wrapping these direct forms in a type constructors, for example:

[source, python]
----
tuple((1,2))

list([1,2])
list([x for x in [1,2]])

set({})
set({for k in [1,2]})

dict({'a':1})
dict({k:v for k,v in [1,2]})
dict([(1,"a"), (2, "b")]) 
----
is unnecessary. 

Such constructs:
* add overhead by creating an intermediate collections
* add verbosity without providing any additional functionality
* add ambiguity and may mislead readers or imply a more complex operation than what is actually occurring

=== Exceptions

When using comprehensions this rule will only raise issues when the comprehension filter or modify the elements.

== How to fix it

To fix this remove the constructor call and use the literal or comprehension syntax of the target type.
As an exception, for a list or comprehension inside of a `tuple` constructor replace the comprehension by a generator.

[source,python,diff-id=1,diff-type=noncompliant]
----
t1 = tuple([1, 2]) # Noncompliant: the tuple creation can be done directly without the intermediate list
----

[source,python,diff-id=1,diff-type=compliant]
----
t1 = (1, 2) # Compliant
----

[source,python,diff-id=2,diff-type=noncompliant]
----
def foo(x):
    return x * 2

l1 = list([foo(x) for x in [1,2,3]]) # Noncompliant: list is redundant.
----

[source,python,diff-id=2,diff-type=compliant]
----
def foo(x):
    return x * 2
l1 = [foo(x) for x in [1,2,3]] # Compliant
----

[source,python,diff-id=3,diff-type=noncompliant]
----
def foo(x):
    return x * 2

s1 = set([foo(x) for x in [1,2,3]]) # Noncompliant: the set creation can be done with a set comprehension.
----

[source,python,diff-id=3,diff-type=compliant]
----
def foo(x):
    return x * 2
s1 = {foo(x) for x in [1,2,3]} # Compliant
----

== Resources

=== Documentation
* Python Documentation - https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions[List Comprehensions]
* Python Documentation - https://docs.python.org/3/tutorial/datastructures.html#dictionaries[Dictionaries]
* Python Documentation - https://docs.python.org/3/tutorial/datastructures.html#sets[Sets]
* Python Documentation - https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences[Tuples and Sequences]

ifdef::env-github,rspecator-view[]
== Implementation Specification

=== Message

When the inner type is the same as the constructor:
* Remove the redundant {tuple|list|set|dict} constructor call.

When the inner type is different than the constructor:
For literals:
* Replace this {tuple|list|set|dict} constructor call by a {tuple|list|set|dict} literal.
For comprehensions:
* Replace this {list|set|dict} constructor call by a {list|set|dict} literal.

Exception for tuple with a list/set-comprehension `tuple([foo(x) in [1,2]])` 
* Replace this list/set comprehension by a generator.

=== Highlighting
The list/set/dict/tuple constructor call.

Exception for tuple with a list/set-comprehension `tuple([foo(x) in [1,2]])`:
We should highlight the list/set-comprehension 
endif::env-github,rspecator-view[]
