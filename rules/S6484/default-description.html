<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>std::format</code> accepts a format string composed of ordinary text and replacement fields (surrounded with <code>{}</code>) that are replaced with a textual representation of the remaining <code>std::format</code> arguments.
This allows generating a complex string with a single invocation of <code>std::format</code>.</p>
</div>
<div class="paragraph">
<p>Since calls to <code>std::format</code> produce string objects, it is possible to concatenate them with other string objects or string literals.
However, compared to a single <code>std::format</code> invocation with an adjusted format string, this concatenation is inefficient and less readable.</p>
</div>
<div class="paragraph">
<p>This rule raises an issue when the concatenation performed on the result of <code>std::format</code> can be replaced with a single <code>std::format</code> invocation.</p>
</div>
<div class="sect2">
<h3 id="_noncompliant_code_example">Noncompliant code example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">void formatExamples(std::string str, char const* cstr, int i) {
  std::string s1 = "You have been greeted " + std::format("{}", i) + " times."; // Noncompliant
  std::string s2 = "Hello " + std::format("{:*^20}", str) + "! " + std::format("{:-&gt;15}", cstr) + '.'; // Noncompliant
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_compliant_solution">Compliant solution</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">void formatExamples(std::string str, char const* cstr, int i) {
  std::string s1 = std::format("You have been greeted {} times.", i); // Compliant
  std::string s2 = std::format("Hello {:*^20}! {:-&gt;15}.", str, cstr); // Compliant
}

std::string fullName(std::string name, std::string secondName, std::string surname, std::size_t number) {
  // Compliant, as the formatted output depends on runtime properties
  std::string result = std::format("({}) {}", number, name);
  if (!secondName.empty()) {
     result += " ";
     result += secondName.front();
  }
  result += surname;
  return result;
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_documentation">Documentation</h3>
<div class="ulist">
<ul>
<li>
<p>C&#43;&#43; reference - <a href="https://en.cppreference.com/w/cpp/utility/format/format"><code>std::format</code></a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_articles_blog_posts">Articles &amp; blog posts</h3>
<div class="ulist">
<ul>
<li>
<p>C&#43;&#43; Stories - <a href="https://www.cppstories.com/2022/custom-stdformat-cpp20/">Formatting Custom types with std::format from C&#43;&#43;20</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_related_rules">Related rules</h3>
<div class="ulist">
<ul>
<li>
<p><a data-rspec-id="S6185" class="rspec-auto-link">S6185</a> - "std::format" should be used instead of string concatenation and "std::to_string"</p>
</li>
<li>
<p><a data-rspec-id="S6494" class="rspec-auto-link">S6494</a> - C&#43;&#43; formatting functions should be used instead of C printf-like functions</p>
</li>
<li>
<p><a data-rspec-id="S6495" class="rspec-auto-link">S6495</a> - "std::format" should be used instead of standard output manipulators</p>
</li>
</ul>
</div>
</div>
</div>
</div>