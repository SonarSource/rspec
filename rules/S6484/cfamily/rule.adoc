`std::format` accepts a format string that in addition to replacement fields (surrounded with `{}`) which are replaced with a 
textual representation of the arguments, can include hardcoded text surrounding them. This allows to produce a complex output,
 with a single invocation of `std::format`.

As calls to `std::format` produce string objects, it is possible to concatenate them with other string objects or string literals.
However, compared to a single `std::format` invocation with an adjusted format string, a concatenation of strings is less readable and efficient.

This rule raises an issue when a concatenation of the output of `std::format` can be replaced with a single `std::format` invocation.

== Noncompliant Code Example

[source,cpp]
----
void formatExamples(std::string str, char const* cstr, int i) {
  std::string s1 = "The int argument has '" + std::format("{}", i) + "' value."; // Noncompliant
  std::string s2 = "Hello " + std::format("{:*^20}", str) + "! " + std::format("{:->15}", cstr) + '.'; // Noncompliant
  std::string s3 =  "Welcome";   // Noncompliant, this and 4 next line can be merged
  s3 +=  std::format("{:*^20}", str);
  s3 += "! ";
  s3 += std::format("{:->15}", cstr);
  s3 += '.';
}

std::string fullName(std::string name, std::string secondName, std::string surname, std::size_t number) {
  // Compliant, as the formatted output depends on runtime properties
  std::string result = std::format("({}) {}", number, name);
  if (!secondName.empty()) {
     result += " ";
     result += secondName.front();
  }
  result += surname;
  return result;
}
----

== Compliant Solution

[source,cpp]
----
void formatExamples(std::string str, char const* cstr, int i) {
  std::string s1 = std::format("The int argument has '{}' value.", i); // Compliant
  std::string s2 = std::format("Hello {:*^20}! {:->15}.", str, cstr); // Compliant
  std::string s3 = std::format("Welcome {:*^20}! {:->15}.", str, cstr); // Compliant
}

----

