== Why is this an issue?

There are various reasons why developers may call multiple times DateTime.Now, DateTimeOffset.Now, 
DateTime.UtcNow or DateTimeOffset.UtcNow inside the same block:

1) The purpose may be simply to store the results, perhaps even expecting the value of the calls to be or not to be the same. 
However, these properties change their value every time they are called (depending on the system clock resolution), and, calling them repeatedly can be an expensive operation. 

[source,csharp]
----
account1.updatedAt = DateTime.UtcNow; // First call, might be N ticks
account2.updatedAt = DateTime.UtcNow; // Second call, this one could be N + 1 ticks, but also N.
Console.WriteLine($"The accounts have been updated at {DateTime.UtcNow}"); // Third call, this can also be N, N + 1 or N + 2 ticks
----

2) The purpose may be to time how long something takes.
However, using repeated calls to DateTime.Now or DateTime.UtcNow to measure elapsed time is not recommended because it's dependent on the system clock, which may have low resolution on older systems (as low as 15 milliseconds). Moreover, DateTime.Now and DateTimeOffset.Now are subject to Daylight Savings Time (DST), which can cause issues if a DST transition occurs during the benchmark session.

[source,csharp]
----
var start = DateTime.Now; // First call
MethodToBeBenchmarked();

var elapsed = (int)(DateTime.Now - start).TotalMilliseconds; // Second call
----

== How to fix it

1) To avoid these issues and improve the performance of the application, it's recommended to declare a local variable to store a single DateTime or DateTimeOffset value and use it throughout the code block.

2) Instead of DateTime or DateTimeOffset, it's recommended to use *Stopwatch*, which automatically checks for the existence of high-precision timers, it’s lightweight and computationally faster, and it’s not affected by DST.

=== Code examples

==== Noncompliant code example

[source,csharp,diff-id=1,diff-type=noncompliant]
----
account1.updatedAt = DateTime.UtcNow; // Noncompliant
account2.updatedAt = DateTime.UtcNow; // Secondary
Console.WriteLine($"The accounts have been updated at {DateTime.UtcNow}"); // Secondary
----

==== Compliant solution

[source,csharp,diff-id=1,diff-type=compliant]
----
var now = DateTime.UtcNow; // Compliant
account1.updatedAt = now;
account2.updatedAt = now;
Console.WriteLine($"The accounts have been updated at {now}");
----

==== Noncompliant code example

[source,csharp,diff-id=1,diff-type=noncompliant]
----
if ((DateTime.UtcNow - latest).TotalMillisecond > 100) // Noncompliant
{
    // Do stuff
    latest = DateTime.UtcNow; // Secondary
}
----

==== Compliant solution

[source,csharp,diff-id=1,diff-type=compliant]
----
var utcNow = DateTime.UtcNow;
if ((utcNow - latest).TotalMillisecond > 100) // Compliant
{
    // Do stuff
    latest = utcNow; // Secondary
}
----

or

[source,csharp,diff-id=1,diff-type=compliant]
----
var stopWatch = Stopwatch.StartNew();

if (stopWatch.ElapsedMilliseconds > 100) // Compliant
{
    // Do stuff
    stopWatch.Restart();
}
----

==== Noncompliant code example

[source,csharp,diff-id=1,diff-type=noncompliant]
----
var start = DateTime.Now; // Noncompliant
MethodToBeBenchmarked();

Console.WriteLine("{0} ms",(int)(DateTime.Now - start).TotalMilliseconds); // Secondary
----

==== Compliant solution

[source,csharp,diff-id=1,diff-type=compliant]
----
var stopWatch = Stopwatch.StartNew(); // Compliant
MethodToBeBenchmarked();
stopWatch.Stop();

Console.WriteLine("{0} ms", stopWatch.ElapsedMilliseconds);
----

== Resources

=== Documentation

* https://learn.microsoft.com/en-us/dotnet/api/system.datetime?view=net-7.0#datetime-resolution
