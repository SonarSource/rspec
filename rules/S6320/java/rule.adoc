== Why is this an issue?

A cast operation allows an object to be converted from one type to another.
The compiler raises an error if it can determine that the target type is incompatible with the declared type of the object, otherwise it accepts the cast.
However, depending on the actual runtime type of the object, a cast operation may fail at runtime.
When a cast operation fails, a `ClassCastException` is thrown.
This type of exception is usually unexpected, so it is not caught and the application crashes.

== How can I fix it?

When an object is cast, the code makes assumptions about the type of the object.
A `ClassCastException` indicates that this assumption has been broken.
If the assumption is reasonable, then some prior logic should ensure that only objects of a compatible type can be cast.
You should try to identify the code responsible for these checks and fix it.

=== Noncompliant code example

[source,java]
----
List<String> list = new LinkedList<>();
if (someCondition) {
  list = new ArrayList<>();
}
((LinkedList<String>) list).addLast("abc"); // Noncompliant, throws a ClassCastException when someCondition is true
----

=== Compliant solution

[source,java]
----
List<String> list = new LinkedList<>();
if (someCondition) {
  list = new ArrayList<>();
}
if (list instanceof LinkedList) {
  ((LinkedList<String>) list).addLast("abc");
}
----

or

[source,java]
----
List<String> list = new LinkedList<>();
if (someCondition) {
  list = new ArrayList<>();
}
list.add("abc");
----

or

[source,java]
----
LinkedList<String> list = new LinkedList<>();
list.addLast("abc");
----

=== Going the extra mile

==== Consider polymorphism

Casting is considered an anti-pattern in object-oriented programming.
It is sometimes necessary, but you may want to evaluate whether your solution can use polymorphism instead.

