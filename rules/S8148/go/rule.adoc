This is an issue when code ignores errors, uses non-idiomatic control flow patterns, or attempts to implement exception-like error handling instead of Go's conventional explicit error returns.

== Why is this an issue?

Go was designed with explicit error handling as a core philosophy to make error conditions visible and force developers to consciously decide how to handle them. This approach leads to more reliable and maintainable code.

When errors are ignored using the blank identifier (`_`), potential failures become invisible, making debugging difficult and potentially causing silent failures in production. This goes against Go's principle of making errors explicit and handling them at the point where they occur.

Non-idiomatic patterns like unnecessary `else` clauses after error checks or using `panic`/`recover` for normal error flow make code less familiar to Go developers. These patterns increase cognitive load because they don't follow the established conventions that Go developers expect.

Abstraction layers that wrap Go's error handling in complex patterns (like Result types or generic error handlers) hide the explicit nature of Go's error handling, making code harder to understand and debug. Go's simple error interface and explicit returns are designed to be clear and direct.

The idiomatic Go approach of checking errors immediately after function calls and returning them explicitly creates a clear error flow that's easy to follow and debug. This pattern is so common in Go that it becomes second nature to experienced developers.

=== What is the potential impact?

Ignoring errors can lead to silent failures, data corruption, or unexpected application behavior in production. Non-idiomatic error handling patterns make code harder to maintain and review, especially for teams with varying Go experience levels.

When errors are not handled explicitly, debugging becomes significantly more difficult because error conditions are not visible in the code flow. This can result in longer development cycles and more production issues.

Using exception-like patterns in Go can mask the true source of errors and make it unclear where failures might occur, reducing the reliability benefits that Go's explicit error handling provides.

== How to fix it

Replace error ignoring with explicit error handling. Check the error return value and handle it appropriately, either by returning it to the caller or taking corrective action.

=== Code examples

==== Noncompliant code example

[source,go,diff-id=1,diff-type=noncompliant]
----
result, _ := someFunction() // Noncompliant
fmt.Println(result)
----

==== Compliant solution

[source,go,diff-id=1,diff-type=compliant]
----
result, err := someFunction()
if err != nil {
    return fmt.Errorf("operation failed: %w", err)
}
fmt.Println(result)
----

== Resources

=== Documentation

 * Effective Go - Error handling - https://go.dev/doc/effective_go#errors[Official Go documentation on error handling patterns and best practices]

 * Go Blog - Error handling and Go - https://go.dev/blog/error-handling-and-go[Detailed explanation of Go's error handling philosophy and patterns]

 * Go by Example - Errors - https://gobyexample.com/errors[Practical examples of error handling in Go]

=== Standards

 * CWE-754: Improper Check for Unusual or Exceptional Conditions - https://cwe.mitre.org/data/definitions/754.html[Relates to the importance of properly checking and handling error conditions]

=== Related rules

 * RSPEC-1181 - https://rules.sonarsource.com/go/RSPEC-1181/[Unused function parameters should be removed]
