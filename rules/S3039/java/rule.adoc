== Why is this an issue?

There are various `String` operations that take one or more character indexes as input and return a result that is the function of the original string and the indexes.
Indexing in this context is zero-based, meaning that the first character's index is `0`.
As a result, given a string `myString`, its last character is at index `myString.length - 1`.

If an index is smaller than 0 or larger than `myString.length - 1` is passed to one of the string operation methods a `StringIndexOutOfBoundsException` will be thrown.
For instance, it is not possible to use `String::substring` to reverse the order of characters in a string and it is not possible to use `String::charAt` to retrieve a value before the start or after the end of a string.

This rule raises an issue when a negative literal or `String::length` is passed as an argument to the `String::substring`, `String::charAt`, and related methods.
It also raises an issue when the start index passed to `String::substring` is larger than the end index.


== How to fix it

Use non-negative indexes that are strictly smaller than the length of the string in question.


=== Noncompliant code example

[source,java,diff-id=1,diff-type=compliant]
----
String speech = "Lorem ipsum dolor sit amet";

String substr1a = speech.substring(0, speech.length());      // Noncompliant, speech.length() is out of bounds
String substr1b = speech.substring(-1, speech.length() - 1); // Noncompliant, -1 is out of bounds
String substr2 = speech.substring(speech.length - 1, 0);     // Noncompliant, the start index must be smaller than the end index. String::substring to reverse the order of characters.
char ch = speech.charAt(speech.length());                    // Noncompliant, speech.length() is out of bounds
----


=== Compliant solution

[source,java,diff-id=1,diff-type=noncompliant]
----
String speech = "Lorem ipsum dolor sit amet";

String substr1a = speech;                                       // Compliant, no string operation used
String substr1b = speech.substring(0, speech.length() - 1);     // Compliant, both 0 and speech.length - 1 are in bounds
String substr2 = new StringBuilder(speech).reverse().toString() // Compliant, the string can be reversed using StringBuilder::reverse
char ch = speech.charAt(speech.length() - 1);                   // Compliant, speech.length() - 1 is in bounds.
----



ifdef::env-github,rspecator-view[]

'''
== Implementation Specification
(visible only on this page)

=== Message

Refactor this "[substring|charAt]" call; it will result in an "StringIndexOutOfBounds" exception at runtime.


'''
== Comments And Links
(visible only on this page)

=== relates to: S2121

endif::env-github,rspecator-view[]
