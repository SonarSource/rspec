include::../why-general.adoc[]


The examples below show typical situations in which shadowing can occur.

 * Parameter shadowing
+
[source,cpp]
----
void f(int x, bool b) {
  int y = 4;
  if (b) {
    int x = 7; // Noncompliant: the parameter "x" is shadowed.
    int y = 9; // Noncompliant: the local variable "y" is shadowed.
    // ...
  }
}
----

* Member variable shadowing
+
[source,cpp]
----
class Foo {
private:
  int myField;

public:
  void doSomething() {
    int myField = 0; // Noncompliant: Foo::myField is shadowed.
    // ...
  }
};
----

* Global variable shadowing
+
[source,cpp]
----
namespace ns {
  int state;

  void bar() {
    int state = 0; // Noncompliant: the namespace variable is shadowed.
  }
}
----

=== Exceptions

It is common practice to have constructor arguments shadowing the fields they initialize in the _member initializer list_.
This pattern avoids the need to select new names for the constructor arguments and will not be reported by this rule.
The exception also applies when using `std::move` or `std::forward` to initialize the field, or when passing the parameter to a base class constructor.

[source,cpp]
----
class Point {
public:
  Point(int x, int y)
    : x(x) // Compliant by exception: the parameter "x" is used
           // in the member initializer list.
  {
    y = y; // Noncompliant: the parameter is assigned to itself
           // and the member "y" is not initialized.
  }

private:
  int x;
  int y;
};
----

[source,cpp]
----
template<typename T>
class Wrapper {
public:
  template<typename U>
  Wrapper(std::string name, U&& value)
    : name(std::move(name)),      // Compliant by exception: uses std::move
      value(std::forward<U>(value))  // Compliant by exception: uses std::forward
  {
  }

private:
  std::string name;
  T value;
};
----

[source,cpp]
----
class Base {
public:
  Base(int value) : value(value) {}
protected:
  int value;
};

class Derived : public Base {
public:
  Derived(int value) : Base(value) {}  // Compliant by exception: parameter passed to base constructor
};
----

Similarly, it is common practice for setter methods to have parameters that shadow the fields they set.
This pattern will not be reported when the method body contains only a single assignment statement from the parameter to the member accessed through the `this` pointer.
The exception also applies when using `std::move` or `std::forward` in the assignment.

[source,cpp]
----
template<typename T>
class Wrapper {
public:
  void setName(std::string name) {
    this->name = std::move(name);  // Compliant by exception: setter with std::move
  }

  template<typename U>
  void setValue(U&& value) {
    this->value = std::forward<U>(value);  // Compliant by exception: setter with std::forward
  }

private:
  std::string name;
  T value;
};
----

=== Caveats

==== Shadowing in `if`, `else if`, and `else`

Variables can be introduced in the condition of an `if` statement.
Their scope includes the optional `else` statement, which may be surprising.
Consequently, such variables can be shadowed in an `else if` statement.
This can be even more confusing and result in unintended behavior, as illustrated in this example:

[source,cpp]
----
using ExpectedData = std::expected<std::string, std::error_code>;

if (ExpectedData e = readData()) {
  printMessage(e.value());
} else if (ExpectedData e = readFallbackSource()) { // Noncompliant
  printMessage(e.value());
} else {
  logError(
    "Initial source failed with: ",
    e.error() // Contrary to the intention, the second "e" is used.
  );
}
----

== Resources

=== External coding guidelines

* MISRA C:2004, 5.2 - Identifiers in an inner scope shall not use the same name as an identifier in an outer scope, and therefore hide that identifier
* MISRA {cpp}:2008, 2-10-2 - Identifiers declared in an inner scope shall not hide an identifier declared in an outer scope
* MISRA C:2012, 5.3 - An identifier declared in an inner scope shall not hide an identifier declared in an outer scope

=== Standards

* CERT - https://wiki.sei.cmu.edu/confluence/display/c/DCL01-C.+Do+not+reuse+variable+names+in+subscopes[DCL01-C. Do not reuse variable names in subscopes]

=== Related rules

* S2387 - Child class fields should not shadow parent class fields

include::../rspecator.adoc[]
