include::../why-general.adoc[]


The examples below show typical situations in which shadowing can occur.

[source,cpp]
----
void f(int x, bool b) {
  int y = 4;
  if (b) {
    int x = 7; // Noncompliant: the parameter "x" is shadowed.
    int y = 9; // Noncompliant: the local variable "y" is shadowed.
    // ...
  }
}

class Foo {
private:
  int myField;

public:
  void doSomething() {
    int myField = 0; // Noncompliant: Foo::myField is shadowed.
    // ...
  }
};

namespace ns {
  int state;

  void bar() {
    int state = 0; // Noncompliant: the namespace variable is shadowed.
  }
}
----

=== Exceptions

It is common practice to have constructor arguments shadowing the fields they initialize in the _member initializer list_.
This pattern avoids the need to select new names for the constructor arguments and will not be reported by this rule.

[source,cpp]
----
class Point {
public:
  Point(int x, int y)
    : x(x) // Compliant by exception: the parameter "x" is used
           // in the member initializer list.
  {
    y = y; // Noncompliant: the parameter is assigned to itself
           // and the member "y" is not initialized.
  }

private:
  int x;
  int y;
};
----

=== Pitfalls

==== Shadowing in `if`, `else if`, and `else`

Variables can be introduced in the condition of an `if` statement.
Their scope includes the optional `else` statement, which may be surprising.
Consequently, such variables can be shadowed in an `else if` statement.
This can be even more confusing and result in unintended behavior, as illustrated in this example:

[source,cpp]
----
if (std::expected<std::string, std::error_code> e = readData())
{
  std::cout << *e << std::endl;
}
else if (std::expected<std::string, std::error_code> e = readFallbackSource())
{
  std::cout << "Initial source failed with: "
    << e.error().message() << std::endl; // Ups, I mean previous e here
  std::cout << *e << std::endl;
}
else
{
  std::cout << "Initial source failed with: "
    << e.error().message() << std::endl; // Ups, I mean first e here
}
----

==== Shadowing of inaccessible declarations

This rule also raises issues on some variables, although they do not shadow another variable according to a strict interpretation of the {cpp} language. There are mainly two reasons for this.

 . The primary one is that the readability and maintainability of the code are impaired.
   Readers need an advanced understanding of the {cpp} language to understand the subtle differences.

 . The second motivation is that a small change can lead to actual shadowing.
   This can lead to subtle bugs when updating the code.

Here is an example with nested classes:

[source,cpp]
----
class A {
public:
  int x;
  class B;
};

class A::B {
  void f(int x) { // Noncompliant
    // The parameter "x" shadows the field "A::x".
  }

  void illFormed() {
    x = 42; // Error: use of non-static data member 'x' of 'A' from nested type 'B'
  }
};
----

In the above example, `A::x` cannot be used from `A::B` member functions because it is not a static field.
Changing the declaration of `A::x` from `int x;` to `static int x;` would make the code compile.
This can lead to surprising effects when moving code around, for example.

You should always avoid shadowing to avoid any confusion and increase the maintainability of your code.

== Resources

=== External coding guidelines

* MISRA C:2004, 5.2 - Identifiers in an inner scope shall not use the same name as an identifier in an outer scope, and therefore hide that identifier
* MISRA {cpp}:2008, 2-10-2 - Identifiers declared in an inner scope shall not hide an identifier declared in an outer scope
* MISRA C:2012, 5.3 - An identifier declared in an inner scope shall not hide an identifier declared in an outer scope

=== Standards

* CERT - https://wiki.sei.cmu.edu/confluence/display/c/DCL01-C.+Do+not+reuse+variable+names+in+subscopes[DCL01-C. Do not reuse variable names in subscopes]

=== Related rules

* S2387 - Child class fields should not shadow parent class fields

include::../rspecator.adoc[]
