<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p><em>Mutexes</em> are synchronization primitives that allow the managing of concurrency. It is a common situation to have to use multiple <em>mutexes</em> to protect multiple resources with different access patterns.</p>
</div>
<div class="paragraph">
<p>In such a situation, it is crucial to define an order on the set of all <em>mutexes</em>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>This order should be strictly followed when <em>locking</em> <em>mutexes</em>.</p>
</li>
<li>
<p>The reverse order should be strictly followed when <em>unlocking</em> <em>mutexes</em>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Failure to do so can lead to <em>deadlocks</em>. i.e., situations where two or more threads are blocked forever, each holding one mutex and waiting for one held by the other(s).</p>
</div>
<div class="paragraph">
<p>In C&#43;&#43;, an easy way to make sure the unlocks are called in reverse order from the lock is to wrap the lock/unlock operations in an RAII class (since destructors of local variables are called in reverse order of their creation).</p>
</div>
<div class="paragraph">
<p>If instead of <code>pthread_mutex_t</code> you are using <code>std::mutex</code>, there are other mechanisms that allow you to avoid deadlocks in that case, see <a data-rspec-id="S5524" class="rspec-auto-link">S5524</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_fix_it">How to fix it</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Reorder locking and unlocking operations to always lock in the same order and unlock in the reverse order.</p>
</div>
<div class="sect2">
<h3 id="_code_examples">Code examples</h3>
<div class="sect3">
<h4 id="_noncompliant_code_example">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">pthread_mutex_t mtx1;
pthread_mutex_t mtx2;

void thread_safe_operation(void) {
  pthread_mutex_lock(&amp;mtx1);
  pthread_mutex_lock(&amp;mtx2);
  use_resources();
  pthread_mutex_unlock(&amp;mtx1); // Noncompliant
  pthread_mutex_unlock(&amp;mtx2);
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution">Compliant solution</h4>
<div class="paragraph">
<p>C solution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">pthread_mutex_t mtx1;
pthread_mutex_t mtx2;

void thread_safe_operation(void) {
  pthread_mutex_lock(&amp;mtx1);
  pthread_mutex_lock(&amp;mtx2);
  use_resources();
  pthread_mutex_unlock(&amp;mtx2);
  pthread_mutex_unlock(&amp;mtx1);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>C&#43;&#43;03 solution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">pthread_mutex_t mtx1;
pthread_mutex_t mtx2;

struct MutexLocker {
  MutexLocker(pthread_mutex_t* mtx) : mtx(mtx) {
    pthread_mutex_lock(mtx);
  }
  ~MutexLocker() {
    pthread_mutex_unlock(mtx);
  }
  pthread_mutex_t* mtx;
};

struct ResourcesLocker {
  ResourcesLocker() : m1(&amp;mtx1), m2(&amp;mtx2) {}
  MutexLocker m1;
  MutexLocker m2;
};

void thread_safe_operation(void) {
  ResourcesLocker locker;
  use_resources();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>C&#43;&#43;11 and C&#43;&#43;14 solution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">std::mutex m1;
std::mutex m2;

void thread_safe_operation(void) {
  std::lock(m1, m2);
  std::lock_guard&lt;std::mutex&gt; lck1(m1, std::adopt_lock);
  std::lock_guard&lt;std::mutex&gt; lck2(m2, std::adopt_lock);
  use_resources();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>C&#43;&#43;17 and after:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">std::mutex m1;
std::mutex m2;

void thread_safe_operation(void) {
  std::scoped_lock lck1(m1, m2);
  use_resources();
}</code></pre>
</div>
</div>
<hr>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_comments_and_links">Comments And Links</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_relates_to_s5486">relates to: <a data-rspec-id="S5486" class="rspec-auto-link">S5486</a></h3>

</div>
<div class="sect2">
<h3 id="_relates_to_s5487">relates to: <a data-rspec-id="S5487" class="rspec-auto-link">S5487</a></h3>

</div>
<div class="sect2">
<h3 id="_relates_to_s5524">relates to: <a data-rspec-id="S5524" class="rspec-auto-link">S5524</a></h3>

</div>
<div class="sect2">
<h3 id="_is_related_to_s5486">is related to: <a data-rspec-id="S5486" class="rspec-auto-link">S5486</a></h3>

</div>
<div class="sect2">
<h3 id="_is_related_to_s5487">is related to: <a data-rspec-id="S5487" class="rspec-auto-link">S5487</a></h3>

</div>
<div class="sect2">
<h3 id="_on_6_nov_2019_235457_loïc_joly_wrote">on 6 Nov 2019, 23:54:57 Loïc Joly wrote:</h3>
<div class="paragraph">
<p>\[~geoffray.adde]</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Can you please review my changes?</p>
</li>
<li>
<p>It&#8217;s not clear to me if this rule is supposed to detect that in on place mtx1 is locked before mtx2, and in another place the order is reversed?</p>
</li>
</ul>
</div>
</div>
</div>
</div>