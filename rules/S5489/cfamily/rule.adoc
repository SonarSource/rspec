== Why is this an issue?

_Mutexes_ are synchronization primitives that allow managing concurrency. It is a common situation to have to use multiple _mutexes_ to protect multiple resources with different access patterns.


In such a situation, it is crucial to define an order on the set of all _mutexes_.

This order should be strictly followed when _locking_ _mutexes_.

The reverse order should be strictly followed when _unlocking_ _mutexes_.


Failure in doing so can lead to _deadlocks_.


In {cpp}, an easy way to make sure the unlocks are called in reverse order from the lock is to wrap the lock/unlock operations in an RAII class (since destructors of local variables are called in reverse order of their creation).


If instead of ``++pthread_mutex_t++`` you are using ``++std::mutex++``, there are other mechanisms that allow you to avoid deadlocks in that case, see S5524.

== How to fix it

Reorder locking and unlocking operations to always lock in the same order and unlock in the reverse order.

=== Code examples

==== Noncompliant code example

[source,c,diff-id=1,diff-type=noncompliant]
----
pthread_mutex_t mtx1, mtx2;

void thread_safe_operation(void)
{
  pthread_mutex_lock(&mtx1);
  pthread_mutex_lock(&mtx2);
  use_resources();
  pthread_mutex_unlock(&mtx1); // Noncompliant
  pthread_mutex_unlock(&mtx2);
}
----


==== Compliant solution

[source,c,diff-id=1,diff-type=compliant]
----
pthread_mutex_t mtx1, mtx2;

void thread_safe_operation(void)
{
  pthread_mutex_lock(&mtx1);
  pthread_mutex_lock(&mtx2);
  use_resources();
  pthread_mutex_unlock(&mtx2);
  pthread_mutex_unlock(&mtx1);
}
----



ifdef::env-github,rspecator-view[]
'''
== Comments And Links
(visible only on this page)

include::comments-and-links.adoc[]
endif::env-github,rspecator-view[]
