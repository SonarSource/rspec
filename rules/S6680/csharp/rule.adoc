This vulnerability exposes the system to various operational overloads that can
lead to either a technical denial of service and/or business disruptions.

== Why is this an issue?

In the context of an application vulnerable to Loop Boundary Injection: +
After discovering the injection point, attackers insert data into the
vulnerable field to either make the affected component inaccessible, attempt a
malfunction, or read from an artifact that exceeds the developer's intended
boundaries.

In low-level languages, this vulnerability can lead to memory over-reads or
over-writes and have worse consequences.

=== What is the potential impact?

==== Self Denial of service

If the component jeopardized by this vulnerability is not a bottleneck that
acts as a single point of failure (SPOF) within the application, the denial of
service might only affect the attacker who initiated it.

Such benign denial of service can also occur in architectures that rely heavily
on containers and container orchestrators. Replication systems would detect the
failure of a container and automatically replace it.

include::../../../shared_content/appsec/high_impact_dos.adoc[]

== How to fix it

=== Code examples

==== Noncompliant code example

[source,csharp,diff-id=1,diff-type=noncompliant]
----
public class ExampleController : Controller
{
    public IActionResult Compute(int data)
    {
        for (int i = 0; i < data; i++) // Noncompliant
        {
            Console.WriteLine("Hello");
        }

        Enumerable
            .Range(1, data) // Noncompliant
            .ToList()
            .ForEach(i => Console.WriteLine("World"));

        return Ok();
    }
}
----

==== Compliant solution

[source,csharp,diff-id=1,diff-type=compliant]
----
public class ExampleController : Controller
{
    public static int MAX_BOUNDARY = 1337;
    public static int MIN_BOUNDARY = 1;

    public IActionResult Compute(int data)
    {
        
        if (MIN_BOUNDARY > data)
        {
            data = MIN_BOUNDARY;
        }
        else if (data > MAX_BOUNDARY)
        {
            data = MAX_BOUNDARY;
        }

        for (int i = 0; i < data; i++)
        {
            Console.WriteLine("Hello");
        }

        Enumerable
            .Range(1, data) // Noncompliant
            .ToList()
            .ForEach(i => Console.WriteLine("World"));

        return Ok();
    }
}
----

=== How does this work?

==== Set limits

just like with other injection vulnerabilities, when fixing this vulnerability
you need to make sure that the value to be set as a boundary respects the
system and functional boundaries. If an instruction should not be executed more
than 3 times, the limit must be explicitly set. +
No assumptions should be made about what users will choose, because attackers
definitely do not adhere to these assumptions.

== Resources

=== Standards

* https://owasp.org/Top10/A03_2021-Injection/[OWASP Top 10 2021 Category A3] - Injection
* https://www.owasp.org/index.php/Top_10-2017_A1-Injection[OWASP Top 10 2017 Category A1] - Injection
* https://cwe.mitre.org/data/definitions/606[MITRE, CWE-606] - Unchecked Input for Loop Condition

