Each template requires certain operations to be provided by types it is instantiated with.
Before {cpp}20, the only way to describe those requirements was through documentation.
Concepts, introduced in {cpp}20, provide a way to express requirements in a way that can be checked by the compiler.

This improves the readability and maintainability of the code, most importantly:

* It makes it clear from the declaration what types are accepted, and what operations they should support.
  This benefit is even higher when the concepts used to contrain the code are well-known, such as concepts defined in the standard library
* Errors from incorrect instantiations points at the call side (code produced by the programmer),
  and not at some obscure details in the middle of the implementation of an algorithm.

Should all template code be exhaustively constrained? Probably not, especially if that would lead to defining single-use concepts.
But in the case of templates designed to work with standard-style iterators, there is no good reason not to use standard library concepts describing them.
Even adding a simple set of basic constraints, such as the required category of iterators, without covering all the operations required by the algorithm,
is already providing value.

The rule raises issue for generic iterator-pair algorithms that are not constrained.

== Noncompliant Code Example

[source,cpp]
----
template<typename Iter, typename Func>
void adjacent_for_each(Iter first, Iter last, Func func) {
  auto prev = first;
  for (++first; first != last; ++first) {
    func(*prev, *first);
    prev = first;
  }
}
----

== Compliant Solution

[source,cpp]
----
template<std::forward_iterator Iter, typename Func>
// compliant, even though this template requires additional operations, for instance:
//   requires std::invocable<Func&, std::iter_reference_t<Iter>, std::iter_reference_t<Iter>>
void adjacent_for_each(Iter first, Iter last, Func func) {
  auto prev = first;
  for (++first; first != last; ++first) {
    func(*prev, *first);
    prev = first;
  }
}
----

