<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Each template requires certain operations to be provided by the types it is instantiated with.
Before C&#43;&#43;20, the only way to describe those requirements was through documentation.
Concepts, introduced in C&#43;&#43;20, provide a way to express requirements in a way that can be checked by the compiler.</p>
</div>
<div class="paragraph">
<p>This improves the readability and maintainability of the code, most notably:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It makes it clear from the declaration what types are accepted and what operations they should support.
This benefit is even higher when the concepts used to constrain the code are well-known, such as concepts defined in the standard library.</p>
</li>
<li>
<p>Errors from incorrect instantiations point at the call site (code produced by the programmer),
and not at some obscure details in the middle of the implementation of an algorithm.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Should all template code be exhaustively constrained? Probably not, especially if that would lead to defining single-use concepts.
But in the case of templates designed to work with standard-style iterators, there is no good reason not to use the standard library concepts describing them.
Even adding a simple set of basic constraints, such as the required category of iterators, without covering all the operations needed for the algorithm,
is already providing value.</p>
</div>
<div class="paragraph">
<p>This rule raises an issue for generic iterator-pair algorithms that are not constrained.</p>
</div>
<div class="sect2">
<h3 id="_noncompliant_code_example">Noncompliant code example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">template&lt;typename Iter, typename Func&gt;
void adjacent_for_each(Iter first, Iter last, Func func) {
  auto prev = first;
  for (++first; first != last; ++first) {
    func(*prev, *first);
    prev = first;
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_compliant_solution">Compliant solution</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">template&lt;std::forward_iterator Iter, typename Func&gt;
// Compliant, even though this template needs additional operations, for instance:
//   requires std::invocable&lt;Func&amp;, std::iter_reference_t&lt;Iter&gt;, std::iter_reference_t&lt;Iter&gt;&gt;
void adjacent_for_each(Iter first, Iter last, Func func) {
  auto prev = first;
  for (++first; first != last; ++first) {
    func(*prev, *first);
    prev = first;
  }
}</code></pre>
</div>
</div>
</div>
</div>
</div>