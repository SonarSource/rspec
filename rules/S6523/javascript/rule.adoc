== Why is this an issue?

The optional chaining operator `?.` allows to access a deeply nested property, returning `undefined` if the property or any intermediate object is `undefined`.

This usually means that we expect the expression to evaluate as `undefined` in some cases. Therefore, using the optional chaining operator in a context where returning `undefined` is forbidden can lead to errors.

Since optional chaining represents multiple execution branches, having an error thrown in such a context can be hard to debug.

[source,javascript]
----
new (foo?.bar)();           //Noncompliant: TypeError: (intermediate value) is not a constructor
const { foo } = bar?.baz;   //Noncompliant: TypeError: Cannot destructure property 'foo' of '(intermediate value)' as it is undefined.
const foo = [...bar?.baz]   //Noncompliant: TypeError: (intermediate value) is not iterable
----

In order to prevent runtime errors, you should provide fallbacks for when the optional chaining operator short circuits to `undefined`.

[source,javascript]
----
new (foo?.bar ?? baz)()
const { foo } = bar?.baz || {}
const foo = bar?.baz ? [...bar.baz] : []
----

//=== How does this work?

//=== Pitfalls

//=== Going the extra mile


//== Resources
//=== Documentation
//=== Articles & blog posts
//=== Conference presentations
//=== Standards
