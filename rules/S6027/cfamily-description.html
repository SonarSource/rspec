<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>const</code> member functions are the member functions that do not modify the object they are called on.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>While returning a non-const reference or a pointer from such a function does not in itself modify the object, it creates an opportunity for modification in the future. In particular, it enables the code that uses this member function to modify a ``++const++`` object.</pre>
</div>
</div>
<div class="paragraph">
<p>When defining a const member function, consider returning by reference/pointer to <code>const</code> or returning by value.</p>
</div>
<div class="paragraph">
<p>In some cases you need to be able to read the field from <code>const</code> objects and mutate it in non-<code>const</code>, as is often the case with container objects, like <code>std::vector</code>. Consider using <code>const</code>-overloading in this case.</p>
</div>
<div class="paragraph">
<p>This rule detects when a <code>const</code> member function returns a reference field and has as a return type a pointer/reference to a non-const object.</p>
</div>
<div class="sect2">
<h3 id="_noncompliant_code_example">Noncompliant code example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">class Person {
  std::string name;
  std::string &amp;alias = name;
public:
  std::string &amp;getAlias() const { // Noncompliant
    return alias;
  }
};

void fun(const Person &amp;p) {
  p.getAlias() = "Looser"; // The function modifies a constant object
}

class Shadow {
  Person &amp;p;
public:
  Shadow(Person &amp;p) : p(p) {}
  Person &amp;getPerson() const {// Noncompliant
    return p;
  }
};</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_compliant_solution">Compliant solution</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">class Person {
  std::string name;
  std::string &amp;alias = name;
public:
  std::string const &amp;getAlias() const { // Compliant
    return alias;
  }
};

void fun(const Person &amp;p) {
  //p.getAlias() = "Looser"; // This prank is prevented
}

class Shadow {
  Person &amp;p;
public:
  Shadow(Person &amp;p) : p(p) {}
  Person const &amp;getPerson() const {// Compliant
    return p;
  }
  Person &amp;getPerson() {// Compliant, const-overload
    return p;
  }
};</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a href="https://isocpp.org/wiki/faq/const-correctness#return-const-ref-from-const-memfn" class="bare">https://isocpp.org/wiki/faq/const-correctness#return-const-ref-from-const-memfn</a></p>
</li>
</ul>
</div>
</div>
</div>