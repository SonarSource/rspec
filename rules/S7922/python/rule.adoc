This rule raises an issue when blocking operations like synchronous HTTP requests, `time.sleep()`, or CPU-intensive computations are performed directly within async functions.

== Why is this an issue?

Async functions are designed to enable concurrent execution by yielding control back to the event loop when waiting for I/O operations or other asynchronous tasks. When you perform blocking operations within an async function, you defeat this purpose entirely.

Blocking operations prevent the event loop from executing other coroutines, essentially making your async code run sequentially instead of concurrently. This leads to poor performance and resource utilization, especially in web applications where you might expect to handle multiple requests simultaneously.

For example, using `requests.get()` in an async function blocks the entire event loop until the HTTP request completes. Even if you have multiple async tasks running, they will execute one after another instead of concurrently.

The same applies to CPU-intensive operations. While these don't involve I/O, they still consume the event loop thread and prevent other coroutines from running until the computation finishes.

=== What is the potential impact?

Blocking operations in async functions can severely degrade application performance by:

* Reducing throughput in web applications as requests are processed sequentially instead of concurrently
* Causing timeouts and poor user experience due to increased response times
* Wasting server resources as the event loop remains idle while waiting for blocking operations
* Making the application unresponsive during CPU-intensive tasks

== How to fix it

Replace synchronous HTTP requests with async HTTP libraries like `httpx` or `aiohttp`. These libraries provide async methods that properly yield control back to the event loop.

=== Code examples

==== Noncompliant code example

[source,python,diff-id=1,diff-type=noncompliant]
----
import requests
import asyncio

async def fetch_data():
    # Blocking HTTP request
    response = requests.get("https://api.example.com/data")  # Noncompliant
    return response.json()

async def main():
    tasks = [fetch_data() for _ in range(5)]
    results = await asyncio.gather(*tasks)
    return results
----

==== Compliant solution

[source,python,diff-id=1,diff-type=compliant]
----
import httpx
import asyncio

async def fetch_data():
    # Non-blocking HTTP request
    async with httpx.AsyncClient() as client:
        response = await client.get("https://api.example.com/data")
        return response.json()

async def main():
    tasks = [fetch_data() for _ in range(5)]
    results = await asyncio.gather(*tasks)
    return results
----

== How to fix it in FastAPI

Use FastAPI's `run_in_threadpool()` utility for blocking operations, or define background tasks as synchronous functions to let the framework handle thread management automatically.

=== Code examples

==== Noncompliant code example

[source,python,diff-id=2,diff-type=noncompliant]
----
from fastapi import BackgroundTasks, FastAPI
import time

app = FastAPI()

async def background_task(data):
    # This blocks the event loop
    time.sleep(5)  # Noncompliant
    await db.save(data)

@app.post("/process")
async def process_data(data: dict, background_tasks: BackgroundTasks):
    background_tasks.add_task(background_task, data)
    return {"status": "processing"}
----

==== Compliant solution

[source,python,diff-id=2,diff-type=compliant]
----
from fastapi import BackgroundTasks, FastAPI
from fastapi.concurrency import run_in_threadpool
import time

app = FastAPI()

async def background_task(data):
    # Move blocking operation to thread pool
    await run_in_threadpool(lambda: time.sleep(5))
    await db.save(data)

# Alternative: define as synchronous function
def sync_background_task(data):
    time.sleep(5)  # Framework handles this in separate thread
    db.save_sync(data)

@app.post("/process")
async def process_data(data: dict, background_tasks: BackgroundTasks):
    background_tasks.add_task(background_task, data)
    return {"status": "processing"}
----

== Resources

=== Documentation

 * Python asyncio documentation - https://docs.python.org/3/library/asyncio.html[Official Python documentation for asyncio module]

 * HTTPX async client documentation - https://www.python-httpx.org/async/[Documentation for HTTPX async HTTP client]

 * FastAPI concurrency utilities - https://fastapi.tiangolo.com/async/#concurrency-and-async-await[FastAPI documentation on handling concurrency and blocking operations]
