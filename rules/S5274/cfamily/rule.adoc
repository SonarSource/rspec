This rule reports an issue when the use of ``++std::move++`` prevents the copy elision optimizations from happening.

== Why is this an issue?

Usually, when copying an object, the source object is unchanged, 
meaning all resources owned by the source objects must be duplicated during the copy operation. 
If the source object is no longer used, this duplication is inefficient. 
Since {cpp}11, a move semantic mechanism has been added to detect such cases and replace the expensive copy with a much cheaper move operation that will transfer resources.

The cornerstone of move semantics is detecting during a "copy" whether the source object will be reused or not. 
This can be done explicit by the user, by invoking a `std::move` (or different cast to rvalue) on the object.
In such case the user promises to the compiler that they won't care for the object's current value any longer.
In addition to that the compile will use move, or skip coping of the object in some situations.

Firstly, the copy will be elided (not performed) or automatically turned into move operation,
when the temporary object of type `T` is used to initialize a parameter or variable of type `T` or `const T`, 
or returned from the function that declares `T` or `const T` as return type:
[source,cpp]
----
class A {/* ... */};
A create();

void asParam(A a);

A returnedFromFunc() {
  // For all below examples, the object will not be copied,
  // and either the no copy or move will be performed (as optimization, that is guaranteed since C++17)
  // or move operation will be used.
  A a = create();
  asParam(createA()); 
  return A();
}
----

Calling `std::move` on such object is not only necessary, but will also prevent compiler from performing (inhibit) copy elision,
and the rule raises issues in that case.
[source,cpp]
----
class A {/* ... */};
A create();

void asParam(A a);

A returnedFromFunc() {
  // Move operations needs to be peformed, and cannot be elided.
  A a = std::move(create()); // Noncompliant
  asParam(createA());        // Noncompliant
  return A();                // Noncompliant
}
----

Secondly, under certain conditions the local variable or function parameter is implicit moved,
if it is directly returned (`return x`) from the function.
In particular, when a variable of type `T` is returned direclty from the function that declares `T` or `const T`
as a return type:
[source,cpp]
----
class A {/* ... */};

A returnedLocalVar() {
  A a = create();
  // Variable a is automatically moved here
  return a;
}
----

This conditions overlaps with the conditions under which copy elision optimization,
refered as Named Return Value Optimization (NRVO) can be performed by compiler. 
When this optimization is applied the local variable is returned without any copy or move operation being performed.
In this case adding `std::move` to the return statment will inhibit this optimization,
and the rule raises an issues.
[source,cpp]
----
class A {/* ... */};

A returnedLocalVar() {
  A a = create();
  // Variable a is moved, but NRVO cannot be perforedm
  return std::move(a); // Noncompliant
}
----


=== Why is the issue raised if my class does not have move constructr?

A move itself is not performing any object operation, and casting an source to `rvalue`.
This leads to the constructor and assigment operator that accepts rvalue refence as parameter,
also reffered as move constructor and move assigment, to be selectedu by overload resolution.
However, in situation case if class does not provide such constructor, 
a copy constructor/assigment will be invoked respectively.

Such invocation of copy constructor may still be eliminated by copy-elision optimizations,
and thus redundant `std::move` calls that inhibits such optimization, has higher impact in such situations.

[source,cpp]
----
class OnlyCopyable {
  OnlyCopyable(OnlyCopyable const&);
  /* No move constructor */
};
OnlyCopyable create();

void test() {
  // Forces a move operation, that invokes copy constructor
  OnlyCopyable c1 = std::move(create()); // Noncompliant
  // Copy elision elimites invoke of copy constructor
  OnlyCopyable c2 = create();
}
----

=== Why if issue raised when passing argument to reference parameter?

The copy elision optimization applies only if a new value is produced from the source,
as consequence there are not applied if the parameter is reference to same type:

[source,cpp]
----
void process(A&& sink);

void passArgument() {
  // No move operation is triggered, as parameter is reference
  process(std::move(createA())); // Noncompliant
}
----

Such calls to `std::move` are not inhibiting optimization at this point,
they will if the `process` function is modified accept `A` by value.

/* TODO: say it reduces maintability */


=== Why the is is not raised for all redundant moves?

/* TODO: redo */

The requirments from performing an implcit move where relaxed in {cpp}20 and {cpp}23 standards,
with some of them being applied retroactively.
As consequence depending on the language and compiler, 
a call to `std::move` may or not redundant in return statment,
and thus required for the code to be portable accross compilers.

// Do code examples section

=== Noncompliant code example

[source,cpp,diff-id=1,diff-type=noncompliant]
----
class A {};
A getA();

A f() {
  A a = std::move(getA()); // Noncompliant, prevents copy elision
  std::vector<A> v;
  v.push_back(std::move(getA())); // Noncompliant
  return std::move(a); // Noncompliant
}
----


=== Compliant solution

[source,cpp,diff-id=1,diff-type=compliant]
----
class A {};
A getA();

A f() {
  A a = getA(); // Compliant
  std::vector<A> v;
  v.push_back(getA()); // Compliant
  return a; // Compliant
}
----


== Resources

=== Documentation

* {cpp} reference - https://en.cppreference.com/w/cpp/language/copy_elision[Copy elision]
* {cpp} reference - https://en.cppreference.com/w/cpp/utility/move[std::move]

=== External coding guidelines

* {cpp} Core Guidelines - https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f48-dont-return-stdmovelocal[F.48: Don't `return std::move(local)`]


ifdef::env-github,rspecator-view[]

'''
== Implementation Specification
(visible only on this page)

=== Message

Moving a temporary object prevents copy elision.

Moving a temporary object is useless.


'''
== Comments And Links
(visible only on this page)

=== is duplicated by: S5412

=== is related to: S5415

=== on 3 Sep 2019, 18:01:27 Lo√Øc Joly wrote:
\[~geoffray.adde]: Could you please review the changed I made to this RSPEC?

endif::env-github,rspecator-view[]
