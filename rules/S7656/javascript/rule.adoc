This rule raises an issue when a class decorated with `@Pipe` does not implement the `PipeTransform` interface.

== Why is this an issue?

Angular Pipes are components that transform data for display in templates. The `PipeTransform` interface defines the contract that all pipes must follow, specifically requiring a `transform` method with the correct signature.

When a pipe class doesn't implement `PipeTransform`, several problems can occur:

* **Missing type safety**: Without the interface, TypeScript cannot verify that the pipe implements the required `transform` method correctly
* **Runtime errors**: If the `transform` method is missing or has the wrong signature, the application will fail at runtime
* **Poor developer experience**: IDEs cannot provide proper autocomplete, refactoring support, or error detection
* **Maintenance issues**: Future changes to the pipe might accidentally break the required contract without compile-time warnings

The `PipeTransform` interface ensures that your pipe has a `transform` method that takes a value as the first parameter and optional additional parameters, returning the transformed result. This contract is essential for Angular's change detection and template rendering to work correctly.

=== What is the potential impact?

Without implementing `PipeTransform`, pipes may fail at runtime if the `transform` method is missing or incorrectly implemented. This can cause template rendering errors and application crashes. Additionally, developers lose type safety and IDE support, making the code harder to maintain and more prone to bugs.

=== How to fix in Angular?

Import and implement the PipeTransform interface in your pipe class. This ensures type safety and proper contract compliance.

==== Non-compliant code example

[source,typescript,diff-id=1,diff-type=noncompliant]
----
@Pipe({ name: 'example' })
class ExamplePipe { // Noncompliant
  transform(value: string): string {
    return value.toUpperCase();
  }
}
----

==== Compliant code example

[source,typescript,diff-id=1,diff-type=compliant]
----
import { Pipe, PipeTransform } from '@angular/core';

@Pipe({ name: 'example' })
class ExamplePipe implements PipeTransform {
  transform(value: string): string {
    return value.toUpperCase();
  }
}
----

When implementing multiple interfaces, include PipeTransform alongside other interfaces.

==== Non-compliant code example

[source,typescript,diff-id=2,diff-type=noncompliant]
----
@Pipe({ name: 'example' })
class ExamplePipe implements OnDestroy { // Noncompliant
  transform(value: string): string {
    return value.toUpperCase();
  }
  
  ngOnDestroy(): void {
    // cleanup logic
  }
}
----

==== Compliant code example

[source,typescript,diff-id=2,diff-type=compliant]
----
import { Pipe, PipeTransform, OnDestroy } from '@angular/core';

@Pipe({ name: 'example' })
class ExamplePipe implements PipeTransform, OnDestroy {
  transform(value: string): string {
    return value.toUpperCase();
  }
  
  ngOnDestroy(): void {
    // cleanup logic
  }
}
----

=== Documentation

 * Angular Pipes Guide - https://angular.io/guide/pipes[Official Angular documentation on creating and using pipes]
 * PipeTransform Interface - https://angular.io/api/core/PipeTransform[API documentation for the PipeTransform interface]

