:object_replacement_protocol: https://docs.python.org/3/library/copy.html#object.__replace__

== Why is this an issue?

Calling ``++copy.replace(...)++`` with an argument of an unsupported type will raise an ``++TypeError++``.
Types supported by ``++copy.replace(...)++`` must implement the {object_replacement_protocol}[replace protocol]. 

The following built-in types are supported by ``++copy.replace(...)++``

* ``++collections.namedtuple()++``
* ``++dataclasses.dataclass++``
* ``++datetime.datetime++``, ``++datetime.date++``, ``++datetime.time++``
* ``++inspect.Signature++``, ``++inspect.Parameter++``
* ``++types.SimpleNamespace++``
* https://docs.python.org/3/reference/datamodel.html#code-objects[code objects]

== How to fix it

If the argument passed in is a class defined in this project then implementing the {object_replacement_protocol}[replace protocol] by defining the ``++__replace__++`` method. 

[source,python,diff-id=1,diff-type=compliant]
----
class SomeClass:
    def __init__(self, name)
        self.name = name

    def __replace__(self, /, **changes)
        return SomeClass(changes.get("name", self.name))
----

=== Code examples

==== Noncompliant code example

[source,python,diff-id=1,diff-type=noncompliant]
----
import copy

class AClass: 
    ...

a = AClass()
b = copy.replace(a) # Noncompliant
----

==== Compliant solution

[source,python,diff-id=1,diff-type=compliant]
----
import copy

class AClass: 
    ...
    def __replace__(self, /, **changes):
        ...

a = AClass()
b = copy.replace(a) # Compliant


@dataclass
class ADataClass:
    ...

c = ADataClass()
d = copy.replace(c) # Compliant
----

=== Pitfalls

Ensure that if the ``++__replace__++`` is implemented that the implementation creates a new object instead of updating the old one. 


== Resources
=== Documentation
* https://docs.python.org/3/library/copy.html#copy.replace
* https://docs.python.org/3/library/copy.html#object.\\__replace__
* https://docs.python.org/3/whatsnew/3.13.html#copy
