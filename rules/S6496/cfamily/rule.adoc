Objects of small sizes, i.e., smaller than `2 * sizeof(void*)` bytes, whose types are trivially copyable and trivially copy-constructible should be passed by value.

Passing such objects by value is always more efficient than passing them by reference and comes with the following benefits:

* No copy-constructor is called (trivial)
* Object may be passed using registers (Scalar Replacement Of Aggregates) or may not be passed at all (e.g. for objects of empty types)
* Aliasing in the call target is eliminated
* No extra indirection required to access from the callee


== Noncompliant Code Example

[source,cpp]
----
struct Point {
  int x;
  int y;
};

void f1(const int& i); // Noncompliant, pass by value is more efficient
void f2(const double& d); // Noncompliant, pass by value is more efficient
void f3(const Point& p); // Noncompliant, pass by value is more efficient
----

== Compliant Solution

[source,cpp]
----
struct Point {
  int x;
  int y;
};

void f1(int i);
void f2(double d);
void f3(Point p);
void f4(const std::string &s); // Compliant, pass by reference to const; pass by value is potentially expensive
----


== See

* https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#f16-for-in-parameters-pass-cheaply-copied-types-by-value-and-others-by-reference-to-const[{cpp} Core Guidelines F.16] - For "in" parameters, pass cheaply-copied types by value and other by reference to const
