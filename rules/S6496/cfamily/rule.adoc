Small objects whose types are trivially copy-constructible and destructible should be passed by value.
Copy constructor and destructor are trivial, if they are not user-provided, the respective type does not declare virtual function members, and these properties hold recursively for all its members and its base class.
In other words, they do not run any code but are only copying bytes.


Passing small objects by value comes with the following benefits:

. Aliasing in the call target is eliminated
+
Aliasing describes the situation in which the same piece of memory can be accessed via different pointer or reference variables.
Internally, the compiler treats references like pointers.
Aliasing, however, oftentimes hinders the compiler to produce efficient code.
Consider the following code example:
+
[source,cpp]
----
int add(int& x, const int& y) {
  if (y == 42) {
    x = 9001; // can potentially change y's value, if x and y alias
  }
  return x + y; // need to load y again
}
----
Parameters passed by value cannot alias with any pointer/reference parameter of global variable.

. No extra indirection required to access from the callee
+
Passing a reference typed variable is like passing a pointer typed variable, since the compiler treats references like pointers.
To access memory using a reference (or pointer) hence requires two loads: One load for the pointer and a second load for the memory that resides at the address carried by the pointer typed variable.
Objects passed by value may not even be stored in memory at all and can be passed via registers, instead or they are not passed at all, if the object is empty. 
Small objects of non-scalar types (as identified by this rule) enable many compilers to apply Scalar Replacement of Aggregates (SRA).

. No additional function-call overhead
+
Analogously to reference parameters, creating a copy of a trivially copy-constructible object does not require a call to a constructor (i.e., functional call).


This rule raises an issue when a small object (up to `2 * sizeof(void*)` bytes) with trivial copy operations and a trivial destructor is passed by reference.


== Noncompliant Code Example

[source,cpp]
----
struct Point {
  int x;
  int y;
};

void f1(const int& i); // Noncompliant, pass by value is more efficient
void f2(const double& d); // Noncompliant, pass by value is more efficient
void f3(const Point& p); // Noncompliant, pass by value is more efficient
void add(int& x, const int& y) {
  // Noncompliant, even worse: compiler has to assume that the memory referred
  // to by y can change, too, since x and y could alias and effectively refer
  // to the same memory location.
  if (y == 42) {
    x = 9001;
  }
  return x + y;
}
----

== Compliant Solution

[source,cpp]
----
struct Point {
  int x;
  int y;
};

void f1(int i);
void f2(double d);
void f3(Point p);
// Compliant, pass by reference to const; pass by value is potentially expensive
void f4(const std::string &s);
void add(int& x, int y) {
  if (y == 42) {
    x = 9001;
  }
  return x + y;
}
----


== See

* https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#f16-for-in-parameters-pass-cheaply-copied-types-by-value-and-others-by-reference-to-const[{cpp} Core Guidelines F.16] - For "in" parameters, pass cheaply-copied types by value and other by reference to const
