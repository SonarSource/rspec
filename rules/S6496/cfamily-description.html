<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Small objects whose types are trivially copy-constructible and destructible should be passed by value.
Copy constructor and destructor are trivial, if they are not user-provided, the respective type does not declare virtual function members, and these properties hold recursively for all its members and its base class.
In other words, they do not run any code but are only copying bytes.</p>
</div>
<div class="paragraph">
<p>Passing small objects by value comes with the following benefits:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Aliasing in the call target is eliminated</p>
<div class="paragraph">
<p>Aliasing describes the situation in which the same piece of memory can be accessed via a different pointer or reference variables.
Internally, the compiler treats references like pointers.
Aliasing, however, oftentimes hinders the compiler from producing efficient code.
Consider the following code example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">int add(int&amp; x, const int&amp; y) {
  if (y == 42) {
    x = 9001; // can potentially change y's value, if x and y alias
  }
  return x + y; // need to load y again
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Not only needs the compiler to generate a second load for <code>y</code>, but it is also not immediately clear that variable <code>y</code> may be changed by the store to <code>x</code>, which breaks local reasoning and thus may confuse programmers.
Parameters passed by value cannot alias with any pointer/reference parameter or global variable and, therefore, eliminate the aforementioned problems.</p>
</div>
</li>
<li>
<p>No extra indirection required to access from the callee</p>
<div class="paragraph">
<p>Passing a reference-typed variable is like passing a pointer-typed variable, since the compiler treats references like pointers.
To access memory using a reference (or pointer) hence incurs an additional indirection.
Objects passed by value may not even be stored in memory at all and can be passed via registers (Scalar Replacement of Aggregates) instead, or they are not passed at all, if the object is empty.</p>
</div>
</li>
<li>
<p>No additional function-call overhead</p>
<div class="paragraph">
<p>Creating a copy of a trivially copy-constructible object does not require a call to a constructor (i.e., functional call) and hence has similar costs to copying one or only very few pointer/reference parameters.</p>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>This rule raises an issue when a small object (up to <code>2 * sizeof(void*)</code> bytes) with trivial copy operations and a trivial destructor is passed by reference.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_noncompliant_code_example">Noncompliant Code Example</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">struct Point {
  int x;
  int y;
};

void f1(const int&amp; i); // Noncompliant, pass by value is more efficient
void f2(const double&amp; d); // Noncompliant, pass by value is more efficient
void f3(const Point&amp; p); // Noncompliant, pass by value is more efficient
void add(int&amp; x, const int&amp; y) {
  // Noncompliant, even worse: compiler has to assume that the memory referred
  // to by y can change, too, since x and y could alias and effectively refer
  // to the same memory location.
  if (y == 42) {
    x = 9001;
  }
  return x + y;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_compliant_solution">Compliant Solution</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">struct Point {
  int x;
  int y;
};

void f1(int i);
void f2(double d);
void f3(Point p);
// Compliant, pass by reference to const; pass by value is potentially expensive
void f4(const std::string &amp;s);
void add(int&amp; x, int y) {
  if (y == 42) {
    x = 9001;
  }
  return x + y;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_see">See</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#f16-for-in-parameters-pass-cheaply-copied-types-by-value-and-others-by-reference-to-const">C&#43;&#43; Core Guidelines F.16</a> - For "in" parameters, pass cheaply-copied types by value and other by reference to const</p>
</li>
</ul>
</div>
</div>
</div>