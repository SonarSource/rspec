This rule raises an issue when a public method processes input parameters without validating them first.

== Why is this an issue?

Public methods act as the entry points to your code and should be defensive against invalid inputs. When these methods don't validate their parameters, several problems can occur:

**Runtime panics**: Accessing nil pointers, reading from empty slices beyond their bounds, or performing operations on invalid data can cause your program to crash unexpectedly.

**Incorrect behavior**: Processing invalid inputs often leads to wrong results that can be hard to trace back to the source. For example, a function that expects a positive number might produce meaningless output when given a negative value.

**Resource waste**: Methods that don't validate inputs might perform expensive operations on data that should have been rejected immediately.

**Poor error handling**: Without early validation, errors occur deep in the call stack, making them harder to debug and handle gracefully.

**Security vulnerabilities**: In some cases, unvalidated inputs can lead to security issues like buffer overflows or injection attacks.

Input validation serves as a contract between your method and its callers. It makes your code more predictable, easier to debug, and more robust against unexpected usage patterns.

=== What is the potential impact?

Missing input validation can lead to runtime panics, incorrect program behavior, security vulnerabilities, and difficult-to-debug issues. The impact is particularly severe in production environments where crashes can affect system availability and user experience.

== How to fix it

Add validation checks at the beginning of your public methods. Check for nil pointers, empty slices, invalid ranges, and other preconditions before processing the data.

=== Code examples

==== Noncompliant code example

[source,go,diff-id=1,diff-type=noncompliant]
----
func (s *Service) ProcessData(data []byte, config *Config) error {
    // Missing validation - could panic or misbehave // Noncompliant
    result := make([]byte, len(data)*2)
    copy(result, data)
    
    if config.Enabled {
        // Process with config
    }
    return nil
}
----

==== Compliant solution

[source,go,diff-id=1,diff-type=compliant]
----
func (s *Service) ProcessData(data []byte, config *Config) error {
    if len(data) == 0 {
        return errors.New("data cannot be empty")
    }
    if config == nil {
        return errors.New("config cannot be nil")
    }
    
    result := make([]byte, len(data)*2)
    copy(result, data)
    
    if config.Enabled {
        // Process with config
    }
    return nil
}
----

== Resources

=== Documentation

 * Go Blog: GIF decoder exercise - https://go.dev/blog/gif-decoder[Example of input validation in the blockReader.Read method]

 * Effective Go: Error handling - https://go.dev/doc/effective_go#errors[Best practices for error handling and validation in Go]

 * Go by Example: Errors - https://gobyexample.com/errors[Examples of proper error handling and validation patterns]

=== Standards

 * CWE-20: Improper Input Validation - https://cwe.mitre.org/data/definitions/20.html[Covers the security implications of insufficient input validation]

 * CWE-476: NULL Pointer Dereference - https://cwe.mitre.org/data/definitions/476.html[Describes vulnerabilities from accessing null/nil pointers]

=== Related rules

 * RSPEC-3900 - https://rules.sonarsource.com/csharp/RSPEC-3900/[Similar rule for C# about validating method arguments]
