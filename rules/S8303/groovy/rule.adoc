This rule raises an issue when a star import (import package.*) is used to import all classes from a package.

== Why is this an issue?

Star imports bring all public classes from a package into the local namespace, which creates several problems:

**Namespace pollution**: Star imports clutter the local namespace with many classes that may not be used, making it harder to understand which classes are actually needed.

**Unclear dependencies**: When reading code, it becomes difficult to determine which specific classes come from which packages, reducing code readability and making maintenance more challenging.

**Potential naming conflicts**: If multiple packages contain classes with the same name, star imports can lead to ambiguous references and compilation errors.

**IDE performance**: Some development environments may experience slower performance when processing large numbers of imported classes.

Explicit imports make code dependencies clear and help maintain a clean, understandable codebase.

== How to fix it

Replace star imports with explicit imports for each class you actually use.

=== Code examples

==== Noncompliant code example

[source,groovy,diff-id=1,diff-type=noncompliant]
----
import groovy.xml.* // Noncompliant
import java.util.* // Noncompliant
import java.io.* // Noncompliant

def markupBuilder = new MarkupBuilder()
def list = new ArrayList()
----

==== Compliant solution

[source,groovy,diff-id=1,diff-type=compliant]
----
import groovy.xml.MarkupBuilder // Compliant
import java.util.ArrayList // Compliant

def markupBuilder = new MarkupBuilder()
def list = new ArrayList()
----

== Resources

=== Documentation

 * Groovy documentation  - https://groovy-lang.org/structure.html#_star_import[Program structure]
