<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A unit test assertion should have only one reason to succeed because it helps to ensure that the test is focused and specific. When a test has multiple reasons to succeed, it becomes difficult to determine the root cause of a failure if the test fails. This can lead to confusion and wasted time trying to debug the test.</p>
</div>
<div class="paragraph">
<p>This rule raises an issue when the following Chai.js assertions are found:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When <code>.not</code> and <a href="https://www.chaijs.com/api/bdd/#method_throw"><code>.throw</code></a> are used together and at least one argument is provided to <code>.throw</code>. Such assertions succeed when the target either does not throw any exception, or when it throws an exception different from the one provided.</p>
</li>
<li>
<p>When <code>.not</code> and <a href="https://www.chaijs.com/api/bdd/#method_include"><code>.include</code></a> are used together and an <code>object</code> is given to <code>.include</code>. Such assertions succeed when one or multiple key/values are missing.</p>
</li>
<li>
<p>When <code>.not</code> and <a href="https://www.chaijs.com/api/bdd/#method_property"><code>.property</code></a> are used together and <code>.property</code> is given at least two arguments. Such assertions succeed when the target either doesn&#8217;t have the requested property, or when this property exists but has a different value.</p>
</li>
<li>
<p>When <code>.not</code> and <a href="https://www.chaijs.com/api/bdd/#method_ownpropertydescriptor"><code>.ownPropertyDescriptor</code></a> are used together and <code>.ownPropertyDescriptor</code> is given at least two arguments. Such assertions succeed when the target either doesn&#8217;t have the requested property descriptor, or its property descriptor is not deeply equal to the given descriptor</p>
</li>
<li>
<p>When <code>.not</code> and <a href="https://www.chaijs.com/api/bdd/#method_members"><code>.members</code></a> are used together. Such assertions succeed when one or multiple members are missing.</p>
</li>
<li>
<p>When <a href="https://www.chaijs.com/api/bdd/#method_change"><code>.change</code></a> and <a href="https://www.chaijs.com/api/bdd/#method_by"><code>.by</code></a> are used together. Such assertions succeed when the target either decreases or increases by the given delta</p>
</li>
<li>
<p>When <code>.not</code> and <a href="https://www.chaijs.com/api/bdd/#method_increase"><code>.increase</code></a> are used together. Such assertions succeed when the target either decreases or stays the same.</p>
</li>
<li>
<p>When <code>.not</code> and <a href="https://www.chaijs.com/api/bdd/#method_decrease"><code>.decrease</code></a> are used together. Such assertions succeed when the target either increases or stays the same.</p>
</li>
<li>
<p>When <code>.not</code> negates <a href="https://www.chaijs.com/api/bdd/#method_by"><code>.by</code></a>. Such assertions succeed when the target didn&#8217;t change by one specific delta among all the possible deltas.</p>
</li>
<li>
<p>When <code>.not</code> and <a href="https://www.chaijs.com/api/bdd/#method_finite"><code>.finite</code></a> are used together. Such assertions succeed when the target either is not a <code>number</code>, or is one of <code>Nan</code>, positive <code>Infinity</code>, negative <code>Infinity</code>.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">const expect = require('chai').expect;

describe("Each Chai.js assertion", function() {
    const throwsTypeError = () =&gt; { throw new TypeError() }

    it("has more than one reason to succeed", function() {
        expect(throwsTypeError).to.not.throw(ReferenceError) // Noncompliant
        expect({a: 42}).to.not.include({b: 10, c: 20});  // Noncompliant
        expect({a: 21}).to.not.have.property('b', 42); // Noncompliant
        expect({a: 21}).to.not.have.ownPropertyDescriptor('b', {   // Noncompliant
            configurable: true,
            enumerable: true,
            writable: true,
            value: 42,
        });
        expect([21, 42]).to.not.have.members([1, 2]); // Noncompliant

        let myObj = { value: 1 }
        const incThree = () =&gt; { myObj.value += 3; };
        const decThree = () =&gt; { myObj.value -= 3; };
        const doNothing = () =&gt; {};

        expect(incThree).to.change(myObj, 'value').by(3); // Noncompliant
        expect(decThree).to.change(myObj, 'value').by(3); // Noncompliant

        expect(decThree).to.not.increase(myObj, 'value'); // Noncompliant
        expect(incThree).to.not.decrease(myObj, 'value'); // Noncompliant

        expect(doNothing).to.not.increase(myObj, 'value'); // Noncompliant
        expect(doNothing).to.not.decrease(myObj, 'value'); // Noncompliant

        expect(incThree).to.increase(myObj, 'value').but.not.by(1); // Noncompliant

        let toCheck;
        expect(toCheck).to.not.be.finite; // Noncompliant
    });
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>By having only one reason to succeed, the test is more precise and easier to understand. It also helps to ensure that the test is testing only one specific behavior or functionality of the code, which makes it easier to identify and fix any issues that arise.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">const expect = require('chai').expect;

describe("Each Chai.js assertion", function() {
    const throwsTypeError = () =&gt; { throw new TypeError() }

    it("has only one reason to succeed", function() {
        expect(throwsTypeError).to.throw(TypeError)
        expect({a: 42}).to.not.have.any.keys('b', 'c');
        expect({a: 21}).to.not.have.property('b');
        expect({a: 21}).to.not.have.ownPropertyDescriptor('b');
        expect([21, 42]).to.not.include(1).and.not.include(2);

        let myObj = { value: 1 }
        const incThree = () =&gt; { myObj.value += 3; };
        const decThree = () =&gt; { myObj.value -= 3; };
        const doNothing = () =&gt; {};

        expect(incThree).to.increase(myObj, 'value').by(3);
        expect(decThree).to.decrease(myObj, 'value').by(3);

        expect(decThree).to.decrease(myObj, 'value').by(3);
        expect(incThree).to.increase(myObj, 'value').by(3);

        expect(doNothing).to.not.change(myObj, 'value');

        expect(incThree).to.increase(myObj, 'value').by(3);

        let toCheck;
        // Either of the following is valid
        expect(toCheck).to.be.a('string');
        expect(toCheck).to.be.NaN;
        expect(toCheck).to.equal(Infinity);
        expect(toCheck).to.equal(-Infinity);
    });
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>Having only one reason to succeed also helps to make the test more maintainable. If the test needs to be updated or modified in the future, it is easier to do so when the test is focused on a single behavior or functionality.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_documentation">Documentation</h3>
<div class="ulist">
<ul>
<li>
<p>Chai.js Documentation - <a href="https://www.chaijs.com/api/bdd/#method_by"><code>.by</code></a></p>
</li>
<li>
<p>Chai.js Documentation - <a href="https://www.chaijs.com/api/bdd/#method_change"><code>.change</code></a></p>
</li>
<li>
<p>Chai.js Documentation - <a href="https://www.chaijs.com/api/bdd/#method_decrease"><code>.decrease</code></a></p>
</li>
<li>
<p>Chai.js Documentation - <a href="https://www.chaijs.com/api/bdd/#method_finite"><code>.finite</code></a></p>
</li>
<li>
<p>Chai.js Documentation - <a href="https://www.chaijs.com/api/bdd/#method_include"><code>.include</code></a></p>
</li>
<li>
<p>Chai.js Documentation - <a href="https://www.chaijs.com/api/bdd/#method_increase"><code>.increase</code></a></p>
</li>
<li>
<p>Chai.js Documentation - <a href="https://www.chaijs.com/api/bdd/#method_members"><code>.members</code></a></p>
</li>
<li>
<p>Chai.js Documentation - <a href="https://www.chaijs.com/api/bdd/#method_ownpropertydescriptor"><code>.ownPropertyDescriptor</code></a></p>
</li>
<li>
<p>Chai.js Documentation - <a href="https://www.chaijs.com/api/bdd/#method_property"><code>.property</code></a></p>
</li>
<li>
<p>Chai.js Documentation - <a href="https://www.chaijs.com/api/bdd/#method_throw"><code>.throw</code></a></p>
</li>
</ul>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_implementation_specification">Implementation Specification</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_message">Message</h3>
<div class="paragraph">
<p>Refactor this uncertain assertion; it can succeed for multiple reasons.</p>
</div>
</div>
<div class="sect2">
<h3 id="_highlighting">Highlighting</h3>
<div class="paragraph">
<p>The part of the assertion which is uncertain. We simply not highlight parts which are ok.</p>
</div>
<div class="paragraph">
<p>Example: In the following case</p>
</div>
<div class="literalblock">
<div class="content">
<pre>``++expect(throwsTypeError).to.exist.and.to.not.throw(ReferenceError);++``</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>The primary location should be on</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>``++and.to.not.throw(ReferenceError)++``</pre>
</div>
</div>
</div>
</div>
</div>