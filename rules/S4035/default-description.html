<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When a class implements the <code>IEquatable&lt;T&gt;</code> interface, it enters a contract that, in effect, states "I know how to compare two instances of type T or any type derived from T for equality.". However if that class is derived, it is very unlikely that the base class will know how to make a meaningful comparison. Therefore that implicit contract is now broken.</p>
</div>
<div class="paragraph">
<p>Alternatively <code>IEqualityComparer&lt;T&gt;</code> provides a safer interface and is used by collections or <code>Equals</code> could be made <code>virtual</code>.</p>
</div>
<div class="paragraph">
<p>This rule raises an issue when an unsealed, <code>public</code> or <code>protected</code> class implements <code>IEquatable&lt;T&gt;</code> and the <code>Equals</code> is neither <code>virtual</code> nor <code>abstract</code>.</p>
</div>
<div class="sect2">
<h3 id="_noncompliant_code_example">Noncompliant code example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-csharp" data-lang="csharp">using System;

namespace MyLibrary
{
  public class Base : IEquatable&lt;Base&gt; // Noncompliant
  {
    public bool Equals(Base other)
    {
      if (other == null) { return false; }
      // do comparison of base properties
      return true;
    }

    public override bool Equals(object other)  =&gt; Equals(other as Base);
  }

  class A : Base
  {
    public bool Equals(A other)
    {
      if (other == null) { return false; }
      // do comparison of A properties
      return base.Equals(other);
    }

    public override bool Equals(object other)  =&gt; Equals(other as A);
  }

  class B : Base
  {
    public bool Equals(B other)
    {
      if (other == null) { return false; }
      // do comparison of B properties
      return base.Equals(other);
    }

    public override bool Equals(object other)  =&gt; Equals(other as B);
  }

  internal class Program
  {
    static void Main(string[] args)
    {
        A a = new A();
        B b = new B();
         Console.WriteLine(a.Equals(b)); // This calls the WRONG equals. This causes Base.Equals(Base)
                                         // to be called which only compares the properties in Base and ignores the fact that
                                         // a and b are different types. In the working example A.Equals(Object) would have been
                                         // called and Equals would return false because it correctly recognizes that a and b are
                                         // different types. If a and b have the same base properties they will be returned as equal.
    }
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_compliant_solution">Compliant solution</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-csharp" data-lang="csharp">using System;

namespace MyLibrary
{
    public sealed class Foo : IEquatable&lt;Foo&gt;
    {
        public bool Equals(Foo other)
        {
            // Your code here
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://msdn.microsoft.com/en-us/library/ms132151(v=vs.110).aspx">IEqualityComparer&lt;T&gt; Interface</a></p>
</div>
<hr>
</div>
</div>
<div class="sect1">
<h2 id="_implementation_specification">Implementation Specification</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_message">Message</h3>
<div class="paragraph">
<p>Seal class "XXX" or implement "IEqualityComparer&lt;T&gt;" instead.</p>
</div>
</div>
<div class="sect2">
<h3 id="_highlighting">Highlighting</h3>
<div class="paragraph">
<p>Class declaration</p>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_comments_and_links">Comments And Links</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_on_21_jun_2017_112600_amaury_levé_wrote">on 21 Jun 2017, 11:26:00 Amaury Levé wrote:</h3>
<div class="paragraph">
<p>We decided not to recommend sealing the class when implementing <code>Equals(object)</code> as it is possible for sub-classes to change the behavior. Besides, we also added an exception to the rule to say we don&#8217;t report if the <code>Equals(T)</code> is <code>virtual</code>.</p>
</div>
</div>
</div>
</div>