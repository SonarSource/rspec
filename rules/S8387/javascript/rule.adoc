== Why is this an issue?

Inter-process communication (IPC) mechanisms allow data exchange between
separate processes or execution contexts. When user-controlled data flows into
IPC channels without proper validation or sanitization, it can lead to security
vulnerabilities in the receiving process.

The receiving process often operates with a different trust level or security
context. +
By passing unvalidated data through IPC, an attacker can potentially exploit
vulnerabilities in the receiving process, bypass security controls, or cause
unintended behavior in components that assume incoming IPC data is trustworthy.

=== What is the potential impact?

When tainted data is sent through IPC channels without proper validation,
several security issues can arise, depending on how the receiving process trusts
the data.

==== Remote code execution

If the receiving process interprets the IPC data as commands or code, an
attacker could execute arbitrary code in the context of that process. This is
particularly dangerous when the receiving process has elevated privileges.

==== Security control bypass

IPC often crosses security boundaries between processes. Sending unvalidated
data can allow attackers to bypass access controls, authentication mechanisms,
or sandboxing implemented in the receiving process.

==== Data corruption and integrity issues

Malicious data passed through IPC can corrupt the state of the receiving
process, leading to incorrect behavior, crashes, or data loss in dependent
systems.

== How to fix it

=== Code examples

The following code is vulnerable because user-controlled data is sent directly
through IPC without validation.

==== Noncompliant code example

[source,javascript,diff-id=1,diff-type=noncompliant]
----
const { fork } = require('child_process');

function handleRequest(req, res) {
    const userInput = req.query.data;

    const child = fork('./worker.js');
    child.send({ command: userInput });
}
----

==== Compliant solution

[source,javascript,diff-id=1,diff-type=compliant]
----
const { fork } = require('child_process');

const ALLOWED_COMMANDS = ['process', 'analyze', 'transform'];

function handleRequest(req, res) {
    const userInput = req.query.data;

    if (!ALLOWED_COMMANDS.includes(userInput)) {
        res.status(400).send('Invalid command');
        return;
    }

    const child = fork('./worker.js');
    child.send({ command: userInput });
}
----

=== How does this work?

==== Input validation

The compliant solution validates user input against an allowlist of permitted
values before sending it through IPC. This ensures that only expected,
legitimate data reaches the receiving process.

When validating IPC data:

* Use allowlists to restrict input to known-safe values when possible.
* Validate the structure and type of complex data objects.
* Sanitize string inputs to remove or escape potentially dangerous characters.
* Consider the trust model of the receiving process when determining validation
  requirements.

== Resources

=== Documentation

* Node.js Documentation - https://nodejs.org/api/child_process.html[Child Processes]
* OWASP - https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html[Input Validation Cheat Sheet]

=== Standards

* OWASP Top 10 2021 - https://owasp.org/Top10/A03_2021-Injection/[A03:2021 - Injection]
* CWE - https://cwe.mitre.org/data/definitions/20[CWE-20 - Improper Input Validation]


ifdef::env-github,rspecator-view[]

'''
== Implementation Specification
(visible only on this page)

=== Message

Ensure that tainted data is validated before being sent through IPC.

=== Highlighting

Highlight the IPC send call that receives tainted data.

'''
== Comments And Links
(visible only on this page)

endif::env-github,rspecator-view[]
