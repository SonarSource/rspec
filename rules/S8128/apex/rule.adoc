This is an issue when an Apex class contains more than one method annotated with `@InvocableMethod`.

== Why is this an issue?

The Salesforce platform only supports one invocable method per Apex class. When a Flow calls an Apex action, it needs to know exactly which method to invoke.

If multiple methods in the same class have the `@InvocableMethod` annotation, Salesforce cannot determine which method should be called. This creates ambiguity that the platform resolves by throwing a runtime error.

The `@InvocableMethod` annotation is specifically designed to expose Apex methods to declarative automation tools like Flow Builder. Each class acts as a single callable unit from the Flow perspective, so having multiple entry points violates this design principle.

This limitation is enforced at the platform level and cannot be overridden through configuration or workarounds.

=== What is the potential impact?

When a Flow attempts to call an Apex action from a class with multiple `@InvocableMethod` annotations, it will fail at runtime with an error. This can cause:

* Flow execution failures that interrupt business processes
* User-facing errors in screen flows
* Failed automated processes that may leave data in an inconsistent state
* Difficulty troubleshooting since the error occurs at runtime rather than compile time

== How to fix it

Remove the @InvocableMethod annotation from all but one method in the class. If you need multiple invocable methods, create separate classes for each one.

=== Code examples

==== Noncompliant code example

[source,apex,diff-id=1,diff-type=noncompliant]
----
public class MyInvocableClass {
    @InvocableMethod
    public static void method1(List<String> inputs) {
        // Implementation
    }
    
    @InvocableMethod // Noncompliant
    public static void method2(List<String> inputs) {
        // Implementation
    }
}
----

==== Compliant solution

[source,apex,diff-id=1,diff-type=compliant]
----
public class MyInvocableClass {
    @InvocableMethod
    public static void method1(List<String> inputs) {
        // Implementation
    }
    
    public static void method2(List<String> inputs) {
        // Implementation - now a regular method
    }
}

// Or create a separate class for the second invocable method
public class MySecondInvocableClass {
    @InvocableMethod
    public static void method2(List<String> inputs) {
        // Implementation
    }
}
----

== Resources

=== Documentation

 * Salesforce Flow Best Practices - https://www.apexhours.com/salesforce-flow-best-practices[Comprehensive guide to Flow Builder best practices including invocable method limitations]

 * InvocableMethod Annotation - https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/apex_classes_annotation_InvocableMethod.htm[Official Salesforce documentation for the @InvocableMethod annotation]
