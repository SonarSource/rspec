<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>XPath injections occur in an application when the application retrieves
untrusted data and inserts it into an XML Path (XPath) query without sanitizing
it first.</p>
</div>
<div class="sect2">
<h3 id="_what_is_the_potential_impact">What is the potential impact?</h3>
<div class="paragraph">
<p>In the context of a web application vulnerable to XPath injection:<br>
After discovering the injection point, attackers insert data into the
vulnerable field to execute malicious commands in the affected XML documents.</p>
</div>
<div class="paragraph">
<p>The impact of this vulnerability depends on the importance of XML
structures in the enterprise.<br>
In cases where organizations rely on XML structures for business-critical
operations or where XML is used only for innocuous data transport, the severity
of an attack ranges from critical to harmless.</p>
</div>
<div class="paragraph">
<p>Below are some real-world scenarios that illustrate some impacts of an attacker
exploiting the vulnerability.</p>
</div>
<div class="sect3">
<h4 id="_data_leaks">Data Leaks</h4>
<div class="paragraph">
<p>A malicious XPath query allows direct data leakage from one or more databases.
Although XML is not as widely used as it once was, this possibility still
exists with configuration files, for example.</p>
</div>
</div>
<div class="sect3">
<h4 id="_data_deletion_and_denial_of_service">Data deletion and denial of service</h4>
<div class="paragraph">
<p>The malicious query allows the attacker to delete data in the affected XML
documents.<br>
This threat is particularly insidious if the attacked organization does not
maintain a disaster recovery plan (DRP) and if XML structures are considered
important, as missing critical data can disrupt the regular operations of an
organization.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_fix_it_in_lxml">How to fix it in lxml</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_code_examples">Code examples</h3>
<div class="paragraph">
<p>The following noncompliant code is vulnerable to XPath injection because untrusted data is
concatenated to an XPath query without prior validation.</p>
</div>
<div class="sect3">
<h4 id="_noncompliant_code_example">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">from flask import request
from lxml import etree

@app.route('/authenticate')
def authenticate():
    username = request.args['username']
    password = request.args['password']
    expression = "./users/user[@name='" + username + "' and @pass='" + password + "']"
    tree = etree.parse('resources/users.xml')

    if tree.find(expression) is None:
        return "Invalid credentials", 401
    else:
        return "Success", 200</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">from flask import request
from lxml import etree

@app.route('/authenticate')
def authenticate():
    username = request.args['username']
    password = request.args['password']
    expression = "./users/user[@name=$username and @pass=$password]"
    tree = etree.parse('resources/users.xml')

    if tree.xpath(expression, username=username, password=password) is None:
        return "Invalid credentials", 401
    else:
        return "Success", 200</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_how_does_this_work">How does this work?</h3>
<div class="paragraph">
<p>As a rule of thumb, the best approach to protect against injections is to
systematically ensure that untrusted data cannot break out of the initially
intended logic.</p>
</div>
<div class="sect3">
<h4 id="_parameterized_queries">Parameterized Queries</h4>
<div class="paragraph">
<p>For XPath injections, the cleanest way to do so is to use parameterized queries.</p>
</div>
<div class="paragraph">
<p>XPath allows for the usage of variables inside expressions in the form of <code>$variable</code>. XPath variables can be used to construct an XPath query without needing to concatenate user arguments to the query at runtime. Here is an example of an XPath query with variables:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>/users/user[@user=$user and @pass=$pass]</pre>
</div>
</div>
<div class="paragraph">
<p>When the XPath query is executed, the user input is passed alongside it. During execution, when the values of the variables need to be known, a resolver will return the correct user input for each variable. The contents of the variables are not considered application logic by the XPath executor, and thus injection is not possible.</p>
</div>
<div class="paragraph">
<p>In the example, the username and password are passed as <a href="https://lxml.de/xpathxslt.html#:~:text=The%20xpath()%20method%20has%20support%20for%20XPath%20variables%3A">XPath variables</a> rather than concatenated to the XPath query. By using a parameterized query, injection is successfully prevented.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_fix_it_in_the_python_standard_library">How to fix it in the Python Standard Library</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_code_examples_2">Code examples</h3>
<div class="paragraph">
<p>The following noncompliant code is vulnerable to XPath injection because untrusted data is
concatenated to an XPath query without prior validation. Although <code>xml.etree.ElementTree</code> only
supports a subset of XPath syntax, exploitation can still be possible.</p>
</div>
<div class="sect3">
<h4 id="_noncompliant_code_example_2">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">from xml.etree import ElementTree
from flask import request

@app.route('/authenticate')
def authenticate():
    username = request.args['username']
    password = request.args['password']
    expression = "./users/user[@name='" + username + "'][@pass='" + password + "']"
    tree = ElementTree.parse('resources/users.xml')

    if tree.find(expression) is None:
        return "Invalid credentials", 401
    else:
        return "Success", 200</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution_2">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">import re
from xml.etree import ElementTree
from flask import request

tree = ElementTree.parse('resources/users.xml')

@app.route('/authenticate')
def authenticate():
    username = request.args['username']
    password = request.args['password']

    if re.match("^[a-zA-Z0-9]*$", username) is None or re.match("^[a-zA-Z0-9]*$", password) is None:
        return "Username or password contains invalid characters", 400

    expression = "./users/user[@name='" + username + "'][@pass='" + password + "']"
    tree = ElementTree.parse('resources/users.xml')

    if tree.find(expression) is None:
        return "Invalid credentials", 401
    else:
        return "Success", 200</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_how_does_this_work_2">How does this work?</h3>
<div class="paragraph">
<p>As a rule of thumb, the best approach to protect against injections is to
systematically ensure that untrusted data cannot break out of the initially
intended logic.</p>
</div>
<div class="sect3">
<h4 id="_parameterized_queries_2">Parameterized Queries</h4>
<div class="paragraph">
<p>For XPath injections, the cleanest way to do so is to use parameterized queries.</p>
</div>
<div class="paragraph">
<p>XPath allows for the usage of variables inside expressions in the form of <code>$variable</code>. XPath variables can be used to construct an XPath query without needing to concatenate user arguments to the query at runtime. Here is an example of an XPath query with variables:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>/users/user[@user=$user and @pass=$pass]</pre>
</div>
</div>
<div class="paragraph">
<p>When the XPath query is executed, the user input is passed alongside it. During execution, when the values of the variables need to be known, a resolver will return the correct user input for each variable. The contents of the variables are not considered application logic by the XPath executor, and thus injection is not possible.</p>
</div>
<div class="paragraph">
<p>It is not possible to construct parameterized queries using only the Python Standard Library.<br>
Please use <a href="https://pypi.org/project/lxml/">lxml</a> instead, which allows for parameterized queries using the <code>ElementTree.xpath()</code> method.</p>
</div>
</div>
<div class="sect3">
<h4 id="_validation">Validation</h4>
<div class="paragraph">
<p>In case XPath parameterized queries are not available, the most secure way to protect against injections is to validate the input before using it in an XPath query.</p>
</div>
<div class="paragraph">
<p><strong>Important</strong>: The application must do this validation server-side. Validating this client-side is insecure.</p>
</div>
<div class="paragraph">
<p>Input can be validated in multiple ways:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>By checking against a list of authorized and secure strings that the application is allowed to use in a query.</p>
</li>
<li>
<p>By ensuring user input is restricted to a specific range of characters (e.g., the regex <code>/^[a-zA-Z0-9]*$/</code> only allows alphanumeric characters.)</p>
</li>
<li>
<p>By ensuring user input does not include any XPath metacharacters, such as <code>"</code>, <code>'</code>, <code>/</code>, <code>@</code>, <code>=</code>, <code>*</code>, <code>[</code>, <code>]</code>, <code>(</code> and <code>)</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If user input is not considered valid, it should be rejected as it is unsafe.</p>
</div>
<div class="paragraph">
<p>In the example, we ensure that the username and password only contain alphanumeric characters by doing a regex match before executing the XPath query.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_standards">Standards</h3>
<div class="ulist">
<ul>
<li>
<p>OWASP - <a href="https://owasp.org/Top10/A03_2021-Injection/">Top 10 2021 Category A3 - Injection</a></p>
</li>
<li>
<p>OWASP - <a href="https://owasp.org/www-project-top-ten/2017/A1_2017-Injection">Top 10 2017 Category A1 - Injection</a></p>
</li>
<li>
<p>CWE - <a href="https://cwe.mitre.org/data/definitions/20">CWE-20 - Improper Input Validation</a></p>
</li>
<li>
<p>CWE - <a href="https://cwe.mitre.org/data/definitions/643">CWE-643 - Improper Neutralization of Data within XPath Expressions</a></p>
</li>
<li>
<p>STIG Viewer - <a href="https://stigviewer.com/stigs/application_security_and_development/2024-12-06/finding/V-222608">Application Security and Development: V-222608</a> - The application must not be vulnerable to XML-oriented attacks.</p>
</li>
<li>
<p>STIG Viewer - <a href="https://stigviewer.com/stigs/application_security_and_development/2024-12-06/finding/V-222609">Application Security and Development: V-222609</a> - The application must not be subject to input handling vulnerabilities.</p>
</li>
</ul>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_implementation_specification">Implementation Specification</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_message">Message</h3>
<div class="paragraph">
<p>Change this code to not construct this XPath expression from user-controlled data.</p>
</div>
<hr>
<hr>
</div>
</div>
</div>