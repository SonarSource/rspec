== How to fix it in .NET

=== Code examples
The following code is vulnerable to XPath injections because untrusted data is
concatenated in an XPath query without prior validation.

==== Noncompliant code example

[source,vbnet,diff-id=1,diff-type=noncompliant]
----
Public Class ExampleController
    Inherits Controller

    <HttpGet>
    Public Function Authenticate(user As String, pass As String) As IActionResult
        Dim doc As New XmlDocument()
        
        Dim expression As String = "/users/user[@name='" + user + "' and @pass='" + pass + "']"

        Return Json(doc.SelectSingleNode(expression) IsNot Nothing)
    End Function
End Class
----

==== Compliant solution

[source,vbnet,diff-id=1,diff-type=compliant]
----
Public Class ExampleController
    Inherits Controller

    <HttpGet>
    Public Function Authenticate(user As String, pass As String) As IActionResult
        Dim doc As New XmlDocument()
        If Not Regex.IsMatch(user, "^[a-zA-Z]+$") OrElse Not Regex.IsMatch(pass, "^[a-zA-Z]+$") Then
            Return BadRequest()
        End If

        Dim expression As String = "/users/user[@name='" + user + "' and @pass='" + pass + "']"

        Return Json(doc.SelectSingleNode(expression) IsNot Nothing)
    End Function
End Class
----

=== How does this work?

As a rule of thumb, the best approach to protect against injections is to
systematically ensure that untrusted data cannot break out of the initially
intended logic.

include::../../common/fix/validation.adoc[]

In the example, a validation mechanism is applied to untrusted input to ensure
it is strictly composed of alphabetic characters.
