=== How to fix it in the Python Standard Library

The following noncompliant code is vulnerable to XPath injections because untrusted data is
concatenated to an XPath query without prior validation. Although `xml.etree.ElementTree` only
supports a subset of XPath syntax, exploitation can still be possible.

==== Noncompliant code example

[source,python,diff-id=1,diff-type=noncompliant]
----
from xml.etree import ElementTree

def authenticate(tree: ElementTree, username: str, password: str) -> bool:
    expression = "./users/user[@name='" + username + "'][@pass='" + password + "']"

    return tree.find(expression) is not None
----

////
The above example would be exploitable by using e.g. `username=”admin][.!=”` and `password=”][.!='XXXXX”`
This creates the following query: `./users/user[@name='admin][.!='][@pass='][.!='XXXXX']`,
where `[.!='][@pass=']` and `[.!='XXXXX']` should match on everything, resulting in authentication as admin.
////

==== Compliant solution

[source,python,diff-id=1,diff-type=compliant]
----
from xml.etree import ElementTree
import re

def authenticate(tree: ElementTree, username: str, password: str) -> bool:
    if re.match(/^[a-zA-Z0-9]*$/, username) is None or re.match(/^[a-zA-Z0-9]*$/, username) is None:
        raise ValueError("Username or password contains invalid characters")
    expression = "./users/user[@name='" + username + "'][@pass='" + password + "']"

    return tree.find(expression) is not None
----

=== How does this work?

As a rule of thumb, the best approach to protect against injections is to
systematically ensure that untrusted data cannot break out of the initially
intended logic.

include::../../common/fix/parameterized-queries.adoc[]

It is not possible to construct parameterized queries using only the Python Standard Library. +
Please use https://pypi.org/project/lxml/[lxml] instead, which allows for parameterized queries using the `ElementTree.xpath()` method.

include::../../common/fix/validation.adoc[]

In the example, we ensure that the username and password only contain alphanumeric characters by doing a regex match before executing the XPath query.
