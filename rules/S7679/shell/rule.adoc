This rule raises an issue when shell functions use positional parameters (`$1`, `$2`, etc.) directly in their body without first assigning them to local variables with descriptive names.

== Why is this an issue?

Using positional parameters directly in shell functions makes code harder to read and maintain. When you see `$1` or `$2` in the middle of a function, it's not immediately clear what that parameter represents or how it's being used.

Shell functions can accept multiple parameters, and as functions grow in complexity, keeping track of what each numbered parameter means becomes increasingly difficult. This is especially problematic when:

* Functions have multiple parameters
* Functions are longer than a few lines
* Code is reviewed or maintained by different developers
* Functions are modified over time and parameter meanings change

Assigning positional parameters to local variables with descriptive names at the beginning of a function serves as inline documentation. It makes the function's interface explicit and the code's intent clear. This practice also makes refactoring safer, as you're less likely to mix up parameter positions when they have meaningful names.

This approach follows the principle of writing self-documenting code, where the code itself explains what it does without requiring additional comments.

=== What is the potential impact?

Poor code readability can lead to maintenance difficulties and increase the likelihood of introducing bugs during code modifications. When developers cannot easily understand what parameters represent, they may:

* Make incorrect assumptions about parameter usage
* Introduce bugs when modifying or extending functions
* Spend extra time deciphering code during debugging or code reviews
* Create inconsistent code patterns across the codebase

While this issue doesn't directly impact security or runtime behavior, it significantly affects code maintainability and team productivity.

=== How to fix?


Assign positional parameters to local variables with descriptive names at the beginning of the function. Use the `local` keyword to ensure variables are scoped to the function.

==== Non-compliant code example

[source,bash,diff-id=1,diff-type=noncompliant]
----
process_file() {
  echo "Processing $1 with $2"  # Noncompliant
  if [[ -f "$1" ]]; then
    cat "$1" | grep "$3"
  fi
}
----

==== Compliant code example

[source,bash,diff-id=1,diff-type=compliant]
----
process_file() {
  local filename="$1"
  local options="$2"
  local pattern="$3"
  
  echo "Processing $filename with $options"
  if [[ -f "$filename" ]]; then
    cat "$filename" | grep "$pattern"
  fi
}
----

=== Documentation

 * LinuxCommand.org - Bash Script Coding Style Guide - https://linuxcommand.org/lc3_adv_standards.php[Comprehensive guide to shell scripting best practices including function parameter handling]
 * Bash Manual - Shell Functions - https://www.gnu.org/software/bash/manual/html_node/Shell-Functions.html[Official documentation on bash shell functions and parameter handling]
 * Google Shell Style Guide - https://google.github.io/styleguide/shellguide.html[Google's comprehensive style guide for shell scripting]

