This rule raises an issue when a goroutine is manually created with `time.Sleep()` to implement timeouts, instead of using the idiomatic `time.After()` function.

== Why is this an issue?

Go provides the `time.After()` function as the standard, idiomatic way to create timeout channels. This function returns a channel that receives a value after a specified duration.

Manually creating timeout goroutines with `time.Sleep()` has several drawbacks:

* **More verbose**: Requires more boilerplate code to achieve the same result
* **Resource management**: You need to ensure proper cleanup and handle edge cases
* **Less readable**: The intent is less clear compared to the explicit `time.After()` call
* **Error-prone**: Manual implementations can introduce subtle bugs in goroutine lifecycle management

The `time.After()` function handles all the complexity internally and provides a clean, expressive API that clearly communicates the timeout intent. It automatically manages the underlying goroutine and ensures proper resource cleanup.

=== What is the potential impact?

Using manual timeout goroutines instead of `time.After()` leads to more complex, harder-to-maintain code. While not a security issue, it can make the codebase less readable and more prone to bugs in timeout handling logic.

== How to fix it

Replace the manual timeout goroutine with `time.After()`. This eliminates the need for explicit goroutine creation and channel management.

=== Code examples

==== Noncompliant code example

[source,go,diff-id=1,diff-type=noncompliant]
----
timeout := make(chan bool, 1)
go func() {
    time.Sleep(1 * time.Second)
    timeout <- true
}()

select {
case <-ch:
    // handle data
case <-timeout: // Noncompliant
    // handle timeout
}
----

==== Compliant solution

[source,go,diff-id=1,diff-type=compliant]
----
select {
case <-ch:
    // handle data
case <-time.After(1 * time.Second):
    // handle timeout
}
----

== Resources

=== Documentation

 * Go time.After documentation - https://pkg.go.dev/time#After[Official documentation for the time.After function]

 * Go Concurrency Patterns: Timing out - https://go.dev/blog/go-concurrency-patterns-timing-out-and[Official Go blog post explaining timeout patterns and recommending time.After]
