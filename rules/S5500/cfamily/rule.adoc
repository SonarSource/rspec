== Why is this an issue?

Rvalue reference arguments allow to transfer ownership of objects.

When a function has an argument of type rvalue reference, it is expected to call ``++std::move++`` to take ownership of the corresponding parameter when it is called.

If it does not do it or if it does it conditionally, ownership is unclear and this might lead to bugs.


This rule does not apply when the argument is a forwarding reference.


=== Noncompliant code example

[source,cpp]
----
enum class Shape {
  empty, circle, square
};

class DrawingStore {
  std::vector<Shape> store;
public:
  void insertShape(Shape &&shape) {
    store.emplace_back(shape); // Noncompliant, call to std::move is expected
  }  

  void insertIfCircle(Shape &&shape) {
      if (shape == Shape::circle) {
          store.emplace_back(std::move(shape)); // Noncompliant, std::move is not always called, ownership of shape is not clear
      }    
  }  
};
----


=== Compliant solution

[source,cpp]
----
enum class Shape {
  empty, circle, square
};

class DrawingStoreOk {
  std::vector<Shape> store;
public:
  void insertShape(Shape &&shape) {
    store.emplace_back(std::move(shape));
  }  

  void insertIfCircle(const Shape &shape) {
      if (shape == Shape::circle) {
          store.emplace_back(shape);
      }    
  }  
};
----

== Exceptions

For the {cpp}23 or later standard, this rule does not raise issues if the function returns the rvalue reference parameter.
In such cases, the parameter is implicitly moved, and an explicit call to `std::move` is not required:
[source,cpp]
----
Shape updateShape(Shape&& shape) {
  /* ... */
  return shape; // Compliant: implicitly moves shape
}
----

When returning a parameter or variable of rvalue reference type, an implicit move
was introduced in {cpp}20, and retroactively applied to previous standards. 
As a consequence, the behavior of such return statements is not consistent across compilers
and standard versions.

Furthermore, with the {cpp}20 rules, the implicit move is not triggered if the function
returns a reference:
[source,cpp]
----
Shape&& updateShape(Shape&& shape) {
  /* ... */
  // C++23: Implicit moves, equivalent to `std::move(shape)`
  // C++20: No moves, ill-formed as Shape&& reference cannot bound to Shape&
  return shape; 
}
----

Due to all of the above, this rule does not treat `return p` as an exception in {cpp} standard prior to {cpp}23,
and require explicit move `return std::move(p)`. 

In contrast to returning local (stack) variables, named return value optimization (NRVO)
does not apply to function parameters, so an explicit `std::move` call has no impact on optimizations.


== Resources

* {cpp} Core Guidelines - https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f18-for-will-move-from-parameters-pass-by-x-and-stdmove-the-parameter[F.18: For "will-move-from" parameters, pass by `X&&` and `std::move` the parameter]
* {cpp} reference - https://en.cppreference.com/w/cpp/language/copy_elision[Copy elision]

ifdef::env-github,rspecator-view[]

'''
== Implementation Specification
(visible only on this page)

=== Message

"std::move" is never called on this rvalue reference argument.


'''
== Comments And Links
(visible only on this page)

=== relates to: S5272

endif::env-github,rspecator-view[]
