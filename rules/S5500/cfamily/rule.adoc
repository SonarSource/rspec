== Why is this an issue?

Rvalue reference arguments allow to transfer ownership of objects.

When a function has an argument of type rvalue reference, it is expected to call ``++std::move++`` to take ownership of the corresponding parameter when it is called.

If it does not do it or if it does it conditionally, ownership is unclear and this might lead to bugs.


This rule does not apply when the argument is a forwarding reference.


=== Noncompliant code example

[source,cpp]
----
enum class Shape {
  empty, circle, square
};

class DrawingStore {
  std::vector<Shape> store;
public:
  void insertShape(Shape &&shape) {
    store.emplace_back(shape); // Noncompliant, call to std::move is expected
  }  

  void insertIfCircle(Shape &&shape) {
      if (shape == Shape::circle) {
          store.emplace_back(std::move(shape)); // Noncompliant, std::move is not always called, ownership of shape is not clear
      }    
  }  
};
----


=== Compliant solution

[source,cpp]
----
enum class Shape {
  empty, circle, square
};

class DrawingStoreOk {
  std::vector<Shape> store;
public:
  void insertShape(Shape &&shape) {
    store.emplace_back(std::move(shape));
  }  

  void insertIfCircle(const Shape &shape) {
      if (shape == Shape::circle) {
          store.emplace_back(shape);
      }    
  }  
};
----

== Exceptions

For the {cpp}23 or later standard, does not raise issues if the function returns the rvalue reference parameter.
In such cases, the parameter is implicitly moved, and explicit call  `std::move` is not required:
[source,cpp]
----
Shape updateShape(Shape&& shape) {
  /* ... */
  return shape; // Compliant: implicitly moves shape
}
----

An implicit move in case of returning a parameter or variable of rvalue reference parameter,
was introduced in {cpp}20 timeframe, and retroactively applied to previous standards. 
As a consequence, depending on the compiler version behavior of such return statement
is not consistient accross complies.
Furthermore, with the {cpp}20 rules, the implicit move is not triggered if the function
returns reference:
[source,cpp]
----
Shape&& updateShape(Shape&& shape) {
  /* ... */
  // C++23: Implicit moves, equivalent to `std::move(shape)`
  // C++20: No moves, ill-formed as Shape&& reference cannot bound to Shape&
  return shape; 
}
----

Due to all of the above, we do not tree `return p` as an exception in {cpp} standard prior to {cpp}23,
and you should write `return std::move(p)`. 
In contrast to returning local (stack) variables, named return value optimization (NRVO)
does not apply to function parameters, so such explicit move have no impact on optimizations.


== Resources

* {cpp} Core Guidelines - https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f18-for-will-move-from-parameters-pass-by-x-and-stdmove-the-parameter[F.18: For "will-move-from" parameters, pass by `X&&` and `std::move` the parameter]
* {cpp} reference - https://en.cppreference.com/w/cpp/language/copy_elision[Copy elision]

ifdef::env-github,rspecator-view[]

'''
== Implementation Specification
(visible only on this page)

=== Message

"std::move" is never called on this rvalue reference argument.


'''
== Comments And Links
(visible only on this page)

=== relates to: S5272

endif::env-github,rspecator-view[]
