This rule raises an issue when a `ScopedValue` instance is not declared with both `static` and `final` modifiers.

== Why is this an issue?

ScopedValue instances should be declared as `static final` fields to follow the recommended pattern.

ScopedValue objects act as keys to access their bound values. When not declared as `static final`:

* Non-final references can be reassigned, creating security risks
* Without `static`, each class instance creates its own ScopedValue
* This violates the intended design where ScopedValue instances should be immutable references

=== What is the potential impact?

Improper declaration may lead to security vulnerabilities or functional issues where scoped values don't work as expected.

== How to fix it

Declare the ScopedValue as a static final field.

=== Code examples

==== Noncompliant code example

[source,java,diff-id=1,diff-type=noncompliant]
----
public class Framework {
    private ScopedValue<FrameworkContext> context = ScopedValue.newInstance(); // Noncompliant
}
----

==== Compliant solution

[source,java,diff-id=1,diff-type=compliant]
----
public class Framework {
    private static final ScopedValue<FrameworkContext> CONTEXT = ScopedValue.newInstance();
}
----

== Resources

=== Documentation

 * JEP 506: Scoped Values - https://openjdk.org/jeps/506[Official JEP documentation for Scoped Values feature]

 * ScopedValue JavaDoc - https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/ScopedValue.html[Official API documentation for ScopedValue class]

=== Related rules

 * RSPEC-1170 - https://rules.sonarsource.com/java/RSPEC-1170/[Public constants and fields initialized at declaration should be "static final" rather than just "final"]
