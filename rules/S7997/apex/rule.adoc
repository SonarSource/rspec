This rule raises an issue when trigger code uses hardcoded array indices like `Trigger.New[0]` to access trigger context variables.

== Why is this an issue?

Salesforce triggers are designed to handle bulk operations efficiently, processing multiple records in a single transaction. When you use hardcoded array indices like `Trigger.New[0]`, your code only processes the first record and completely ignores all other records in the bulk operation.

This approach violates the fundamental principle of "bulkifying" Apex code. In Salesforce's multi-tenant environment, operations often involve multiple records at once. For example, when importing data, updating records via API, or using Data Loader, hundreds or thousands of records might be processed in a single trigger execution.

By accessing only the first record, your trigger logic fails silently for all subsequent records. This can lead to:

* Incomplete business logic execution
* Data inconsistencies
* Unexpected application behavior
* Poor performance and scalability issues

The Salesforce platform is optimized for bulk operations, and triggers that don't handle multiple records properly can cause significant problems in production environments where bulk data operations are common.

=== What is the potential impact?

When triggers only process the first record in a bulk operation, the remaining records bypass the intended business logic entirely. This can result in data integrity issues, incomplete validations, and inconsistent application behavior. In scenarios involving data imports, API integrations, or batch updates, this pattern can cause widespread data problems that are difficult to detect and fix.

== How to fix it

Replace hardcoded array index access with a loop that iterates over the entire trigger context collection. This ensures all records in the bulk operation are processed correctly.

=== Code examples

==== Noncompliant code example

[source,apex,diff-id=1,diff-type=noncompliant]
----
trigger AccountTrigger on Account(before insert) {
    Account acc = Trigger.New[0]; // Noncompliant
    if (acc.Name != null) {
        // Business logic only applies to first record
    }
}
----

==== Compliant solution

[source,apex,diff-id=1,diff-type=compliant]
----
trigger AccountTrigger on Account(before insert) {
    for (Account acc : Trigger.New) {
        if (acc.Name != null) {
            // Business logic applies to all records
        }
    }
}
----

== Resources

=== Documentation

 * Apex Triggers Best Practices - https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/apex_triggers_best_practices.htm[Official Salesforce documentation on trigger best practices including bulk processing]

 * Bulkifying Apex Code - https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/apex_gov_limits_intro.htm[Salesforce guide on writing bulk-safe Apex code to avoid governor limits]

=== Standards

 * Salesforce Apex Best Practices - https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/apex_intro.htm[Official Salesforce guidelines for writing efficient and scalable Apex code]
