<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In the standard library, several functions, instead of taking an object as an argument, take a list of arguments that will be used to construct an object in a specific place:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>std::vector::emplace_back</code> will create the object directly inside the vector</p>
</li>
<li>
<p><code>std::make_unique</code> will create the object and a <code>unique_ptr</code> that points to it</p>
</li>
<li>
<p><code>std::make_shared</code> will create the object in a specially allocated memory area that will also contain bookkeeping information for the shared pointer, and the associated <code>shared_ptr</code></p>
</li>
<li>
<p><code>std::optional</code> has a constructor that will create an object inside the optional (this constructor is selected by using <code>std::in_place</code> as its first argument)</p>
</li>
<li>
<p>&#8230;&#8203;</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These functions are said to perform delegated object creation.</p>
</div>
<div class="paragraph">
<p>Constructing an object externally and passing it to one of these functions is possible. They will then create their object by calling the copy constructor to copy the argument. But it defeats the purpose of those functions that try to create the object at the right place directly.</p>
</div>
<div class="paragraph">
<p>This rule raises an issue when a function that performs delegated object creation is passed an object of the right type explicitly created for this purpose only.</p>
</div>
<div class="sect2">
<h3 id="_noncompliant_code_example">Noncompliant code example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">struct Point {
  Point(int x, int y);
  Point(std::string_view serialized);
};

void f() {
  auto p1 = std::make_unique&lt;Point&gt;(Point(1, 2)); // Noncompliant
  auto p2 = std::optional&lt;Point&gt;(std::in_place, Point(1, 2)); // Noncompliant

  std::vector&lt;Point&gt; points;
  points.emplace_back(Point {1, 2}); // Noncompliant

  Point p {3, 4};
  points.emplace_back(p); // Noncompliant, since p is not used anywhere else
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_compliant_solution">Compliant solution</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">struct Point {
  Point(int x, int y);
  Point(std::string_view serialized);
};

void f() {
  auto p1 = std::make_unique&lt;Point&gt;(1, 2); // Compliant
  auto p2 = std::optional&lt;Point&gt;(std::in_place, 1, 2); // Compliant

  std::vector&lt;Point&gt; points;
  points.emplace_back(1, 2); // Compliant

  Point p {3, 4};
  points.emplace_back(p); // Compliant
  someFunction(p);

  auto buffer = "1,3";
  points.emplace_back(std::string_view{buffer, 3}) // Compliant, the constructed object is of a different type
}</code></pre>
</div>
</div>
</div>
</div>
</div>