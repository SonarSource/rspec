``++StringBuilder++`` instances that are never ``++ToString++``ed needlessly clutter the code, and worse are a drag on performance. Either they should be removed, or the missing ``++ToString++`` call added.

== Noncompliant Code Example

[source,csharp]
----
public void doSomething(List<string> strings) {
  StringBuilder sb = new StringBuilder();  // Noncompliant
  sb.Append("Got: ");
  foreach(string str in strings) {
    sb.Append(str).Append(", ");
    // ...
  }
}
----

== Compliant Solution

[source,csharp]
----
public void doSomething(List<string> strings) {
  foreach(string str in strings) {
    // ...
  }
}
----
or
[source,csharp]
----
public void doSomething(List<string> strings) {
  StringBuilder sb = new StringBuilder();  // Noncompliant
  sb.Append("Got: ");
  foreach(string str in strings) {
    sb.Append(str).Append(", ");
    // ...
  }
  _logger.LogInformation(sb.toString, DateTimeOffset.UtcNow);
}
----

== Exceptions

No issue is reported when ``++StringBuilder++`` is:

* passed as method arguments, on the grounds that it will likely ``++ToString++``ed there.
[source,csharp]
----
var sb = new StringBuilder(); // Compliant
ExternalMethod(sb);
----
* an argument of the current method
[source,csharp]
----
public void MyMethod(StringBuilder sb) // Compliant  
{
}
----
* retrieved by a custom function
[source,csharp]
----
var sb = GetStringBuilder(); // Compliant
----
* returned by the method
[source,csharp]
----
StringBuilder sb = new(); // Compliant
return sb;
----
* a local variable but the .ToString() call is unreachable
[source,csharp]
----
StringBuilder sb = new(); // Compliant
if (false)
{
    sb.ToString();
}
----
