:example_env: ACCESS_TOKEN
:example_name: authorization
:example_secret: Basic dXNlcjpwYXNzd29yZA==
:secret_type: authentication credentials

include::../../../shared_content/secrets/description.adoc[]

== Why is this an issue?

include::../../../shared_content/secrets/rationale.adoc[]

HTTP URLs may contain a userinfo component that defines credentials (username and optional password) for HTTP authentication. In URLs, this appears as an optional component between the schema (e.g., `https://`) and the host, separated by `@`, such as `http://user:password@host`.

For wire transfer, basic authentication credentials are combined with a colon, then the base64-encoded string is sent in the HTTP Authorization header:

[source,text]
----
GET / HTTP/1.1
Authorization: Basic aGVsbG86d29ybGQ=
----

When credentials are embedded in URLs or sent via basic authentication headers, they may be exposed through browser history, server logs, proxy caches, referrer headers, or network traffic interception.

=== What is the potential impact?

Below are some real-world scenarios that illustrate some impacts of an attacker exploiting the {secret_type}.

include::../../../shared_content/secrets/impact/data_compromise.adoc[]

==== Session hijacking and privilege escalation

If an attacker intercepts the HTTP authentication credentials, they can impersonate the authenticated user. This gives them unauthorized access to the user's account and potentially allows them to perform malicious actions, access sensitive data, or escalate privileges within the system.

Basic authentication does not provide any mechanism to protect against session hijacking attacks. Once intercepted, the credentials can be reused indefinitely until changed.

==== Brute-force attacks

Basic authentication typically lacks built-in protection against brute-force attacks. If credentials are exposed in logs or URLs, attackers can analyze them to understand password patterns and policies, making it easier to guess other credentials or launch targeted attacks.

== How to fix it

// 1. Revoke leaked secrets

include::../../../shared_content/secrets/fix/revoke.adoc[]

// 2. Analyze recent use to identify misuse

include::../../../shared_content/secrets/fix/recent_use.adoc[]

// 3. Use a secret vault in the future

include::../../../shared_content/secrets/fix/vault.adoc[]

**Use token-based authentication**

Use a token-based authentication mechanism like OAuth 2.0 or JWT instead of basic authentication. Tokens can be short-lived, have limited scopes, and can be revoked without changing the underlying user credentials.

**Always use HTTPS**

If basic authentication must be used, ensure all communications occur over HTTPS to encrypt credentials in transit. However, this does not protect against credentials being logged or stored in URLs.

// 4. Never hard-code secrets

include::../../../shared_content/secrets/fix/default.adoc[]

=== Code examples

include::../../../shared_content/secrets/examples.adoc[]

=== How does this work?

Token-based authentication provides several security advantages:

* **Limited lifetime**: Tokens can expire automatically, reducing the window of opportunity for attackers
* **Revocable**: Tokens can be revoked without changing user credentials
* **Limited scope**: Tokens can be restricted to specific resources or actions
* **No exposure risk**: Unlike URLs with embedded credentials, tokens are only sent in headers and never logged in browser history

== Resources

include::../../../shared_content/secrets/resources/standards.adoc[]

//=== Benchmarks
