== How to fix it in pyca

=== Code examples

The example uses a hardcoded IV as a nonce, which causes AES-CCM to be insecure. To fix it, a nonce is randomly generated instead.

==== Noncompliant code example

[source,python,diff-id=201,diff-type=noncompliant]
----
from cryptography.hazmat.primitives.ciphers.aead import AESGCM

def encrypt(key, plaintext):
    nonce = '7cVgr5cbdCZV'.encode('utf-8')
    cipher = AESGCM(key)

    cipher.encrypt(nonce, plaintext, None)  # Noncompliant
----

==== Compliant solution

[source,python,diff-id=201,diff-type=compliant]
----
from os import urandom
from cryptography.hazmat.primitives.ciphers.aead import AESGCM

def encrypt(key, plaintext):
    nonce = urandom(12)
    cipher = AESGCM(key)

    cipher.encrypt(nonce, plaintext, None)
----

=== How does this work?

When using AES-GCM or AES-CCM, NIST recommends a 96-bit length nonce using a deterministic approach or at least 96 bits using a 'Random Bit Generator (RBG)'.

include::../../common/fix/randomized-nonce.adoc[]

include::../../common/fix/deterministic-nonce.adoc[]
