This rule raises an issue when code uses Node.js APIs that have been officially deprecated and are scheduled for removal in future versions.

== Why is this an issue?

Using deprecated Node.js APIs creates several problems for your application:

**Future Compatibility**: Deprecated APIs will eventually be removed from Node.js, causing your application to break when upgrading to newer versions. This creates technical debt that must be addressed.

**Security and Performance**: Deprecated APIs are often replaced because they have security vulnerabilities, performance issues, or design flaws. Continuing to use them exposes your application to these problems.

**Maintenance Burden**: Code using deprecated APIs becomes harder to maintain as the Node.js ecosystem moves away from supporting these patterns. Finding documentation, examples, and community support becomes increasingly difficult.

**Warning Noise**: Deprecated APIs often generate runtime warnings that clutter logs and make it harder to identify real issues in production environments.

Node.js follows a structured deprecation process where APIs are marked as deprecated before being removed, giving developers time to migrate. However, this migration window is finite, and delaying the transition only makes it more difficult later.

=== What is the potential impact?

Applications using deprecated APIs face several risks:

* **Breaking Changes**: Future Node.js updates may completely remove deprecated APIs, causing runtime errors
* **Security Vulnerabilities**: Some deprecated APIs have known security issues that won't be patched
* **Performance Degradation**: Deprecated APIs may not benefit from performance improvements in newer Node.js versions
* **Maintenance Difficulties**: Finding support and documentation for deprecated APIs becomes increasingly challenging

=== How to fix?


Replace deprecated Buffer constructor with Buffer.from() or Buffer.alloc(). The old Buffer constructor is unsafe and can lead to security vulnerabilities.

==== Non-compliant code example

[source,javascript,diff-id=1,diff-type=noncompliant]
----
// Using deprecated Buffer constructor
const buf1 = new Buffer(10); // Noncompliant
const buf2 = Buffer("hello"); // Noncompliant
----

==== Compliant code example

[source,javascript,diff-id=1,diff-type=compliant]
----
// Use safe Buffer methods instead
const buf1 = Buffer.alloc(10); // Safe allocation
const buf2 = Buffer.from("hello"); // Safe string conversion
----

=== Documentation

 * Node.js Deprecation Guide - https://nodejs.org/api/deprecations.html[Official Node.js documentation listing all deprecated APIs and their alternatives]
 * Buffer Security Issues - https://nodejs.org/en/knowledge/advanced/buffers/how-to-use-buffers/[Explanation of Buffer security issues and safe alternatives]
 * ESLint Plugin Node.js - https://github.com/eslint-community/eslint-plugin-n[ESLint plugin for Node.js specific linting rules including deprecation detection]

=== Standards

 * CWE-477: Use of Obsolete Function - https://cwe.mitre.org/data/definitions/477.html[Using deprecated or obsolete functions can lead to security vulnerabilities]

=== Related Rules

 * RSPEC-1874 - https://rules.sonarsource.com/javascript/RSPEC-1874/[Deprecated code should not be used]

