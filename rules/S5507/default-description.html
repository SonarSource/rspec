<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>One way to end up with a dangling pointer or a dangling reference is to pass to a function a pointer or a reference which lifecycle is not controlled. This is the case when the pointer or the reference is obtained from a smart pointer (<code>shared_ptr</code> or <code>unique_ptr</code>) which is not locally defined or which is potentially aliased.</p>
</div>
<div class="paragraph">
<p>In this case, nothing can guarantee the developer that the pointer or the reference coming from this smart pointer will always be valid: for example, this smart pointer could be reset somewhere in the call chain.</p>
</div>
<div class="sect2">
<h3 id="_noncompliant_code_example">Noncompliant code example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">class Shape;

std::shared_ptr&lt;Shape&gt; globalShape;

void g(Shape&amp; s) {
  globalShape.reset();
  // do something with parameter s
}

void f1() {
  g(*globalShape); // Noncompliant, lifecycle of the reference is not controlled, parameter s of function g will be a dangling reference
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_compliant_solution">Compliant solution</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">class Shape;

std::shared_ptr&lt;Shape&gt; globalShape;

void g(Shape&amp; s) {
  globalShape.reset();
  // do something with parameter s
}

void f1() {
  auto myShape = globalShape; // reference count of the smart pointer is incremented, the pointer-to object is kept alive
  g(*myShape );
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>C++ Core Guidelines - <a href="https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#r37-do-not-pass-a-pointer-or-reference-obtained-from-an-aliased-smart-pointer">R.37: Do not pass a pointer or reference obtained from an aliased smart pointer</a></p>
</li>
</ul>
</div>
<hr>
</div>
</div>
<div class="sect1">
<h2 id="_implementation_specification">Implementation Specification</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_message">Message</h3>
<div class="paragraph">
<p>Make a copy of this "shared_pointer"; pointer/reference obtained from a global smart pointer may dangle.</p>
</div>
<div class="paragraph">
<p>Replace this pointer/reference obtained from a global smart pointer. It may dangle.</p>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_comments_and_links">Comments And Links</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_on_25_oct_2019_114756_loïc_joly_wrote">on 25 Oct 2019, 11:47:56 Loïc Joly wrote:</h3>
<div class="paragraph">
<p>\[~amelie.renard] Please review my changes</p>
</div>
</div>
</div>
</div>