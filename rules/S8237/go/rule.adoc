This rule raises an issue when a shared variable is modified using non-atomic operations like increment (`++`), decrement (`--`), or compound assignment operators (`+=`, `-=`) in code that may be accessed by multiple goroutines.

== Why is this an issue?

When multiple goroutines access and modify the same variable without proper synchronization, race conditions occur. These race conditions can lead to data corruption, incorrect values, and unpredictable behavior.

The problem happens because operations like `counter++` are not atomic at the CPU level. They actually consist of three separate steps: read the current value, increment it, and write it back. If multiple goroutines perform these steps simultaneously, they can interfere with each other.

For example, if two goroutines both read a counter value of 5, increment it to 6, and write it back, the final result will be 6 instead of the expected 7. In high-concurrency scenarios, this can result in significant data loss.

Go's `sync/atomic` package provides atomic operations that guarantee these read-modify-write operations happen as a single, indivisible step. This prevents race conditions and ensures data integrity without the overhead of mutexes.

=== What is the potential impact?

Race conditions in shared counters can cause:

* *Data corruption*: Lost increments or decrements leading to incorrect counts
* *Inconsistent application state*: Statistics, metrics, or business logic based on wrong values
* *Difficult debugging*: Race conditions are often intermittent and hard to reproduce
* *Production failures*: Critical counters (like request counts, error rates) may show incorrect values

These issues are particularly problematic in production environments with high concurrency, where the race conditions become more frequent and visible.

== How to fix it

Replace direct variable manipulation with atomic operations from the `sync/atomic` package. Use `atomic.AddInt64()` for increment/decrement operations and ensure your counter variable is of type `int64` or `uint64`.

=== Code examples

==== Noncompliant code example

[source,go,diff-id=1,diff-type=noncompliant]
----
var counter int

func incrementCounter() {
    counter++ // Noncompliant
}

func decrementCounter() {
    counter-- // Noncompliant
}

func addToCounter(value int) {
    counter += value // Noncompliant
}
----

==== Compliant solution

[source,go,diff-id=1,diff-type=compliant]
----
import "sync/atomic"

var counter int64

func incrementCounter() {
    atomic.AddInt64(&counter, 1)
}

func decrementCounter() {
    atomic.AddInt64(&counter, -1)
}

func addToCounter(value int64) {
    atomic.AddInt64(&counter, value)
}
----

== Resources

=== Documentation

 * Go sync/atomic package - https://pkg.go.dev/sync/atomic[Official documentation for Go's atomic operations package]

 * Go Memory Model - https://go.dev/ref/mem[Official Go memory model documentation explaining synchronization]

 * Effective Go - Concurrency - https://go.dev/doc/effective_go#concurrency[Best practices for concurrent programming in Go]

=== Standards

 * CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization - https://cwe.mitre.org/data/definitions/362.html[Race condition vulnerability classification]
