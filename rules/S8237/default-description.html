<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This rule raises an issue when a shared variable is modified using non-atomic operations like increment (<code>+`), decrement (`--`), or compound assignment operators (`=</code>, <code>-=</code>) in code that may be accessed by multiple goroutines.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When multiple goroutines access and modify the same variable without proper synchronization, race conditions occur. These race conditions can lead to data corruption, incorrect values, and unpredictable behavior.</p>
</div>
<div class="paragraph">
<p>The problem happens because operations like <code>counter++</code> are not atomic at the CPU level. They actually consist of three separate steps: read the current value, increment it, and write it back. If multiple goroutines perform these steps simultaneously, they can interfere with each other.</p>
</div>
<div class="paragraph">
<p>For example, if two goroutines both read a counter value of 5, increment it to 6, and write it back, the final result will be 6 instead of the expected 7. In high-concurrency scenarios, this can result in significant data loss.</p>
</div>
<div class="paragraph">
<p>Go&#8217;s <code>sync/atomic</code> package provides atomic operations that guarantee these read-modify-write operations happen as a single, indivisible step. This prevents race conditions and ensures data integrity without the overhead of mutexes.</p>
</div>
<div class="sect2">
<h3 id="_what_is_the_potential_impact">What is the potential impact?</h3>
<div class="paragraph">
<p>Race conditions in shared counters can cause:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Data corruption</strong>: Lost increments or decrements leading to incorrect counts</p>
</li>
<li>
<p><strong>Inconsistent application state</strong>: Statistics, metrics, or business logic based on wrong values</p>
</li>
<li>
<p><strong>Difficult debugging</strong>: Race conditions are often intermittent and hard to reproduce</p>
</li>
<li>
<p><strong>Production failures</strong>: Critical counters (like request counts, error rates) may show incorrect values</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These issues are particularly problematic in production environments with high concurrency, where the race conditions become more frequent and visible.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_fix_it">How to fix it</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Replace direct variable manipulation with atomic operations from the <code>sync/atomic</code> package. Use <code>atomic.AddInt64()</code> for increment/decrement operations and ensure your counter variable is of type <code>int64</code> or <code>uint64</code>.</p>
</div>
<div class="sect2">
<h3 id="_code_examples">Code examples</h3>
<div class="sect3">
<h4 id="_noncompliant_code_example">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-go" data-lang="go">var counter int

func incrementCounter() {
    counter++ // Noncompliant
}

func decrementCounter() {
    counter-- // Noncompliant
}

func addToCounter(value int) {
    counter += value // Noncompliant
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-go" data-lang="go">import "sync/atomic"

var counter int64

func incrementCounter() {
    atomic.AddInt64(&amp;counter, 1)
}

func decrementCounter() {
    atomic.AddInt64(&amp;counter, -1)
}

func addToCounter(value int64) {
    atomic.AddInt64(&amp;counter, value)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_documentation">Documentation</h3>
<div class="ulist">
<ul>
<li>
<p>Go sync/atomic package - <a href="https://pkg.go.dev/sync/atomic">Official documentation for Go&#8217;s atomic operations package</a></p>
</li>
<li>
<p>Go Memory Model - <a href="https://go.dev/ref/mem">Official Go memory model documentation explaining synchronization</a></p>
</li>
<li>
<p>Effective Go - Concurrency - <a href="https://go.dev/doc/effective_go#concurrency">Best practices for concurrent programming in Go</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_standards">Standards</h3>
<div class="ulist">
<ul>
<li>
<p>CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization - <a href="https://cwe.mitre.org/data/definitions/362.html">Race condition vulnerability classification</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>