== Why is this an issue?

Taking the address of an object of incomplete type, where the complete type contains a user declared ``++operator &++`` leads to undefined behavior.


=== Noncompliant code example

[source,cpp]
----
// A.h
class A
{
public:
  A * operator & ( ); // Noncompliant
};

// f1.cc
class A;
void f ( A & a )
{
  &a; // uses built-in operator &
}

// f2.cc
#include "A.h"
void f2 ( A & a )
{
  &a; // use user-defined operator &
}
----


== Resources

* MISRA {cpp} 2008, 5-3-3 - The unary & operator shall not be overloaded.
* {cpp} Core Guidelines - https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c166-overload-unary\--only-as-part-of-a-system-of-smart-pointers-and-references[C.166: Overload unary `&` only as part of a system of smart pointers and references]



ifdef::env-github,rspecator-view[]
'''
== Comments And Links
(visible only on this page)

=== on 31 Mar 2015, 19:04:52 Evgeny Mandrikov wrote:
\[~ann.campbell.2] implementation seems more complete (SQALE, description) than this spec.

=== on 13 Apr 2015, 19:33:09 Evgeny Mandrikov wrote:
\[~ann.campbell.2] I'm wondering why blocker, but not active by default? Note that in implementation currently major and active.

endif::env-github,rspecator-view[]
