== Why is this an issue?

The ``++%s++`` format specifier is used to read a string into a buffer.

By default, there is no restriction on the length of that string. The ``scanf`` family of functions will continue to read characters into the buffer until they find a whitespace character.

If the input contains a sufficiently long string with no whitespace characters, it can cause memory beyond the end of the buffer to be overwritten. This is a buffer overflow vulnerability.

=== What is the potential impact?

If the buffer is stored on the stack, the attacker can overwrite pieces of memory that control program flow. The attacker can exploit a technique called return-oriented programming to execute arbitrary code.

If the buffer is stored on the heap, the attacker can corrupt other memory on the heap. This allows the attacker to control the application's state, cause unexpected behavior, or cause the program to crash.

== How to fix it

A field width can be used together with the ``++%s++`` format specifier. This places a maximum limit on the number of characters that will be read into the buffer.

Note that the ``++%s++`` format specifier always null-terminates the string in the buffer. You will need to ensure that the buffer is large enough to hold the required input and the null terminator.

=== Code examples

==== Noncompliant code example

[source,C++,diff-id=1,diff-type=noncompliant]
----
char buffer[10];
scanf("%s", buffer);  // Noncompliant
----

If this code is given the word ``noncompliant`` as an input, ``noncomplia`` will be stored in ``buffer`` and ``nt␀`` will overwrite the contents of the memory immediately following ``buffer``.

==== Compliant solution

[source,C++,diff-id=1,diff-type=compliant]
----
char buffer[10];
scanf("%9s", buffer);
----

If this code is given the word ``noncompliant`` as an input, ``noncompli␀`` will be stored in ``buffer``.


== Resources

=== Articles & blog posts

* Wikipedia - https://en.wikipedia.org/wiki/Buffer_overflow[Buffer overflow]
* Wikipedia - https://en.wikipedia.org/wiki/Return-oriented_programming[Return-oriented programming]

=== Standards

* OWASP - https://owasp.org/www-project-top-ten/2017/A9_2017-Using_Components_with_Known_Vulnerabilities[Top 10 2017 Category A9 - Using Components with Known Vulnerabilities]
* MITRE - https://cwe.mitre.org/data/definitions/120[CWE-120 - Buffer Copy without Checking Size of Input] ('Classic Buffer Overflow')
* MITRE - https://cwe.mitre.org/data/definitions/676[CWE-676 - Use of Potentially Dangerous Function]


ifdef::env-github,rspecator-view[]

'''
== Implementation Specification
(visible only on this page)

=== Message

Add a field width specifier to this "%s" placeholder.


'''
== Comments And Links
(visible only on this page)

=== on 28 Aug 2013, 09:37:16 Dinesh Bolkensteyn wrote:
See \http://msdn.microsoft.com/en-us/library/xdb9w69d.aspx

=== on 29 Aug 2013, 06:38:19 Dinesh Bolkensteyn wrote:
perhaps we should also cover sscanf() and fscanf()

=== on 29 Aug 2013, 08:12:36 Dinesh Bolkensteyn wrote:
http://crasseux.com/books/ctutorial/String-overflows-with-scanf.html

=== on 29 Aug 2013, 09:37:41 Dinesh Bolkensteyn wrote:
Let's exclude sscanf() because the length of the string is known by the program, and is an upper bound for the size of the buffer required by %s.

=== on 3 Mar 2015, 09:49:30 Samuel Mercier wrote:
\[~ann.campbell.2] added reference to MITRE, CWE-676 for consistency with RSPEC-1081. Can you double check?

=== on 3 Mar 2015, 14:43:16 Samuel Mercier wrote:
Answer from Ann on hipchat on March 3rd, 2014, 14:31 looks good @SamuelMercier . Thx

endif::env-github,rspecator-view[]
