This is an issue when error conditions are handled by nesting the happy path inside if-else blocks instead of returning early on errors.

== Why is this an issue?

Nested error handling creates unnecessary complexity and reduces code readability. When functions handle the "happy path" inside nested if-else blocks that check for successful operations, the main logic becomes buried under multiple levels of indentation.

This pattern increases cognitive load for developers who need to mentally track multiple nesting levels to understand the code flow. The deeper the nesting, the harder it becomes to follow the primary logic of the function.

Go's idiomatic approach favors early returns on error conditions. This keeps the main logic flow at the top level of the function, making it easier to read and understand. The pattern also aligns with Go's explicit error handling philosophy, where errors are values that should be checked and handled promptly.

By handling errors first and returning immediately, you create a linear flow where each step in the happy path is clearly visible without nested conditions. This approach reduces the mental overhead required to understand the function's behavior.

=== What is the potential impact?

Code with nested error handling is harder to read, understand, and maintain. This increases the time developers need to comprehend the logic and makes the codebase more prone to bugs during modifications. The reduced readability can slow down code reviews and make debugging more difficult.

== How to fix it

Handle error conditions early in the function and return immediately. This keeps the happy path logic at the top level without nesting.

=== Code examples

==== Noncompliant code example

[source,go,diff-id=1,diff-type=noncompliant]
----
func (g *Gopher) WriteTo(w io.Writer) (size int64, err error) {
    err = binary.Write(w, binary.LittleEndian, int32(len(g.Name)))
    if err == nil { // Noncompliant
        size += 4
        var n int
        n, err = w.Write([]byte(g.Name))
        size += int64(n)
        if err == nil { // Noncompliant
            err = binary.Write(w, binary.LittleEndian, int64(g.AgeYears))
            if err == nil { // Noncompliant
                size += 4
            }
            return
        }
        return
    }
    return
}
----

==== Compliant solution

[source,go,diff-id=1,diff-type=compliant]
----
func (g *Gopher) WriteTo(w io.Writer) (size int64, err error) {
    err = binary.Write(w, binary.LittleEndian, int32(len(g.Name)))
    if err != nil {
        return
    }
    size += 4
    n, err := w.Write([]byte(g.Name))
    size += int64(n)
    if err != nil {
        return
    }
    err = binary.Write(w, binary.LittleEndian, int64(g.AgeYears))
    if err == nil {
        size += 4
    }
    return
}
----

== Resources

=== Documentation

 * Go Best Practices - Avoid nesting by handling errors first - https://go.dev/talks/2013/bestpractices.slide#1[Official Go presentation on best practices including error handling patterns]

 * Effective Go - Error handling - https://go.dev/doc/effective_go#errors[Official Go documentation on idiomatic error handling]
