== Why is this an issue?

The rules for method resolution can be complex and may not be fully understood by all developers.
The situation becomes even more challenging when dealing with method overloads that have optional parameter values.
 
This rule raises an issue when an overload with default parameter values is hidden by another overload that does not have the optional parameters.

=== Noncompliant code example

[source,csharp,diff-id=1,diff-type=noncompliant]
----
MyClass.Print(1);  // which overload of Print will be called?

public static class MyClass
{
  public static void Print(int number) { } 
  public static void Print(int number, string delimiter = "\n") { } // Noncompliant, default parameter value is hidden by overload
}
----

In this example, the Print method is overloaded with two versions, where the first one hides the second one. 
This can lead to confusion and uncertainty about which overload of the method will be invoked when calling it.

[source,csharp,diff-id=1,diff-type=compliant]
----
MyClass.PrintWithDelimiter(1);

public static class MyClass
{
  public static void Print(int number) { } 
  public static void PrintWithDelimiter(int number, string delimiter = "\n") { } // Compliant
}
----

== Resources

=== Documentation

* https://learn.microsoft.com/en-us/dotnet/standard/design-guidelines/member-overloading[Member overloading]
* https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/named-and-optional-arguments#optional-arguments[Optional arguments]