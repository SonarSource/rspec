== Why is this an issue?

In property and indexer ``++set++`` methods, and in event ``++add++`` and ``++remove++`` methods, the implicit ``++value++`` parameter holds the value the accessor was called with. Not using the ``++value++`` means that the accessor ignores the caller's intent which could cause unexpected results at runtime.


=== Noncompliant code example

[source,csharp]
----
private int count;
public int Count
{
  get { return count; }
  set { count = 42; } // Noncompliant 
}
----


=== Compliant solution

[source,csharp]
----
private int count;
public int Count
{
  get { return count; }
  set { count = value; }
}
----

or


[source,csharp]
----
public int Count
{
  get { return count; }
  set { throw new InvalidOperationException(); }
}
----


=== Exceptions

This rule doesn't raise an issue when the setter is empty and part of the implementation of an ``++interface++`` . The assumption is that this part of the interface is not meaningful to that particular implementation. A good example of that would be a "sink" logger that discards any logs.


ifdef::env-github,rspecator-view[]

'''
== Implementation Specification
(visible only on this page)

=== Message

Use the "value" parameter in this [property set|indexer set|event] accessor.


'''
== Comments And Links
(visible only on this page)

=== on 8 Jul 2015, 13:51:34 Ann Campbell wrote:
\[~tamas.vajk] 10min seems like a high remediation cost. Does that mean that the Compliant Solution I added is off-base?

=== on 20 Jul 2015, 11:59:05 Tamas Vajk wrote:
\[~ann.campbell.2] We can reduce the required time.

=== on 20 Jul 2015, 13:53:16 Ann Campbell wrote:
I halved it to 5min, [~tamas.vajk]

=== on 27 Jul 2015, 15:39:03 Ann Campbell wrote:
\[~dinesh.bolkensteyn] note that I've edited the first line. Your version, "a property and indexer ``++set++`` method" speaks of one, collective method for both a property and an indexer at one time.

=== on 27 Jul 2015, 15:44:58 Dinesh Bolkensteyn wrote:
thanks [~ann.campbell.2]

endif::env-github,rspecator-view[]
