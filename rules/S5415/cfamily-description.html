<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When calling <code>std::move</code> on an object, we usually expect the resulting operation to be fast, using move semantic to rip data off the source object. If, despite the call to <code>std::move</code>, the source object ends up being copied, the code might be unexpectedly slow.</p>
</div>
<div class="paragraph">
<p>This can happen:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When <code>std::move</code> is called on an object which does not provide a specific move constructor and will resort to copying when requested to move.</p>
</li>
<li>
<p>When calling <code>std::move</code> with a const argument.</p>
</li>
<li>
<p>When passing the result of <code>std::move</code> as a const reference argument. In this case, no object will be moved since it&#8217;s impossible to call the move constructor from within the function. <code>std::move</code> should only be used when the argument is passed by value or by r-value reference.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_noncompliant_code_example">Noncompliant code example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">struct MoveWillCopy{
  MoveWillCopy() = default;
  // This user-provided copy constructor prevents the automatic generation of a move constructor
  MoveWillCopy(NonMovable&amp;) = default;
  Data d;
};

void f(MoveWillCopy m);
void f(std::string s);
void g(const std::string &amp;s);

void test() {
  MoveWillCopy m;
  f(std::move(m)); // Noncompliant: std::move is useless on objects like m: Any attempt to move it will copy it

  const std::string constS="***";
  f(std::move(constS)); // Noncompliant: constS will not be moved

  std::string s="****";
  g(std::move(s)); // Noncompliant: s is cast back to const l-value reference. g cannot move from it


}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_compliant_solution">Compliant solution</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">struct Movable{
  Movable() = default;
  // A move constructor is generated by default
  Data d;
};

void f(Movable m);
void f(std::string s);
void g(const std::string &amp;s);

void test() {
  Movables m;
  f(std::move(m)); // Compliant: move constructor is available

  std::string s="****";
  f(std::move(s)); // Compliant:  move constructor is called

  g(s); // Compliant: no misleading std::move is used
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>C++ Core Guidelines - <a href="https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es56-write-stdmove-only-when-you-need-to-explicitly-move-an-object-to-another-scope">ES.56: Write <code>std::move()</code> only when you need to explicitly move an object to another scope</a></p>
</li>
</ul>
</div>
<hr>
</div>
</div>
<div class="sect1">
<h2 id="_comments_and_links">Comments And Links</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_relates_to_s5272">relates to: <a data-rspec-id="S5272" class="rspec-auto-link">S5272</a></h3>

</div>
<div class="sect2">
<h3 id="_relates_to_s5274">relates to: <a data-rspec-id="S5274" class="rspec-auto-link">S5274</a></h3>

</div>
<div class="sect2">
<h3 id="_on_31_jul_2020_002927_loïc_joly_wrote">on 31 Jul 2020, 00:29:27 Loïc Joly wrote:</h3>
<div class="paragraph">
<p>\[~abbas.sabra]: What do you plan to do inside templates? I think I would totally ignore this rule for dependant arguments, because it might be instantiated with types for which it makes sense&#8230;&#8203; (unless for instance if the const is not deduced, but is part of the template)</p>
</div>
</div>
<div class="sect2">
<h3 id="_on_31_jul_2020_004621_abbas_sabra_wrote">on 31 Jul 2020, 00:46:21 Abbas Sabra wrote:</h3>
<div class="paragraph">
<p>\[~loic.joly] I ignore instantiation and I analyze the main template. If an issue can be detected in the main template, it means that calling std::move is going to be useless in all instantiation and should be removed.</p>
</div>
</div>
</div>
</div>