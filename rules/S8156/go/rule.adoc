This rule raises an issue when types use complex embedding patterns or create deep interface hierarchies that could be simplified through composition.

== Why is this an issue?

Go encourages composition over inheritance, and complex type hierarchies can make code harder to understand, test, and maintain.

When you create types with multiple embedded types or deep interface chains, you're mixing concerns and creating tight coupling. This makes it difficult to:

* Test individual components in isolation
* Understand the flow of data and control
* Modify or extend functionality without affecting other parts
* Reason about the behavior of your code

Complex hierarchies often indicate that a single type is trying to do too much. In Go, it's better to create focused types that do one thing well and compose them together when needed.

Composition makes your code more modular. Each component has a clear responsibility, and you can easily swap out implementations or test components independently. This aligns with Go's philosophy of simplicity and explicit behavior.

=== What is the potential impact?

Complex inheritance hierarchies reduce code maintainability and testability. They create tight coupling between components, making it harder to modify or extend functionality. This can lead to bugs when changes in one part unexpectedly affect other parts of the system.

== How to fix it

Replace complex embedded type hierarchies with simple composition. Create focused types that wrap the functionality you need rather than embedding multiple types.

=== Code examples

==== Noncompliant code example

[source,go,diff-id=1,diff-type=noncompliant]
----
type ComplexReader struct {
    *os.File           // Noncompliant
    *bufio.Reader      // Noncompliant
    *compress.Reader   // Noncompliant
    customLogic bool
}

func (c *ComplexReader) Read(p []byte) (int, error) {
    // Complex implementation mixing multiple concerns
    return 0, nil
}
----

==== Compliant solution

[source,go,diff-id=1,diff-type=compliant]
----
type SimpleReader struct {
    source io.Reader  // Compose with interface
    buffer []byte
}

func (s *SimpleReader) Read(p []byte) (int, error) {
    // Simple, focused implementation
    return s.source.Read(p)
}

// Create the reader with composition
func NewReader(file *os.File) *SimpleReader {
    buffered := bufio.NewReader(file)
    compressed := compress.NewReader(buffered)
    return &SimpleReader{source: compressed}
}
----

== Resources

=== Documentation

 * Go Blog: GIF Decoder Exercise - https://go.dev/blog/gif-decoder-exercise-in-go-interfaces[Demonstrates how to use composition with interfaces to build modular, testable code]

 * Effective Go: Embedding - https://go.dev/doc/effective_go#embedding[Official guidance on when and how to use embedding in Go]

 * Go Blog: Go's Declaration Syntax - https://go.dev/blog/declaration-syntax[Explains Go's design philosophy around simplicity and composition]

=== Related rules

 * S110 - https://rules.sonarsource.com/java/RSPEC-110/[Inheritance tree of classes should not be too deep (Java)]
