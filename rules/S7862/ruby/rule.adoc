This rule raises an issue when you use class-level update methods like `Model.update(id, attributes)` while you already have an instance of that model available.

== Why is this an issue?

When you use class-level update methods like `User.update(user.id, attributes)`, Rails creates a new instance of the model to perform the update. This means your existing instance variable remains unchanged in memory, even though the database record is updated successfully.

This behavior can lead to subtle bugs where your code continues to work with stale data. For example, if you check the updated attributes on your original instance after the class-level update, you'll see the old values, not the new ones from the database.

Instance-level methods like `user.update(attributes)` update both the database record and the in-memory object, ensuring consistency between what's stored and what your code is working with.

Using instance methods when you already have an instance also makes your code more readable and expresses your intent more clearly - you want to update this specific object, not just any record with this ID.

=== What is the potential impact?

This issue can cause bugs where your application logic operates on outdated data, leading to incorrect behavior, inconsistent user interfaces, or failed validations that should have passed. While the database is updated correctly, any subsequent operations on the original instance will use stale data.

== How to fix it in Rails

Replace the class-level update method with the instance-level update method. This ensures both the database and your in-memory object are updated consistently.

=== Code examples

==== Noncompliant code example

[source,ruby,diff-id=1,diff-type=noncompliant]
----
def update_profile
  @user = User.find(params[:id])
  User.update(@user.id, user_params) # Noncompliant
  # @user still has old values in memory
  redirect_to @user
end
----

==== Compliant solution

[source,ruby,diff-id=1,diff-type=compliant]
----
def update_profile
  @user = User.find(params[:id])
  @user.update(user_params)
  # @user now reflects the updated values
  redirect_to @user
end
----

When working with multiple attributes or complex updates, the instance method still provides the same benefits of keeping your object in sync with the database.

=== Code examples

==== Noncompliant code example

[source,ruby,diff-id=2,diff-type=noncompliant]
----
user = User.find(id)
User.update(user.id, { # Noncompliant
  name: new_name,
  email: new_email,
  updated_at: Time.current
})
user.name # Still has the old name
----

==== Compliant solution

[source,ruby,diff-id=2,diff-type=compliant]
----
user = User.find(id)
user.update({
  name: new_name,
  email: new_email,
  updated_at: Time.current
})
user.name # Now has the new name
----

== Resources

=== Documentation

 * Rails Active Record Persistence - https://api.rubyonrails.org/classes/ActiveRecord/Persistence.html#method-i-update[Official Rails documentation for instance-level update methods]

 * Rails Active Record Persistence Class Methods - https://api.rubyonrails.org/classes/ActiveRecord/Persistence/ClassMethods.html#method-i-update[Official Rails documentation for class-level update methods]
