<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The main aim of this rule is clarity for maintainers and reviewers, by ensuring that the version of a function that can be executed from any point in a class hierarchy is unambiguous.</p>
</div>
<div class="paragraph">
<p>Additionally, where classes form a diamond hierarchy, call by dominance ([1] ยง10.3(11)) may occur resulting in a call to a function that is inconsistent with developer expectations. This rule also prevents call by dominance.</p>
</div>
<div class="sect2">
<h3 id="_noncompliant_code_example">Noncompliant code example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">class A
{
public:
  virtual void f1 ( ) = 0; // f1 is pure
  virtual void f2 ( ) = 0; // f2 is pure
  virtual void f3 ( ) { } // f3 is not pure
  virtual void f4 ( ) = 0; // f4 is pure
  virtual ~A(); // destructor
};

// A::f1 is both pure and has a definition
void A::f1 ( ) { }

// A::f4 is both pure and has a definition
void A::f4 ( ) { }

class B : public A
{
public:
  virtual void f2 ( ) { } // Compliant: f2 pure in A and defined in B
  virtual void f3 ( ) { } // Noncompliant: f3 defined in A and B
  virtual void f4 ( ) = 0; // Compliant: f4 is pure in A and in B
  virtual ~B(); // Compliant: destructor
};

// Compliant by Exception - f4 defined in A but also declared pure in A
void B::f4 ( ) { }

class C : public B
{
public:
  virtual void f1 ( ) { } // Compliant: f1 defined in A and C
  // but was pure in A
  virtual void f2 ( ) { } // Noncompliant f2: defined in B and C
  // and not declared pure in B
  virtual void f4 ( ) { } // Compliant by Exception: f4 defined in A and B but also declared pure in A and B
};

class D : public C
{
public:
  virtual void f1 ( ) { } // Noncompliant f1: defined in C and D as well as A
  virtual ~D(); // Compliant: destructor
};



// Call by dominance example
class V
{
public:
  virtual void foo ( ) { }
};

class B1 : public virtual V
{
public:
  virtual void foo ( ) { } // Noncompliant
};

class B2 : public virtual V
{
public:
  void f1 ( )
  {
    foo(); // V::foo would appear to be the only candidate to be called here
  }
};

class D : public B1, public B2
{
public:
  void f2 ( )
  {
    f1();
  }
};

B2 b2;
b2.f1(); // calls V::foo by normal inheritance rules

D d;
d.f2(); // calls B2::f1 which now calls B1::foo "by dominance"
d.f1(); // also calls B1::foo "by dominance"</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>MISRA C&#43;&#43;:2008, 10-3-1 - There shall be no more than one definition of each virtual function on each path through the inheritance hierarchy.</p>
</li>
</ul>
</div>
<hr>
</div>
</div>
<div class="sect1">
<h2 id="_implementation_specification">Implementation Specification</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_message">Message</h3>
<div class="paragraph">
<p>This definition of virtual function "xxx" clashes with an existing definition in class "yyy".</p>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_comments_and_links">Comments And Links</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_is_related_to_s1014">is related to: <a data-rspec-id="S1014" class="rspec-auto-link">S1014</a></h3>

</div>
<div class="sect2">
<h3 id="_relates_to_s1017">relates to: <a data-rspec-id="S1017" class="rspec-auto-link">S1017</a></h3>

</div>
</div>
</div>