<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>std::variant</code> is a type-safe union that can hold values of a type out of a fixed list of types.</p>
</div>
<div class="paragraph">
<p>Depending on the current alternative inside a <code>variant</code>, it is common to execute dedicated code. There are basically two ways to achieve that:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Writing code that checks the current alternative, then getting it and running specific code</p>
</li>
<li>
<p>Letting <code>std::visit</code> perform the check and select the code to run by using overload resolution with the different alternatives</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The second option is usually preferable:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It requires less boilerplate code.</p>
</li>
<li>
<p>It is easy to handle multiple similar alternatives together if desired.</p>
</li>
<li>
<p>It is usually more robust: if a new alternative is added to the variant, but the visitor does not support it, it will not compile.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This rule raises an issue when <code>variant::index</code> is called, or when <code>variant::holds_alternative</code> or <code>variant::get_if</code> is used in a series of <code>if</code> - <code>else if</code> (calling one of these functions in isolation can be an acceptable lightweight alternative to <code>std::visit</code> in some cases).</p>
</div>
<div class="paragraph">
<p>Note: When defining the visitor of a variant, it can be nicer to use a series of lambdas by making use of <a href="https://www.bfilipek.com/2019/02/2lines3featuresoverload.html">the <em>overloaded</em> pattern</a></p>
</div>
<div class="sect2">
<h3 id="_noncompliant_code_example">Noncompliant code example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">using Variant = std::variant&lt;int, float, string&gt;;
void printType1(Variant const &amp;v) {
    switch(v.index()) { // Noncompliant
        case 0: cout &lt;&lt; "int " &lt;&lt;get&lt;int&gt;(v) &lt;&lt; "\n"; break;
        case 1: cout &lt;&lt; "float " &lt;&lt;get&lt;float&gt;(v) &lt;&lt; "\n"; break;
        case 2: cout &lt;&lt; "string " &lt;&lt;get&lt;string&gt;(v) &lt;&lt; "\n";break;
    }
}
void printType2(Variant const &amp;v) {
    if(auto p = get_if&lt;int&gt;(&amp;v)) { // Noncompliant
        cout &lt;&lt; "int " &lt;&lt; *p &lt;&lt; "\n";
    } else if (auto p = get_if&lt;float&gt;(&amp;v)) {
        cout &lt;&lt; "float " &lt;&lt; *p &lt;&lt; "\n";
    } else if (auto p = get_if&lt;string&gt;(&amp;v)) {
        cout &lt;&lt; "string " &lt;&lt; *p &lt;&lt; "\n";
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_compliant_solution">Compliant solution</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">using Variant = std::variant&lt;int, float, string&gt;;

struct VariantPrinter {
    void operator() (int i) { cout &lt;&lt; "int " &lt;&lt; i &lt;&lt; "\n"; }
    void operator() (float f) { cout &lt;&lt; "float " &lt;&lt; f &lt;&lt; "\n"; }
    void operator() (std::string const &amp;s) { cout &lt;&lt; "string " &lt;&lt; s &lt;&lt; "\n"; }
};

void printType3(Variant const &amp;v) {
    std::visit(VariantPrinter{}, v);
}

// Same principle, but using the overloaded pattern
void printType4(Variant const &amp;v) {
    std::visit(overloaded{
        [](int i){cout &lt;&lt; "int " &lt;&lt; i &lt;&lt; "\n";},
        [](float f){cout &lt;&lt; "float " &lt;&lt; f &lt;&lt; "\n";},
        [](std::string const &amp;s){cout &lt;&lt; "string " &lt;&lt; s &lt;&lt; "\n";}
    }, v);
}</code></pre>
</div>
</div>
</div>
</div>
</div>