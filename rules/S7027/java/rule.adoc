== Why is this an issue?

Circular dependencies happen when two classes, directly or indirectly, reference each other in their definitions.

This cyclical relationship means class boundaries cannot be expressed as an intuitive hierarchy. This degrades your codeâ€™s structure and makes it harder to manage and extend over time.

These dependencies can lead to unexpected behavior, which complicates debugging, and makes your code more error-prone.

=== What is the potential impact?

Circular dependencies complicate code maintenance, making it difficult to change one class without inadvertently affecting others and increasing the risk of defects.

In some cases, they can even prevent your code from compiling or cause runtime failures. As your project grows, these cycles become harder to untangle, further degrading the codebase and increasing technical debt.

This structural issue can significantly hinder your ability to adapt and improve the code in the future.

== How to fix it

1. Extract an interface: If two classes share similar functionality, move that functionality to an interface that both can implement. This allows each class to depend on the interface rather than on each other.

2. Use dependency injection: Replace direct references between classes with dependency injection. By passing necessary objects as parameters through constructors or setters, you break the circular reference, making your code more flexible and easier to test.

3. Split responsibilities: Evaluate whether each class is handling too many responsibilities. If so, break them down into smaller, more focused classes. This not only eliminates circular dependencies but makes sure your code has fewer reasons to change, making it easier to manage and extend.

=== Code examples

==== Noncompliant code example

The following code contains two cycles: Order &rarr; Customer &rarr; Order, and Order &rarr; Product &rarr; Order. Furthermore, both cycles are connected to each other via class Order. This is called _a tangle consisting of two cycles_.

[source,java,diff-id=1,diff-type=noncompliant]
----
class Order {
    public Customer customer;
    public List<Product> products;
}
class Customer {
    public List<Order> orders;
}
class Product {
    public List<Order> orders;
}
----

==== Compliant solution

The issue can be resolved by changing the structure. Two service functions can replace the dependencies Customer &rarr; Order and Product &rarr; Order.

[source,java,diff-id=1,diff-type=compliant]
----
class Order {
    public Customer customer;
    public List<Product> products;
}
class Customer { }
class Product { }
interface OrderService {
  List<Order> getOrdersByCustomer(Customer customer);
  List<Order> getOrdersByProduct(Product product);
}
----

== Resources

- Wikipedia - https://en.wikipedia.org/wiki/Acyclic_dependencies_principle[Acyclic dependencies principle]
- STAN - https://stan4j.com/advanced/adp/[Acyclic dependencies principle]
