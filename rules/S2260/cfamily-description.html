<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When the analysis succeeds, it doesn&#8217;t mean that the analyzer was able to understand all the analyzed code. If the analyzer fails to parse some parts of your code, it will ignore them during the analysis. This rule will help you track these parsing failures.</p>
</div>
<div class="paragraph">
<p>There are many reasons why parsing failures can happen, here are the common ones:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Compiler extensions: Your compiler might allow you to write code that isn&#8217;t standard-conforming.</p>
</li>
<li>
<p>Bad analysis environment. This usually means that the environment during the build is different than the one during the analysis. For example, files or symbolic links that were available during the build are not available during the analysis.</p>
</li>
<li>
<p>Use of new language features that are not yet supported by our analyzer.</p>
</li>
<li>
<p>Limitation in our analyzer. We are always working on improving this.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>How do they impact analysis? We cannot judge without looking at specific examples, as they contain a broad range of types of errors. On our side, we will make sure that you get notified through the analysis logs when they have an impact on the quality of the analysis.</p>
</div>
<div class="paragraph">
<p>There are three recommended ways to deal with parsing failures:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Fix them when it is possible. It should be obvious from the message if you can do it. For example, by replacing the use of a compiler extension with the standard-conforming equivalent.</p>
</li>
<li>
<p>If you cannot fix them and the analysis logs state that they have a bad impact on the analysis results, Report them.</p>
</li>
<li>
<p>If you cannot fix them and the analysis logs donâ€™t state anything explicit about their impact, ignore them by resolving them as "won&#8217;t fix".</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_noncompliant_code_example">Noncompliant code example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">// This example uses Microsoft extension /Zc:referenceBinding that allows binding r-value to l-value. Even though your compiler might allow it, our analyzer will flag it

struct S {
...
};

void f(S&amp;) {
...
}

int main() {
  f(S{}); // Noncompliant: no matching function for call to 'f'
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_compliant_solution">Compliant solution</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">// Here we are showing how to fix the issue by replacing the code relying on a compiler extension by standard-conforming equivalent

struct S {
...
};

void f(S&amp;&amp;) { // Using C++11 r-value reference fixes the issue
...
}

int main() {
  f(S{}); // Compliant
}</code></pre>
</div>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_implementation_specification">Implementation Specification</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_message">Message</h3>
<div class="paragraph">
<p>A parsing error occurred in this file.</p>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_comments_and_links">Comments And Links</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_is_duplicated_by_s129">is duplicated by: <a data-rspec-id="S129" class="rspec-auto-link">S129</a></h3>

</div>
<div class="sect2">
<h3 id="_on_14_sep_2018_003601_tim_spriggs_wrote">on 14 Sep 2018, 00:36:01 Tim Spriggs wrote:</h3>
<div class="paragraph">
<p>Today, files that are not parsable by SonarQube are completely passed in the analysis phase (eg: Java.) This means that potentially bad content can seep in where SQ is being used as a Pull Request filter. It would be nice if the SonarQube system as a whole had a good answer to this. Today, work-arounds have been made for individual languages (eg: xml) which end up attempting to parse a file up to three times before an issue is raised and reported. All of these work-arounds are somewhat hackish in nature.</p>
</div>
<div class="paragraph">
<p>The parse phase really needs to be able to directly report lex/parse issues.</p>
</div>
</div>
<div class="sect2">
<h3 id="_on_14_sep_2018_133434_ann_campbell_wrote">on 14 Sep 2018, 13:34:34 Ann Campbell wrote:</h3>
<div class="paragraph">
<p>\[~imoverclocked] I can see the connection you made between your issue and this rule, but this really isn&#8217;t the place for this discussion. Please start a new thread at https://community.sonarsource.com.</p>
</div>
</div>
</div>
</div>