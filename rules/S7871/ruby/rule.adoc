This is an issue when using `Array#include?` for frequent membership testing, using Hash with nil values for membership operations, or combining `Array#include?` with `Array#push` for uniqueness checks.

== Why is this an issue?

Using `Array#include?` for membership testing has O(n) time complexity because it must scan through the entire array to find an element. This becomes a significant performance bottleneck when dealing with large collections or frequent lookups.

When you combine `Array#include?` with `Array#push` to maintain unique elements, each insertion requires checking the entire array first. In loops, this creates O(n²) complexity, where performance degrades quadratically as the collection grows.

Using Hash with nil values for membership testing works efficiently (O(1) lookup), but it's semantically confusing. The code doesn't clearly express that you're testing membership - it looks like you're storing key-value pairs when you only care about the keys.

Ruby's Set class is specifically designed for these use cases. It provides O(1) lookup time for membership testing and automatically handles uniqueness. The code becomes both more efficient and more expressive of your intent.

=== What is the potential impact?

Performance can degrade significantly with large collections. Array membership testing scales linearly (O(n)), while uniqueness patterns with arrays can scale quadratically (O(n²)). This can cause noticeable slowdowns in applications processing large datasets or performing frequent membership checks.

Using Hash with nil values creates maintenance overhead because the code's intent is unclear to other developers.

== How to fix it

Replace Array#include? with Set for membership testing. Convert your array to a Set using `to_set` method and use the same `include?` method for O(1) lookup performance.

=== Code examples

==== Noncompliant code example

[source,ruby,diff-id=1,diff-type=noncompliant]
----
# Inefficient: O(n) lookup for membership testing
valid_ids = [1, 2, 3, 4, 5]

def process_item(item_id, valid_ids)
  return unless valid_ids.include?(item_id)  # Noncompliant
  # Process the item
end
----

==== Compliant solution

[source,ruby,diff-id=1,diff-type=compliant]
----
require 'set'

# Efficient: O(1) lookup for membership testing
valid_ids = [1, 2, 3, 4, 5].to_set

def process_item(item_id, valid_ids)
  return unless valid_ids.include?(item_id)  # O(1) lookup
  # Process the item
end
----

== Resources

=== Documentation

 * Ruby Set Class Documentation - https://ruby-doc.org/stdlib/libdoc/set/rdoc/Set.html[Official Ruby documentation for the Set class, including methods and usage examples]

 * Ruby Array Documentation - https://ruby-doc.org/core/Array.html#method-i-include-3F[Official documentation for Array#include? method and its time complexity characteristics]
