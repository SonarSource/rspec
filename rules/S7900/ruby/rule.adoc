This is an issue when Active Record persistence methods like `save`, `create`, `update`, or `destroy` are called without using the exception-raising bang variants or without handling their return values.

== Why is this an issue?

Active Record persistence methods return boolean values to indicate success or failure. When these return values are ignored, validation errors and other persistence failures can occur silently, leading to data integrity issues and difficult-to-debug problems.

For example, if `user.save` fails due to validation errors, the method returns `false`, but the failure goes unnoticed if the return value isn't checked. This can result in:

* Data not being persisted when expected
* Silent failures that are hard to track down
* Inconsistent application state
* Poor user experience when operations appear successful but actually fail

The bang methods (`save!`, `create!`, etc.) raise exceptions when persistence fails, making errors immediately visible. Alternatively, explicitly checking return values allows for proper error handling and user feedback.

=== What is the potential impact?

Silent persistence failures can lead to data loss, inconsistent application state, and poor user experience. Users may believe their data was saved when it wasn't, leading to frustration and potential business impact. These issues are often difficult to debug because the failures occur silently without any indication of what went wrong.

== How to fix it in Rails

Use the exception-raising bang method instead of the regular method. This will raise an exception if the operation fails, making the error immediately visible.

=== Code examples

==== Noncompliant code example

[source,ruby,diff-id=1,diff-type=noncompliant]
----
user = User.new(name: 'John')
user.save # Noncompliant
----

==== Compliant solution

[source,ruby,diff-id=1,diff-type=compliant]
----
user = User.new(name: 'John')
user.save!
----

Handle the return value of the persistence method explicitly. Check if the operation succeeded and handle failures appropriately.

=== Code examples

==== Noncompliant code example

[source,ruby,diff-id=2,diff-type=noncompliant]
----
user = User.new(name: 'John')
user.save # Noncompliant
----

==== Compliant solution

[source,ruby,diff-id=2,diff-type=compliant]
----
user = User.new(name: 'John')
if user.save
  # Handle success
  redirect_to user_path(user)
else
  # Handle failure
  render :new
end
----

The same principle applies to other persistence methods like `create`, `update`, and `destroy`. Use bang methods or handle return values.

=== Code examples

==== Noncompliant code example

[source,ruby,diff-id=3,diff-type=noncompliant]
----
User.create(name: 'John') # Noncompliant
user.update(email: 'new@example.com') # Noncompliant
----

==== Compliant solution

[source,ruby,diff-id=3,diff-type=compliant]
----
User.create!(name: 'John')
# or
user = User.create(name: 'John')
if user.persisted?
  # Handle success
else
  # Handle failure
end
----

== Resources

=== Documentation

 * Rails Style Guide - save! - https://rails.rubystyle.guide/#save-bang[Official Rails Style Guide recommendation for using bang methods]

 * Active Record Validations and Callbacks - https://guides.rubyonrails.org/active_record_validations.html[Rails guide explaining validation and persistence behavior]
