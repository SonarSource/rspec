This rule raises an issue when Angular lifecycle methods are implemented in classes where they won't be called by the framework.

== Why is this an issue?

Angular lifecycle methods are only called by the framework in specific contexts. Each decorator type (@Component, @Directive, @Injectable, @NgModule, @Pipe) supports different lifecycle methods.

Using lifecycle methods in the wrong context creates several problems:

* The methods will never be called by Angular, making the code ineffective
* It misleads other developers about when the code will execute
* It can indicate a misunderstanding of Angular's architecture
* It adds unnecessary code that serves no purpose

For example, view-related lifecycle methods like `ngAfterViewInit` only work in Components and Directives that have templates. Using them in Services or Pipes is meaningless since these don't have views.

=== What is the potential impact?

The code will not behave as expected since the lifecycle methods won't be called. This can lead to initialization logic not running, cleanup not happening, or change detection not working properly. It may also confuse team members about the application's behavior.

=== How to fix in Angular?

Remove lifecycle methods that are not supported in the current context, or move the logic to an appropriate lifecycle method or initialization pattern.

==== Non-compliant code example

[source,typescript,diff-id=1,diff-type=noncompliant]
----
@Injectable()
class UserService {
  ngOnInit() { // Noncompliant - Services don't support ngOnInit
    this.loadUsers();
  }
  
  ngAfterViewInit() { // Noncompliant - Services don't have views
    console.log('View initialized');
  }
}
----

==== Compliant code example

[source,typescript,diff-id=1,diff-type=compliant]
----
@Injectable()
class UserService {
  constructor() {
    this.loadUsers(); // Use constructor for initialization
  }
  
  ngOnDestroy() { // Only ngOnDestroy is supported in services
    this.cleanup();
  }
}
----

Use ngDoBootstrap only in NgModule classes, not in Components or other contexts.

==== Non-compliant code example

[source,typescript,diff-id=2,diff-type=noncompliant]
----
@Component({
  selector: 'app-root',
  template: '<div>App</div>'
})
class AppComponent {
  ngDoBootstrap() { // Noncompliant - Components don't support ngDoBootstrap
    console.log('Bootstrapping');
  }
}
----

==== Compliant code example

[source,typescript,diff-id=2,diff-type=compliant]
----
@NgModule({
  declarations: [AppComponent],
  imports: [BrowserModule]
})
class AppModule {
  ngDoBootstrap() { // Correct - NgModules support ngDoBootstrap
    console.log('Bootstrapping');
  }
}
----

=== Documentation

* https://github.com/angular-eslint/angular-eslint[Angular ESLint] - Rule https://github.com/angular-eslint/angular-eslint/blob/main/packages/eslint-plugin/docs/rules/contextual-lifecycle.md[contextual-lifecycle]
 * Angular Lifecycle Hooks - https://angular.dev/guide/components/lifecycle[Official Angular documentation on lifecycle hooks and their usage contexts]
 * Angular Services and Dependency Injection - https://angular.dev/guide/di[Guide on Angular services and their lifecycle]

