This rule raises an issue when Angular lifecycle methods are used in classes with decorators that don't support those specific lifecycle hooks.

== Why is this an issue?

Angular provides different types of classes for different purposes, and each type supports only certain lifecycle methods.

Components (`@Component`) and Directives (`@Directive`) are the primary building blocks that interact with the DOM and have a full lifecycle. They support most lifecycle hooks like `ngOnInit`, `ngOnChanges`, `ngDoCheck`, `ngAfterContentInit`, `ngAfterContentChecked`, `ngAfterViewInit`, `ngAfterViewChecked`, and `ngOnDestroy`.

Services (`@Injectable`) are typically stateless and don't have a DOM representation. They only support `ngOnDestroy` for cleanup purposes when the service is destroyed.

Pipes (`@Pipe`) are pure functions for data transformation and only support `ngOnDestroy` for cleanup.

Modules (`@NgModule`) are configuration classes that only support `ngDoBootstrap` for custom bootstrapping logic.

Using lifecycle methods in the wrong context creates several problems:

* The methods will never be called by Angular, leading to dead code
* It indicates a misunderstanding of Angular's architecture
* It can confuse other developers about the class's purpose and behavior
* It may suggest that the class should have a different decorator or be restructured

=== What is the potential impact?

Using lifecycle methods in incorrect contexts results in dead code that never executes, potentially causing bugs when developers expect the lifecycle logic to run. It also indicates architectural misunderstandings that can lead to poorly structured applications and maintenance difficulties.

=== How to fix in Angular?

Remove lifecycle methods that are not supported by the class type, or change the class decorator to one that supports the lifecycle method.

==== Non-compliant code example

[source,typescript,diff-id=1,diff-type=noncompliant]
----
@Injectable()
class UserService {
  ngOnInit() { // Noncompliant
    console.log('Service initialized');
  }
}
----

==== Compliant code example

[source,typescript,diff-id=1,diff-type=compliant]
----
@Injectable()
class UserService {
  // Remove ngOnInit - services don't support this lifecycle
  constructor() {
    console.log('Service initialized');
  }
}
----

For view-related lifecycle methods, use them only in Components and Directives that actually have views.

==== Non-compliant code example

[source,typescript,diff-id=2,diff-type=noncompliant]
----
@Pipe({ name: 'transform' })
class TransformPipe {
  ngAfterViewInit() { // Noncompliant
    console.log('View initialized');
  }
}
----

==== Compliant code example

[source,typescript,diff-id=2,diff-type=compliant]
----
@Pipe({ name: 'transform' })
class TransformPipe {
  // Remove ngAfterViewInit - pipes don't have views
  ngOnDestroy() {
    console.log('Pipe destroyed');
  }
}
----

Use ngDoBootstrap only in NgModule classes for custom application bootstrapping.

==== Non-compliant code example

[source,typescript,diff-id=3,diff-type=noncompliant]
----
@Component({
  selector: 'app-root'
})
class AppComponent {
  ngDoBootstrap() { // Noncompliant
    console.log('Bootstrapping');
  }
}
----

==== Compliant code example

[source,typescript,diff-id=3,diff-type=compliant]
----
@NgModule({
  declarations: [AppComponent],
  entryComponents: [AppComponent]
})
class AppModule {
  ngDoBootstrap(appRef: ApplicationRef) {
    appRef.bootstrap(AppComponent);
  }
}
----

=== Documentation

 * Angular Lifecycle Hooks - https://angular.io/guide/lifecycle-hooks[Official Angular documentation explaining all lifecycle hooks and their proper usage]
 * Angular Architecture Overview - https://angular.io/guide/architecture[Overview of Angular's architecture including components, services, and modules]
 * Angular Bootstrapping - https://angular.io/guide/bootstrapping[Guide to bootstrapping Angular applications including ngDoBootstrap usage]

