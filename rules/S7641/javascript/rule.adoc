This rule raises an issue when Angular lifecycle methods are used in classes with decorators that don't support those specific lifecycle hooks.

== Why is this an issue?

Angular provides different types of classes for different purposes, and each type supports only certain lifecycle hooks.

Components (`@Component`) and Directives (`@Directive`) are the primary building blocks that interact with the DOM and have full access to all lifecycle hooks like `ngOnInit`, `ngOnDestroy`, `ngOnChanges`, `ngDoCheck`, `ngAfterContentInit`, `ngAfterContentChecked`, `ngAfterViewInit`, and `ngAfterViewChecked`.

Services (`@Injectable`) are designed for business logic and data management. They typically only need `ngOnDestroy` for cleanup tasks like unsubscribing from observables. Using other lifecycle hooks in services indicates a misunderstanding of Angular's architecture.

Pipes (`@Pipe`) are pure functions for data transformation and generally only need `ngOnDestroy` for cleanup. Other lifecycle hooks don't make sense in this context.

Modules (`@NgModule`) are configuration classes that organize the application. They only support `ngDoBootstrap` for custom bootstrapping scenarios.

Using lifecycle hooks in inappropriate contexts can lead to:

* Code that doesn't execute as expected
* Confusion about the application's architecture
* Maintenance difficulties
* Performance issues from unnecessary lifecycle hook executions

=== What is the potential impact?

Using lifecycle methods in inappropriate contexts can cause unexpected behavior, performance issues, and make the codebase harder to understand and maintain. It may also indicate architectural problems in the application design.

=== How to fix in Angular?


Move lifecycle logic to appropriate component or directive classes, or remove unnecessary lifecycle methods from services.

==== Non-compliant code example

[source,typescript,diff-id=1,diff-type=noncompliant]
----
@Injectable()
class UserService {
  ngOnInit() { // Noncompliant
    console.log('Service initialized');
  }
  
  ngAfterViewInit() { // Noncompliant
    console.log('View initialized');
  }
}
----

==== Compliant code example

[source,typescript,diff-id=1,diff-type=compliant]
----
@Injectable()
class UserService {
  constructor() {
    console.log('Service initialized');
  }
  
  ngOnDestroy() {
    // Only use ngOnDestroy for cleanup
    console.log('Service destroyed');
  }
}
----

Use ngDoBootstrap only in NgModule classes for custom application bootstrapping.

==== Non-compliant code example

[source,typescript,diff-id=2,diff-type=noncompliant]
----
@Component({
  selector: 'app-root',
  template: '<h1>Hello</h1>'
})
class AppComponent {
  ngDoBootstrap() { // Noncompliant
    console.log('Bootstrapping');
  }
}
----

==== Compliant code example

[source,typescript,diff-id=2,diff-type=compliant]
----
@NgModule({
  declarations: [AppComponent],
  imports: [BrowserModule]
})
class AppModule {
  ngDoBootstrap() {
    // Correct context for custom bootstrapping
    console.log('Bootstrapping');
  }
}
----

Use view-related lifecycle hooks only in components and directives that interact with the DOM.

==== Non-compliant code example

[source,typescript,diff-id=3,diff-type=noncompliant]
----
@Pipe({name: 'transform'})
class TransformPipe {
  ngAfterViewInit() { // Noncompliant
    console.log('View initialized');
  }
}
----

==== Compliant code example

[source,typescript,diff-id=3,diff-type=compliant]
----
@Component({
  selector: 'app-example',
  template: '<div>Example</div>'
})
class ExampleComponent {
  ngAfterViewInit() {
    console.log('View initialized');
  }
}
----
=== Documentation

 * Angular Lifecycle Hooks - https://angular.dev/guide/components/lifecycle[Official Angular documentation on lifecycle hooks and their usage]
 * Angular Architecture Overview - https://angular.dev/guide/architecture[Understanding Angular's architecture and different types of classes]
 * Angular Services and Dependency Injection - https://angular.dev/guide/di[Guide to Angular services and their proper usage patterns]

