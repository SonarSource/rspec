This rule raises an issue when Angular lifecycle methods are implemented in class types where they won't be executed by the framework.

== Why is this an issue?

Angular lifecycle methods are only called by the framework in specific contexts. Each lifecycle hook has a designated purpose and is only executed for certain types of Angular classes.

For example, view-related lifecycle methods like `ngAfterViewInit` are only called for Components and Directives that have associated views. Content-related methods like `ngAfterContentInit` are only relevant for classes that support content projection.

When these methods are implemented in inappropriate contexts (like using `ngAfterViewInit` in an Injectable service), they become dead code that will never execute. This can mislead developers into thinking the lifecycle logic will run when it won't, potentially causing bugs or unexpected behavior.

The framework simply ignores these methods when they're in the wrong context, making debugging difficult since there's no error - the code just silently doesn't work.

=== What is the potential impact?

Using lifecycle methods in wrong contexts creates dead code that never executes, leading to:

* Logic that developers expect to run but doesn't
* Difficult debugging sessions when expected behavior doesn't occur
* Misleading code that suggests functionality that isn't actually active
* Potential memory leaks if cleanup code in inappropriate lifecycle methods doesn't run

=== How to fix in Angular?

Move lifecycle methods to appropriate Angular class types. Use `ngOnDestroy` in services for cleanup, and view/content lifecycle methods only in Components and Directives.

==== Non-compliant code example

[source,typescript,diff-id=1,diff-type=noncompliant]
----
@Injectable()
class UserService {
  ngAfterViewInit() { // Noncompliant - services don't have views
    console.log('View initialized');
  }
}
----

==== Compliant code example

[source,typescript,diff-id=1,diff-type=compliant]
----
@Injectable()
class UserService {
  ngOnDestroy() { // Correct - services can use ngOnDestroy for cleanup
    console.log('Service destroyed');
  }
}

@Component({
  template: '<div>Content</div>'
})
class UserComponent {
  ngAfterViewInit() { // Correct - components have views
    console.log('View initialized');
  }
}
----

Use `ngDoBootstrap` only in NgModules where it's designed to work for manual bootstrapping.

==== Non-compliant code example

[source,typescript,diff-id=2,diff-type=noncompliant]
----
@Component()
class AppComponent {
  ngDoBootstrap() { // Noncompliant - components don't bootstrap
    // This will never be called
  }
}
----

==== Compliant code example

[source,typescript,diff-id=2,diff-type=compliant]
----
@NgModule({
  declarations: [AppComponent]
})
class AppModule {
  ngDoBootstrap() { // Correct - modules handle bootstrapping
    // Manual bootstrap logic
  }
}
----

=== Documentation

 * Angular Lifecycle Hooks Guide - https://angular.dev/guide/components/lifecycle[Official Angular documentation explaining when and where to use lifecycle hooks]
 * Angular Services and Dependency Injection - https://angular.dev/guide/di[Guide explaining the lifecycle of Angular services and appropriate cleanup patterns]

