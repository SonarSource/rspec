<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This is an issue when a trigger handler class contains multiple unrelated pieces of logic, such as validation, field assignment, and business rules all combined in one class.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Massive trigger handler classes violate the Single Responsibility Principle and create several problems:</p>
</div>
<div class="paragraph">
<p><strong>Maintainability Issues</strong>
When all trigger logic is combined into one large class, it becomes difficult to understand what the code does. Developers must read through hundreds of lines to find specific functionality. Making changes becomes risky because modifying one piece of logic might accidentally break another unrelated feature.</p>
</div>
<div class="paragraph">
<p><strong>Testing Challenges</strong>
Large trigger handlers are harder to test effectively. You cannot test individual pieces of logic in isolation, which makes it difficult to write focused unit tests. This leads to either incomplete test coverage or overly complex test methods that try to cover too many scenarios.</p>
</div>
<div class="paragraph">
<p><strong>Code Reusability</strong>
When logic is bundled together, you cannot reuse specific pieces of functionality in other contexts. For example, validation logic that could be useful in other triggers or classes becomes tightly coupled to one specific handler.</p>
</div>
<div class="paragraph">
<p><strong>Team Collaboration</strong>
Multiple developers working on the same large trigger handler class creates merge conflicts and coordination problems. Different team members cannot work independently on separate features.</p>
</div>
<div class="paragraph">
<p><strong>Performance Impact</strong>
Large classes with multiple responsibilities often perform unnecessary operations. For example, validation logic might run even when only assignment logic is needed, leading to inefficient execution.</p>
</div>
<div class="sect2">
<h3 id="_what_is_the_potential_impact">What is the potential impact?</h3>
<div class="paragraph">
<p>Large, monolithic trigger handler classes significantly increase maintenance costs and development time. They make the codebase fragile and error-prone, leading to bugs that are difficult to trace and fix. The lack of modularity also makes it harder to implement new features or modify existing ones without risking unintended side effects.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_fix_it">How to fix it</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Break down the massive trigger handler into small, focused classes that each handle a single responsibility. Use the Trigger Actions Framework to organize and orchestrate these individual action classes.</p>
</div>
<div class="sect2">
<h3 id="_code_examples">Code examples</h3>
<div class="sect3">
<h4 id="_noncompliant_code_example">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-apex" data-lang="apex">public class OpportunityTriggerHandler {
  public void handleBeforeInsert(List&lt;Opportunity&gt; newList) {
    // Stage validation logic
    for (Opportunity opp : newList) {
      if (opp.StageName != 'Prospecting') {
        opp.addError('Invalid stage'); // Noncompliant
      }
    }
    // Price validation logic
    for (Opportunity opp : newList) {
      if (opp.Amount &lt; 0) {
        opp.addError('Invalid amount'); // Noncompliant
      }
    }
    // Owner assignment logic
    for (Opportunity opp : newList) {
      if (opp.OwnerId == null) {
        opp.OwnerId = UserInfo.getUserId(); // Noncompliant
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-apex" data-lang="apex">public class ta_Opportunity_StageInsertRules implements TriggerAction.BeforeInsert {
  public void beforeInsert(List&lt;Opportunity&gt; newList) {
    for (Opportunity opp : newList) {
      if (opp.StageName != 'Prospecting') {
        opp.addError('The Stage must be Prospecting when an Opportunity is created');
      }
    }
  }
}

public class ta_Opportunity_PriceValidation implements TriggerAction.BeforeInsert {
  public void beforeInsert(List&lt;Opportunity&gt; newList) {
    for (Opportunity opp : newList) {
      if (opp.Amount &lt; 0) {
        opp.addError('Invalid amount');
      }
    }
  }
}

public class ta_Opportunity_OwnerAssignment implements TriggerAction.BeforeInsert {
  public void beforeInsert(List&lt;Opportunity&gt; newList) {
    for (Opportunity opp : newList) {
      if (opp.OwnerId == null) {
        opp.OwnerId = UserInfo.getUserId();
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_documentation">Documentation</h3>
<div class="ulist">
<ul>
<li>
<p>Trigger Actions Framework - <a href="https://www.apexhours.com/trigger-actions-framework">Comprehensive guide to implementing the Trigger Actions Framework for better trigger organization</a></p>
</li>
<li>
<p>Apex Trigger Best Practices - <a href="https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/apex_triggers_best_practices.htm">Official Salesforce documentation on trigger best practices</a></p>
</li>
<li>
<p>Single Responsibility Principle - <a href="https://en.wikipedia.org/wiki/Single-responsibility_principle">Explanation of the Single Responsibility Principle in software design</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_standards">Standards</h3>
<div class="ulist">
<ul>
<li>
<p>SOLID Principles - Single Responsibility Principle - <a href="https://en.wikipedia.org/wiki/SOLID">The Single Responsibility Principle states that a class should have only one reason to change</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>