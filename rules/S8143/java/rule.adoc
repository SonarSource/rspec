This rule raises an issue when ScopedValue.Carrier.where() return values are ignored or when multiple separate ScopedValue instances are used instead of bundling values into a record.

== Why is this an issue?

ScopedValue.Carrier is immutable. The `where()` method returns a new Carrier object - it doesn't modify the existing one. Ignoring the return value means your mapping has no effect.

Using multiple separate ScopedValue instances reduces cache efficiency. Java recommends bundling related values into a single record class bound to one ScopedValue instance for better performance.

=== What is the potential impact?

Ignoring `where()` return values causes scoped values to not bind correctly, leading to `NoSuchElementException` or unexpected behavior.

Multiple separate ScopedValue instances create cache thrashing, causing expensive scope scanning that slows down your application.

== How to fix it

Always use the return value of ScopedValue.Carrier.where() since it returns a new immutable Carrier object.

=== Code examples

==== Noncompliant code example

[source,java,diff-id=1,diff-type=noncompliant]
----
ScopedValue.Carrier carrier = ScopedValue.where(key1, value1);
carrier.where(key2, value2); // Noncompliant: result not used
carrier.run(() -> { /* operation */ });
----

==== Compliant solution

[source,java,diff-id=1,diff-type=compliant]
----
ScopedValue.Carrier carrier = ScopedValue.where(key1, value1);
ScopedValue.Carrier newCarrier = carrier.where(key2, value2);
newCarrier.run(() -> { /* operation */ });
----

== Resources

=== Documentation

 * ScopedValue.Carrier JavaDoc - https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/ScopedValue.Carrier.html[Official documentation for ScopedValue.Carrier class explaining its immutable nature]

 * ScopedValue JavaDoc - https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/ScopedValue.html[Official documentation for ScopedValue class with performance recommendations]
