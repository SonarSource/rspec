This rule raises an issue when functions that return an error as their last return value have that error ignored using the blank identifier (`_`) or when the error is not checked immediately after the function call.

== Why is this an issue?

Go's error handling philosophy is built around explicit error checking rather than exceptions. When errors are ignored or not checked immediately, it can lead to several problems:

First, ignoring errors with the blank identifier (`_`) creates silent failures. The program continues executing even when something has gone wrong, which can lead to unpredictable behavior, data corruption, or security vulnerabilities. For example, if a file operation fails but the error is ignored, the program might try to work with invalid data or leave resources in an inconsistent state.

Second, when errors are not checked immediately after a function call, it becomes unclear whether subsequent code should execute. The error might indicate that the returned values are invalid or that the operation didn't complete successfully. Using these potentially invalid values can cause crashes, incorrect results, or other unexpected behavior.

Third, delayed error checking makes debugging more difficult. When an error is checked far from where it occurred, it becomes harder to understand the context and root cause of the problem. This violates Go's principle of handling errors close to where they occur.

Proper error handling is essential for building robust, maintainable Go applications. It ensures that failures are detected early, handled appropriately, and don't propagate silently through the system.

=== What is the potential impact?

Ignoring or not properly checking errors can lead to:

* Silent failures that are difficult to detect and debug
* Data corruption or inconsistent application state
* Security vulnerabilities when error conditions are not handled
* Resource leaks when cleanup operations fail silently
* Unpredictable application behavior in production environments
* Difficulty in troubleshooting issues due to lack of error information

== How to fix it

Always capture error return values and check them immediately after the function call. Use proper error handling patterns like returning the error to the caller or logging it appropriately.

=== Code examples

==== Noncompliant code example

[source,go,diff-id=1,diff-type=noncompliant]
----
file, _ := os.Open("example.txt") // Noncompliant
defer file.Close()
----

==== Compliant solution

[source,go,diff-id=1,diff-type=compliant]
----
file, err := os.Open("example.txt")
if err != nil {
    return fmt.Errorf("failed to open file: %w", err)
}
defer file.Close()
----

== Resources

=== Documentation

 * Error handling and Go - The Go Blog - https://go.dev/blog/error-handling-and-go[Official Go blog post explaining error handling patterns and best practices]

 * Go by Example: Errors - https://gobyexample.com/errors[Practical examples of error handling in Go]

 * Effective Go - Errors - https://go.dev/doc/effective_go#errors[Official Go documentation on error handling conventions]

=== Standards

 * CWE-754: Improper Check for Unusual or Exceptional Conditions - https://cwe.mitre.org/data/definitions/754.html[Covers the security implications of not properly checking for error conditions]

=== Related rules

 * RSPEC-1511 - https://rules.sonarsource.com/abap/RSPEC-1511/[Similar rule for ABAP about checking return codes]
