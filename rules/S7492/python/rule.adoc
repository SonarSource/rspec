This rule raises an issue when list comprehensions are used as parameters to `any()` or `all()` instead of generator expressions as this prevents `any()` or `all()` from short-circuiting.

== Why is this an issue?

Using a list comprehension inside `any()` or `all()` forces the entire list to be created in memory before the check begins. This prevents the short-circuiting behavior that these functions are designed to leverage, where `any()` stops at the first `True` and `all()` stops at the first `False`.

Using a generator expression (without the square brackets) provides the same functionality while preserving the short-circuiting behavior of these functions, resulting in better performance.

== How to fix it

Use a generator expression instead of a list comprehension.

=== Code examples

==== Noncompliant code example

[source,python,diff-id=1,diff-type=noncompliant]
----
numbers = [1, 5, 0, 10]

res_all = all([x > 2 for x in numbers])  # Noncompliant
res_any = any([x > 2 for x in numbers])  # Noncompliant
----

==== Compliant solution

[source,python,diff-id=1,diff-type=compliant]
----
numbers = [1, 5, 0, 10]

res_all = all(x > 2 for x in numbers)  # Compliant: Stops at first False (0)
res_any = any(x > 2 for x in numbers)  # Compliant: Stops at first True (5)
----

=== How does this work?

Generator expressions produce values on demand rather than all at once. When combined with `any()` or `all()` functions, this creates an efficient evaluation process:

* With `any(...)`, evaluation stops as soon as a truthy value is encountered
* With `all(...)`, evaluation stops as soon as a falsy value is encountered

This approach saves both processing time and memory, especially for large iterables or when the condition has side effects or is computationally expensive.

== Resources
=== Documentation
* Python Wiki - https://wiki.python.org/moin/Generators[Generators]
* Python Doc - https://docs.python.org/3/glossary.html#term-generator[Generator Glossary Entry]
