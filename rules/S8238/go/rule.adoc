This rule raises an issue when a pointer is dereferenced, a field is accessed through a pointer, or a method is called on a pointer without first checking if the pointer is nil.

== Why is this an issue?

In Go, pointers have a zero value of `nil`. When you try to dereference a nil pointer using the `*` operator, access a field through a nil pointer, or call a method on a nil pointer, the program will panic at runtime.

A panic is Go's way of handling unrecoverable errors. When a panic occurs, the program stops normal execution and begins unwinding the stack, calling any deferred functions along the way. If the panic is not recovered, the program terminates.

Nil pointer dereference is one of the most common causes of runtime panics in Go programs. This can happen in several scenarios:

* Direct dereferencing with the `*` operator on an uninitialized pointer
* Accessing fields or calling methods on struct pointers that haven't been initialized
* Working with pointer chains where any link in the chain could be nil
* Operations in data structures like linked lists, trees, or graphs where nodes may be nil

These panics are particularly problematic because they can occur in production environments, potentially causing service outages or data loss. Unlike compile-time errors, nil pointer panics only surface when the specific code path is executed with nil values.

=== What is the potential impact?

Runtime panics can cause immediate program termination, leading to service outages, data loss, or degraded user experience. In server applications, unhandled panics can crash entire services. The unpredictable nature of these failures makes them difficult to debug and can erode user trust in the application's reliability.

== How to fix it

Add explicit nil checks before dereferencing pointers or accessing their fields. Use early returns or error handling to manage nil cases gracefully.

=== Code examples

==== Noncompliant code example

[source,go,diff-id=1,diff-type=noncompliant]
----
var p *int
fmt.Println(*p) // Noncompliant
----

==== Compliant solution

[source,go,diff-id=1,diff-type=compliant]
----
var p *int
if p != nil {
    fmt.Println(*p)
} else {
    fmt.Println("pointer is nil")
}
----

== Resources

=== Documentation

 * Go Tour - Pointers - https://go.dev/tour/moretypes/1[Official Go tutorial explaining pointer basics and nil values]

 * Go Tour - Interface values with nil underlying values - https://go.dev/tour/methods/12[Explains how Go handles nil receivers in method calls]

 * Effective Go - Pointers vs Values - https://go.dev/doc/effective_go#pointers_vs_values[Best practices for using pointers in Go]

=== Standards

 * CWE-476: NULL Pointer Dereference - https://cwe.mitre.org/data/definitions/476.html[Common weakness related to dereferencing null pointers]

=== Related rules

 * RSPEC-2259 - https://rules.sonarsource.com/csharp/RSPEC-2259/[Similar rule for other languages addressing null pointer dereference]
