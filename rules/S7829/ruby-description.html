<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This rule raises an issue when a model class calls view rendering methods like <code>render</code>, <code>render_to_string</code>, or <code>render_partial</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In the Model-View-Controller (MVC) architectural pattern, each component has a specific responsibility. Models handle data persistence and business logic, views handle presentation, and controllers coordinate between them.</p>
</div>
<div class="paragraph">
<p>When models directly render views, they violate the separation of concerns principle. This creates several problems:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Tight coupling</strong>: The model becomes dependent on view templates, making it harder to change either independently.</p>
</li>
<li>
<p><strong>Testing complexity</strong>: Unit tests for models become more complex because they need to account for view rendering logic.</p>
</li>
<li>
<p><strong>Reusability issues</strong>: Models that render views are harder to reuse in different contexts, such as API endpoints or background jobs.</p>
</li>
<li>
<p><strong>Maintenance burden</strong>: Changes to view logic require modifications in model classes, breaking the single responsibility principle.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The MVC pattern exists to keep code organized and maintainable. When models handle presentation concerns, the architecture becomes muddled and harder to understand.</p>
</div>
<div class="sect2">
<h3 id="_what_is_the_potential_impact">What is the potential impact?</h3>
<div class="paragraph">
<p>Violating MVC separation of concerns leads to tightly coupled code that is difficult to maintain, test, and scale. Models become harder to reuse in different contexts, and changes to view logic require modifications across multiple layers of the application.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_fix_it_in_rails">How to fix it in Rails</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Move view rendering logic to a controller or dedicated service class. Use callbacks to trigger notifications or background jobs instead of direct rendering.</p>
</div>
<div class="sect2">
<h3 id="_code_examples">Code examples</h3>
<div class="sect3">
<h4 id="_noncompliant_code_example">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">class WallFeed &lt; ApplicationRecord
  after_create :push_create

  private

  def push_create
    rendered_content = render_to_string(partial: 'feeds/feed_item') # Noncompliant
    push_notification(rendered_content)
  end
end</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">class WallFeed &lt; ApplicationRecord
  after_create :notify_creation

  private

  def notify_creation
    WallFeedNotificationService.new(self).push_create
  end
end

class WallFeedNotificationService
  include AbstractController::Rendering

  def initialize(wall_feed)
    @wall_feed = wall_feed
  end

  def push_create
    rendered_content = render_to_string(partial: 'feeds/feed_item', locals: { feed_item: @wall_feed })
    push_notification(rendered_content)
  end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Use background jobs to handle rendering and notifications asynchronously, keeping models focused on data operations.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_code_examples_2">Code examples</h3>
<div class="sect3">
<h4 id="_noncompliant_code_example_2">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">class User &lt; ApplicationRecord
  after_update :send_welcome_email

  private

  def send_welcome_email
    email_body = render(template: 'mailers/welcome') # Noncompliant
    UserMailer.send_email(email, email_body)
  end
end</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution_2">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">class User &lt; ApplicationRecord
  after_update :queue_welcome_email

  private

  def queue_welcome_email
    WelcomeEmailJob.perform_later(self.id)
  end
end

class WelcomeEmailJob &lt; ApplicationJob
  def perform(user_id)
    user = User.find(user_id)
    UserMailer.welcome_email(user).deliver_now
  end
end</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_documentation">Documentation</h3>
<div class="ulist">
<ul>
<li>
<p>Rails MVC Architecture Guide - <a href="https://guides.rubyonrails.org/getting_started.html#mvc-and-you">Official Rails guide explaining the Model-View-Controller pattern</a></p>
</li>
<li>
<p>Active Record Callbacks - <a href="https://guides.rubyonrails.org/active_record_callbacks.html">Guide on using Active Record callbacks properly without violating MVC</a></p>
</li>
<li>
<p>AbstractController::Rendering - <a href="https://api.rubyonrails.org/classes/AbstractController/Rendering.html">Rails API documentation for proper rendering in service classes</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_standards">Standards</h3>
<div class="ulist">
<ul>
<li>
<p>SOLID Principles - Single Responsibility Principle - <a href="https://en.wikipedia.org/wiki/Single-responsibility_principle">Each class should have only one reason to change</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>