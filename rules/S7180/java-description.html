<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Annotating interfaces or interface methods with <code>@Cache*</code> annotations is not recommended by the official Spring documentation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Spring recommends that you only annotate concrete classes (and methods of concrete classes) with the @Cache* annotations, as opposed to annotating interfaces. You certainly can place an @Cache* annotation on an interface (or an interface method), but this works only if you use the proxy mode (mode="proxy"). If you use the weaving-based aspect (mode="aspectj"), the caching settings are not recognized on interface-level declarations by the weaving infrastructure.</pre>
</div>
</div>
<div class="paragraph">
<p>Also, when a method is annotated as cacheable inside an interface, if two different implementations of that method exist, the first one to be invoked will populate the cache.
Subsequent calls will always return the cached value, even if it&#8217;s the other implementation being called.</p>
</div>
<div class="sect2">
<h3 id="_what_is_the_potential_impact">What is the potential impact?</h3>
<div class="ulist">
<ul>
<li>
<p><strong>Confusing Code</strong>: Developers may mistakenly believe that caching is in effect, leading to confusion and incorrect assumptions about application performance.</p>
</li>
<li>
<p><strong>Unreliable Code</strong>: Annotating interface methods as <code>@Cacheable</code> hides the cache name from the implementing classes, making it hard to detect where a conflict of names might occur, causing unexpected results at runtime.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This rule raises an issue when an interface or an interface method is annotated with a <code>@Cache*</code> annotation.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_fix_it">How to fix it</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Move <code>@Cache*</code> annotation from interface or interface method to the concrete class.</p>
</div>
<div class="sect2">
<h3 id="_code_examples">Code examples</h3>
<div class="sect3">
<h4 id="_noncompliant_code_example">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface ExampleService {

    @Cacheable("exampleCache") // Noncompliant: interface method is annotated with @Cacheable
    String getData(String id);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the following example, if our application has two different rest APIs to query the most popular animal in two different zoos, the first zoo to be queried will populate the cache.</p>
</div>
<div class="paragraph">
<p>Calls to a different API to query the other zoo will produce the same cached output, invalidating our application&#8217;s business logic.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface Zoo {
    @Cacheable("popAnimal") //non compliant, interface method is annotated with @Cacheable
    Animal getMostPopularAnimal();
}

public class SanDiegoZoo implements Zoo {
    @Override
    public Animal getMostPopularAnimal() {
        return new Lion();
    }
}

public class RomeBioparc implements Zoo {
    @Override
    public Animal getMostPopularAnimal() {
        return new Pantegana();
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Service
public class ExampleServiceImpl implements ExampleService {

    @Cacheable("exampleCache")
    @Override
    public String getData(String id) {
        // Implementation here
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>With the following solution, we are granted that the two implementations will have separate caches.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface Zoo {
    Animal getMostPopularAnimal();
}

public class SanDiegoZoo implements Zoo {
    @Override
    @Cacheable("sanDiegoPopAnimal")
    public Animal getMostPopularAnimal() {
        return new Lion();
    }
}

public class RomeBioparc implements Zoo {
    @Override
    @Cacheable("romePopAnimal")
    public Animal getMostPopularAnimal() {
        return new Pantegana();
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_documentation">Documentation</h3>
<div class="ulist">
<ul>
<li>
<p>Spring - <a href="https://docs.spring.io/spring-framework/reference/integration/cache/annotations.html#cache-annotation-enable">Declarative Annotation-based Caching</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>