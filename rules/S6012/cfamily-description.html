<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Since C&#43;&#43;17, class template arguments can be automatically deduced by the compiler, either by looking at the arguments of the class constructors or by using an explicitly defined deduction guide.</p>
</div>
<div class="paragraph">
<p>Using the class template argument deduction allows to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Avoid verbose specification of all template parameter types for a class template.</p>
</li>
<li>
<p>Avoid writing helper function that only serves the purpose of deducing the type of a class from its arguments. For example, <code>std::make_pair</code>.</p>
</li>
<li>
<p>Be able to instantiate a class template with hard-to-spell or unutterable names, such as the closure type of a lambda.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This rule raises an issue when explicit class template arguments that can be automatically deduced are specified.</p>
</div>
<div class="sect2">
<h3 id="_noncompliant_code_example">Noncompliant code example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">void f() {
    std::vector&lt;int&gt; v1 {1, 2, 3}; // Noncompliant, int could have been deduced
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_compliant_solution">Compliant solution</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">using namespace std::literals;
void f() {
    std::vector v1 {1, 2, 3}; // Compliant, int could be deduced
    std::vector&lt;std::string&gt; v2 {"a", "b", "c"}; // Compliant, automatic deduction would create a vector&lt;char const *&gt;
    std::vector v3 {"a"s, "b"s, "c"s}; // Still compliant, another option
}</code></pre>
</div>
</div>
</div>
</div>
</div>