<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When an interface inherits from two interfaces that both define a member with the same name, trying to access that member through the derived interface will result in the compiler error <code>CS0229 Ambiguity between 'IBase1.SomeProperty' and 'IBase2.SomeProperty'</code>.</p>
</div>
<div class="paragraph">
<p>So instead, every caller will be forced to cast instances of the derived interface to one or the other of its base interfaces to resolve the ambiguity and be able to access the member. Instead, it is better to resolve the ambiguity in the definition of the derived interface either by:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>renaming the member in one of the base interfaces to remove the collision</p>
</li>
<li>
<p>also defining that member in the derived interface. Use this only if all copies of the member are meant to hold the same value.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_noncompliant_code_example">Noncompliant code example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-csharp" data-lang="csharp">public interface IBase1
{
  string SomeProperty { get; set; }
}

public interface IBase2
{
  string SomeProperty { get; set; }
}

public interface IDerived : IBase1, IBase2 // Noncompliant, accessing IDerived.SomeProperty is ambiguous
{
}

public class MyClass : IDerived
{
  // Implements both IBase1.SomeProperty and IBase2.SomeProperty
  public string SomeProperty { get; set; } = "Hello";

  public static void Main()
  {
    MyClass myClass = new MyClass();
    Console.WriteLine(myClass.SomeProperty); // Writes "Hello" as expected
    Console.WriteLine(((IBase1)myClass).SomeProperty); // Writes "Hello" as expected
    Console.WriteLine(((IBase2)myClass).SomeProperty); // Writes "Hello" as expected
    Console.WriteLine(((IDerived)myClass).SomeProperty); // Error CS0229 Ambiguity between 'IBase1.SomeProperty' and 'IBase2.SomeProperty'
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_compliant_solution">Compliant solution</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-csharp" data-lang="csharp">public interface IDerived : IBase1, IBase2
{
  new string SomeProperty { get; set; }
}

public class MyClass : IDerived
{
  // Implements IBase1.SomeProperty, IBase2.SomeProperty and IDerived.SomeProperty
  public string SomeProperty { get; set; } = "Hello";

  public static void Main()
  {
    MyClass myClass = new MyClass();
    Console.WriteLine(myClass.SomeProperty); // Writes "Hello" as expected
    Console.WriteLine(((IBase1)myClass).SomeProperty); // Writes "Hello" as expected
    Console.WriteLine(((IBase2)myClass).SomeProperty); // Writes "Hello" as expected
    Console.WriteLine(((IDerived)myClass).SomeProperty); // Writes "Hello" as expected
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>or</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-csharp" data-lang="csharp">public interface IBase1
{
  string SomePropertyOne { get; set; }
}

public interface IBase2
{
  string SomePropertyTwo { get; set; }
}

public interface IDerived : IBase1, IBase2
{
}</code></pre>
</div>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_implementation_specification">Implementation Specification</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_message">Message</h3>
<div class="paragraph">
<p>Rename or add members "{X}" and "{Y}" to this interface to resolve ambiguities.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Note that the ellipsis at the end should only be displayed when there are more than two methods to override</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_highlighting">Highlighting</h3>
<div class="ulist">
<ul>
<li>
<p>Primary: interface name</p>
</li>
<li>
<p>Secondary: Implemented interfaces with colliding members</p>
<div class="ulist">
<ul>
<li>
<p>message: Rename or add this ambiguous member.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_comments_and_links">Comments And Links</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_on_8_dec_2015_091207_tamas_vajk_wrote">on 8 Dec 2015, 09:12:07 Tamas Vajk wrote:</h3>
<div class="paragraph">
<p>\[~ann.campbell.2] LGTM. (changed the message and the code samples)</p>
</div>
</div>
<div class="sect2">
<h3 id="_on_8_dec_2015_151211_ann_campbell_wrote">on 8 Dec 2015, 15:12:11 Ann Campbell wrote:</h3>
<div class="paragraph">
<p>\[~tamas.vajk] I&#8217;ve updated the SQALE remediation (constant to linear) to correspond to your message change</p>
</div>
</div>
<div class="sect2">
<h3 id="_on_1_dec_2016_141033_tamas_vajk_wrote">on 1 Dec 2016, 14:10:33 Tamas Vajk wrote:</h3>
<div class="paragraph">
<p>\[~ann.campbell.2] I know it&#8217;s not ideal, but I&#8217;m reverting this back to a constant effort rule. We&#8217;re migrating to Rule-API based descriptions, and in .NET we don&#8217;t have linear regression function support.</p>
</div>
</div>
</div>
</div>