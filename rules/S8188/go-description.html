<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This is an issue when using <code>context.WithCancel</code>, <code>context.WithTimeout</code>, or <code>context.WithDeadline</code> without deferring the returned cancel function.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When you create a cancelable context using functions like <code>context.WithCancel</code>, <code>context.WithTimeout</code>, or <code>context.WithDeadline</code>, these functions return two values: a new context and a cancel function.</p>
</div>
<div class="paragraph">
<p>The cancel function is crucial for proper resource management. It releases resources associated with the context, such as timers and goroutines. If you don&#8217;t call the cancel function, these resources may leak, leading to memory consumption and potential performance issues.</p>
</div>
<div class="paragraph">
<p>The Go runtime cannot automatically clean up these resources because it doesn&#8217;t know when you&#8217;re done with the context. Only your code knows the appropriate time to release these resources.</p>
</div>
<div class="paragraph">
<p>Using <code>defer cancel()</code> immediately after creating the context ensures that cleanup happens automatically when the function returns, regardless of how the function exits (normal return, early return, or panic). This follows the Go idiom of acquiring resources and immediately scheduling their cleanup.</p>
</div>
<div class="sect2">
<h3 id="_what_is_the_potential_impact">What is the potential impact?</h3>
<div class="paragraph">
<p>Failing to call the cancel function can lead to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Memory leaks</strong>: Uncanceled contexts may hold references to resources that cannot be garbage collected</p>
</li>
<li>
<p><strong>Goroutine leaks</strong>: Background goroutines associated with timeouts may continue running indefinitely</p>
</li>
<li>
<p><strong>Resource exhaustion</strong>: In high-traffic applications, accumulated leaks can consume significant system resources</p>
</li>
<li>
<p><strong>Performance degradation</strong>: Leaked goroutines and timers can impact application performance over time</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_fix_it">How to fix it</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Add a <code>defer cancel()</code> statement immediately after creating the context. This ensures the cancel function is called when the function returns, preventing resource leaks.</p>
</div>
<div class="sect2">
<h3 id="_code_examples">Code examples</h3>
<div class="sect3">
<h4 id="_noncompliant_code_example">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-go" data-lang="go">func handleRequest() {
    ctx, cancel := context.WithTimeout(context.Background(), time.Second)
    // Missing defer cancel() - resources may leak
    doWork(ctx)
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-go" data-lang="go">func handleRequest() {
    ctx, cancel := context.WithTimeout(context.Background(), time.Second)
    defer cancel() // Ensures cleanup when function returns
    doWork(ctx)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_documentation">Documentation</h3>
<div class="ulist">
<ul>
<li>
<p>Go Blog: Context - <a href="https://go.dev/blog/context">Official Go blog post explaining context usage patterns and best practices</a></p>
</li>
<li>
<p>Go Package Documentation: context - <a href="https://pkg.go.dev/context">Official documentation for the context package</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>