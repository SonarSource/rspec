This rule raises an issue when a shell script uses `set -e` to enable automatic error detection and script termination on command failures.

== Why is this an issue?

The `set -e` option was designed to add "automatic error detection" to shell scripts by causing them to abort when any command returns a non-zero exit status. However, this approach has significant problems that make it unreliable for robust error handling.

The behavior of `set -e` is governed by complex and inconsistent rules. For example, commands in conditional statements like `if` tests are immune to `set -e`, as are commands in pipelines except for the last one. These rules are difficult to understand and remember, and they change between different Bash versions as the shell attempts to track the evolving POSIX definition.

The situation becomes even more problematic when subshells are involved, where the behavior varies depending on whether Bash is running in POSIX mode. These inconsistencies mean that scripts relying on `set -e` may behave differently across different environments and Bash versions.

Moreover, `set -e` fails to catch many simple error cases that proper explicit error handling would detect. It creates a false sense of security while actually providing unreliable error detection.

=== What is the potential impact?

Using `set -e` can lead to unreliable error handling in shell scripts. Scripts may fail to detect errors in some contexts while unexpectedly terminating in others. This inconsistent behavior can cause:

* Silent failures where errors go undetected
* Unexpected script termination in cases where the error should be handled gracefully
* Different behavior across different systems or Bash versions
* Difficulty in debugging when the script behaves differently than expected

These issues can result in data loss, incomplete operations, or system instability, particularly in production environments where reliable error handling is critical.

=== How to fix?


Replace `set -e` with explicit error checking using conditional statements. Check the exit status of each critical command and handle errors appropriately.

==== Non-compliant code example

[source,shell,diff-id=1,diff-type=noncompliant]
----
#!/bin/bash
set -e  # Noncompliant

command1
command2
command3
----

==== Compliant code example

[source,shell,diff-id=1,diff-type=compliant]
----
#!/bin/bash

command1 || { echo "command1 failed" >&2; exit 1; }
command2 || { echo "command2 failed" >&2; exit 1; }
command3 || { echo "command3 failed" >&2; exit 1; }
----

=== Documentation

 * Bash FAQ #105: Why doesn't set -e do what I expected? - https://mywiki.wooledge.org/BashFAQ/105[Comprehensive explanation of why set -e is problematic and unreliable]
 * LinuxCommand.org Bash Coding Standards - https://linuxcommand.org/lc3_adv_standards.php[Professional shell scripting standards that recommend against using set -e]

=== Standards

 * CWE-754: Improper Check for Unusual or Exceptional Conditions - https://cwe.mitre.org/data/definitions/754.html[Relates to inadequate error handling that can lead to unexpected program behavior]

