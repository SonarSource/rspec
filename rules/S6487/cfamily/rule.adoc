When using `std::format`, you pass it a format string that contains replacement fields (surrounded with `{}`)
and some extra arguments that will be formatted inside those replacement fields. 
Even if the format string is checked at compile-time, it is possible to have a mismatch between the format string and the arguments:

* The format string contains fewer replacement fields than the number of extra arguments:
  `std::format("{} {}", 1, 2, 3);`
* The format string uses indexes for the replacement fields, but one index is missing:
  `std::format("{0} {0} {2}", 1, 2, 3);`

When that happens, the extra arguments are silently ignored. In the best scenario, it is dead code that could be removed, 
but more probably, it is a typo and the output will not be the expected one.

This rule raises an issue when the unused argument is the result of a complex expression (for instance a function call) or, 
in the case of numbered replacement fields, when in addition of a missing index, another index appears several times.


== Noncompliant Code Example

[source,cpp]
----
std::cout << std::format("{} {}", 1, 2, sqrt(2)); // Noncompliant
std::cout << std::format("{0} {0} {2}", 1, 2, 3); // Noncompliant
----

== Compliant Solution
[source,cpp]
----
std::cout << std::format("{} {} {}", 1, 2, sqrt(2)); // Compliant
std::cout << std::format("{0} {0} {2} {1}", 1, 2, 3); // Compliant
----

== See

* S6488 - A version of that rule that triggers for all unused arguments
