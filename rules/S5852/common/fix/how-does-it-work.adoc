Backtracking causes the engine to partially undo some of the matches that it has made. This has different effects depending on the part of the expression being matched.

* Normal quantifiers (`?`, `*`, `+`, and `{}`) try to match as many characters as possible. During backtracking, the engine will gradually shorten the matched length as it attempts to find a successful path.
* Lazy quantifiers (`??`, `*?`, `+?`, and `{}?`) try to match as few characters as possible. During backtracking, the engine will gradually extend the matched length as it attempts to find a successful path.
* Alternation (`a|b|c`) creates alternative paths for the engine to attempt. During backtracking the engine will try all possible alternatives as it attempts to find a successful path.

Every additional alternative path takes time to evaluate. Regular expressions should minimize the number of paths that can be taken and decrease the number of steps needed to check whether each path is invalid.

==== Possessive quantifiers

Adding a `+` after the standard quantifiers (`?+`, `*+`, `++`, and `{}+`) causes them to become possessive quantifiers. This causes the quantifiers to match as many characters as possible, ignoring any parts of the pattern that are yet to be evaluated.

If the engine needs to backtrack over a possessive match, it must backtrack over the entire match. It cannot split the matched characters in an attempt to find a match. This reduces the number of alternative paths.

==== Atomic grouping

The syntax `(?> ... )` creates an atomic group. As soon as the expression finds a match, evaluation of the expression is stopped and any other possible matches are ignored.

If the engine needs to backtrack over an atomic group, it must backtrack over the entire group. It cannot reevaluate the contents of the group to find alternative paths to match. This reduces the number of alternative paths.

==== Nested quantifiers

Nested quantifiers appear when a quantified term is inside a group that is also quantified. A simple example is the expression `(a+)+`.

Backtracking will change the length of input matched by the inner quantified term. If both the current and next iterations of the group continue to match, it means that the same input can be matched in multiple ways. This creates alternate evaluation paths that can lead to catastrophic backtracking.

Avoid nested quantifiers to prevent this problem from occurring. If they cannot be avoided, ensure that the group has a starting or ending sequence that does not have a quantifier. This reduces the number of iterations that are needed before finding that no match can be made.

==== Delimiters and negated character classes

When using a regular expression with a delimited input, care must be taken to avoid matching the delimiter by mistake. Expressions such as `(.+)=(.+)` can run into problems if the input contains more than one `=` character.

By changing the expression to `([^=]+)=(.+)`, the left side of the expression will stop immediately when a delimiter is found. This reduces the number of false matches and prevents unnecessary backtracking.


==== Quantifiers with match limits

The quantifiers `*`, `+`, and `{min,}` (and their lazy equivalents) have no limit on the number of characters they can match. During backtracking, every one of these characters creates an additional path that must be evaluated. 

Using the `{min,max}` quantifier (or its lazy equivalent) reduces the number of alternative paths that can be created during backtracking.



* Solve the problem without regular expressions
* Use an alternative non-backtracking regex implementations such as Google's https://github.com/google/re2[RE2] or https://github.com/uhop/node-re2/[node-re2].
* Use multiple passes. This could mean pre- and/or post-processing the string manually before/after applying the regular expression to it or using multiple regular expressions. One example of this would be to replace `+str.split(/\s*,\s*/)+` with `+str.split(",")+` and then trimming the spaces from the strings as a second step.
* It is often possible to make the regex infallible by making all the parts that could fail optional, which will prevent backtracking. Of course this means that you'll accept more strings than intended, but this can be handled by using capturing groups to check whether the optional parts were matched or not and then ignoring the match if they weren't. For example the regex `+x*y+` could be replaced with `+x*(y)?+` and then the call to `+str.match(regex)+` could be replaced with `+matched = str.match(regex)+` and  `+matched[1] !== undefined+`.


* Solve the problem without regular expressions
* Use an alternative non-backtracking regex implementations such as Google's https://github.com/google/re2[RE2].
* Use multiple passes. This could mean pre- and/or post-processing the string manually before/after applying the regular expression to it or using multiple regular expressions. One example of this would be to replace ``++re.split("\s*,\s*", my_str)++`` with ``++re.split(",", my_str)++`` and then trimming the spaces from the strings as a second step.
