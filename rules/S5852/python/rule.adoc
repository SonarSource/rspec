include::../common/summary.adoc[]

== Why is this an issue?

include::../common/description.adoc[]

== How to fix it

include::../common/fix/how-to-fix-it.adoc[]

Sometimes it is not possible to rewrite the regex to be linear while still matching what you want it to match. This can be especially difficult when matching only part of the input. If you cannot simplify the regular expression, consider one of the following approaches:

* Solve the problem without regular expressions.
* Use an alternative non-backtracking engine such as Google's https://github.com/google/re2[RE2].
* Use multiple passes. This could mean pre- and/or post-processing the string manually before/after applying the regular expression to it or using multiple regular expressions.
** For example, replace ``++re.split("\s*,\s*", my_str)++`` with ``++re.split(",", my_str)++`` and then trim the spaces from the strings as a second step.
* When using ``++re.match()++``, it is often possible to make the regex infallible by making all the parts that could fail optional. This prevents backtracking but could result in matching values that are not acceptable. Further processing will be needed to find the acceptable values.
** For example the regex `++x*y++` could be replaced with ``++x*(y)?++`` and then the call to ``++re.match(value)++`` could be replaced with ``++match = re.match(value)++`` and ``++match[1] is not None++``.

=== Code examples

==== Noncompliant code example

[source,python,diff-id=1,diff-type=noncompliant]
----
import re;

pattern = re.compile("^(a+)+$");  // Noncompliant
pattern.match(
"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"+
"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"+
"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"+
"aaaaaaaaaaaaaaa!");
----

==== Compliant solution

Possessive quantifiers do not keep backtracking positions, so can be used to avoid performance issues. Possessive quantifiers are supports from Python 3.11 onwards.

[source,python,diff-id=1,diff-type=compliant]
----
import re;

pattern = re.compile("^(a+)++$");
pattern.match(
"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"+
"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"+
"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"+
"aaaaaaaaaaaaaaa!");
----

=== How does this work?

include::../common/fix/how-does-it-work.adoc[]


== Resources

=== Documentation

include::../common/resources/documentation.adoc[]

=== Articles & blog posts

include::../common/resources/articles.adoc[]

=== Standards

include::../common/resources/standards.adoc[]


ifdef::env-github,rspecator-view[]

'''
== Implementation Specification
(visible only on this page)

include::../common/message.adoc[]

'''
== Comments And Links
(visible only on this page)

include::../common/comments-and-links.adoc[]

endif::env-github,rspecator-view[]
