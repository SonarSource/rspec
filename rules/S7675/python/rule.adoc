This is an issue when a local Python file, directory, or package uses the same name as a well-known library or standard library module.

== Why is this an issue?

Python's import system searches for modules in a specific order, starting with the current directory. When a local file or directory has the same name as a popular package, Python imports the local module instead of the intended library.

This creates several problems:

* *Import conflicts*: The local module is imported instead of the intended library
* *AttributeError exceptions*: The local module lacks the expected attributes and methods
* *Unexpected behavior*: Code that should work with the real library fails silently or crashes
* *Debugging confusion*: Developers may spend time troubleshooting library issues when the problem is actually module shadowing

For example, if you create a file named `torch.py` and then try to `import torch`, Python will import your local file instead of the PyTorch library. When you try to use PyTorch functions like `torch.device()`, you'll get an AttributeError because your local file doesn't have these methods.

This issue is particularly common with popular data science and machine learning libraries like NumPy, Pandas, and PyTorch, as well as standard library modules like `os`, `sys`, and `json`.

=== What is the potential impact?

This can cause application crashes, unexpected behavior, and significant debugging time. In development environments, it may prevent proper testing of library integrations. In production, it could lead to runtime failures when the application tries to use library functions that don't exist in the shadowing module.

=== How to fix?


Rename the local file to use a more descriptive, non-conflicting name that clearly indicates its purpose.

==== Non-compliant code example

[source,python,diff-id=1,diff-type=noncompliant]
----
# File: torch.py
import torch  # Noncompliant: imports this file instead of PyTorch

def my_function():
    # This will fail with AttributeError
    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
    return device
----

==== Compliant code example

[source,python,diff-id=1,diff-type=compliant]
----
# File: neural_network_utils.py
import torch  # Now correctly imports PyTorch

def my_function():
    # torch.device is available from the real PyTorch library
    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
    return device
----

=== Documentation

 * Python Import System - https://docs.python.org/3/reference/import.html[Official Python documentation on how the import system works]
 * Python Module Search Path - https://docs.python.org/3/tutorial/modules.html#the-module-search-path[Explanation of how Python searches for modules]

