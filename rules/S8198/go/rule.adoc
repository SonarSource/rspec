This rule raises an issue when unsafe pointer arithmetic is used to calculate pointers that extend beyond the boundaries of their original allocated objects.

== Why is this an issue?

In Go, unlike C, it is invalid to advance a pointer beyond the end of its original allocation. This restriction exists to maintain memory safety and prevent undefined behavior.

When you use `unsafe.Pointer` with arithmetic operations, the resulting pointer must always point within the original allocated object. Calculating "end" pointers that point outside the allocated space violates Go's memory model and can lead to:

* Memory access violations
* Unpredictable program behavior
* Potential security vulnerabilities
* Garbage collector interference

The Go runtime and garbage collector assume that all pointers reference valid memory locations within allocated objects. Pointers that extend beyond these boundaries can confuse the garbage collector and lead to memory corruption.

=== What is the potential impact?

Violating pointer arithmetic rules can cause memory access violations, unpredictable program behavior, and potential security vulnerabilities. The garbage collector may also behave incorrectly when encountering invalid pointers, leading to memory corruption or crashes.

== How to fix it

Use `unsafe.Offsetof()` to access fields within structs, ensuring pointers remain within allocated boundaries. Avoid calculating end pointers that extend beyond the object's allocated space.

=== Code examples

==== Noncompliant code example

[source,go,diff-id=1,diff-type=noncompliant]
----
// INVALID: end points outside allocated space
var s MyStruct
end := unsafe.Pointer(uintptr(unsafe.Pointer(&s)) + unsafe.Sizeof(s)) // Noncompliant
----

==== Compliant solution

[source,go,diff-id=1,diff-type=compliant]
----
// Valid: pointer stays within allocated object
var s MyStruct
field := unsafe.Pointer(uintptr(unsafe.Pointer(&s)) + unsafe.Offsetof(s.Field))
----

== Resources

=== Documentation

 * Go unsafe package documentation - https://pkg.go.dev/unsafe[Official Go documentation for the unsafe package, including valid pointer arithmetic patterns]

 * Go Memory Model - https://go.dev/ref/mem[The Go memory model specification explaining memory safety guarantees]

=== Standards

 * CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer - https://cwe.mitre.org/data/definitions/119.html[Covers buffer boundary violations that can lead to memory corruption]

=== Related rules

 * RSPEC-3519 - https://rules.sonarsource.com/c/RSPEC-3519[C/C++ rule for pointer arithmetic beyond array bounds]
