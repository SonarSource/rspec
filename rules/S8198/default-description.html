<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This rule raises an issue when unsafe pointer arithmetic is used to calculate pointers that extend beyond the boundaries of their original allocated objects.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In Go, unlike C, it is invalid to advance a pointer beyond the end of its original allocation. This restriction exists to maintain memory safety and prevent undefined behavior.</p>
</div>
<div class="paragraph">
<p>When you use <code>unsafe.Pointer</code> with arithmetic operations, the resulting pointer must always point within the original allocated object. Calculating "end" pointers that point outside the allocated space violates Go&#8217;s memory model and can lead to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Memory access violations</p>
</li>
<li>
<p>Unpredictable program behavior</p>
</li>
<li>
<p>Potential security vulnerabilities</p>
</li>
<li>
<p>Garbage collector interference</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The Go runtime and garbage collector assume that all pointers reference valid memory locations within allocated objects. Pointers that extend beyond these boundaries can confuse the garbage collector and lead to memory corruption.</p>
</div>
<div class="sect2">
<h3 id="_what_is_the_potential_impact">What is the potential impact?</h3>
<div class="paragraph">
<p>Violating pointer arithmetic rules can cause memory access violations, unpredictable program behavior, and potential security vulnerabilities. The garbage collector may also behave incorrectly when encountering invalid pointers, leading to memory corruption or crashes.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_fix_it">How to fix it</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Use <code>unsafe.Offsetof()</code> to access fields within structs, ensuring pointers remain within allocated boundaries. Avoid calculating end pointers that extend beyond the object&#8217;s allocated space.</p>
</div>
<div class="sect2">
<h3 id="_code_examples">Code examples</h3>
<div class="sect3">
<h4 id="_noncompliant_code_example">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-go" data-lang="go">// INVALID: end points outside allocated space
var s MyStruct
end := unsafe.Pointer(uintptr(unsafe.Pointer(&amp;s)) + unsafe.Sizeof(s)) // Noncompliant</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-go" data-lang="go">// Valid: pointer stays within allocated object
var s MyStruct
field := unsafe.Pointer(uintptr(unsafe.Pointer(&amp;s)) + unsafe.Offsetof(s.Field))</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_documentation">Documentation</h3>
<div class="ulist">
<ul>
<li>
<p>Go unsafe package documentation - <a href="https://pkg.go.dev/unsafe">Official Go documentation for the unsafe package, including valid pointer arithmetic patterns</a></p>
</li>
<li>
<p>Go Memory Model - <a href="https://go.dev/ref/mem">The Go memory model specification explaining memory safety guarantees</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_standards">Standards</h3>
<div class="ulist">
<ul>
<li>
<p>CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer - <a href="https://cwe.mitre.org/data/definitions/119.html">Covers buffer boundary violations that can lead to memory corruption</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_related_rules">Related rules</h3>
<div class="ulist">
<ul>
<li>
<p><a data-rspec-id="S3519" class="rspec-auto-link">RSPEC-3519</a> - <a href="https://rules.sonarsource.com/c/RSPEC-3519">C/C++ rule for pointer arithmetic beyond array bounds</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>