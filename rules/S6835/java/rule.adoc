The `@Autowired` annotation ensures that beans are correctly injected into fields.
However,  Java field initialization has precedence over Spring's auto-wiring mechanism.

== Why is this an issue?

The inline initialization of a field depending on the value of another `autowired` field will recover a null value and/or potentially throw a `NullPointerException`.

=== What is the potential impact?

Your application may fail:

* at startup time, if a bean depends on an object with a field depending on another auto-wired field
* at request time, if your request handler creates an object with a field depending on another auto-wired field


== How to fix it

Do not rely on `@Autowired` values for the initialization of other instance fields.
Prefer setting the field value within the constructor.

=== Code examples

==== Noncompliant code example

[source,java,diff-id=1,diff-type=noncompliant]
----
class Connection {
    @Autowired
    private NetworkConfiguration configuration;

    private String address = configuration.getAddress(); // Noncompliant, will throw an NPE

    private int port = configuration.getPort(); // Noncompliant, will throw an NPE
}
----

==== Compliant solution

[source,java,diff-id=1,diff-type=compliant]
----
class Connection {
    private NetworkConfiguration configuration;
    private String address;
    private int port;

    @Autowired
    public Connection(NetworkConfiguration configuration) {
        this.configuration = configuration;
        this.address = configuration.getAddress();
        this.port = configuration.getPort();
    }
}
----

//=== How does this work?

//=== Pitfalls

//=== Going the extra mile


== Resources
=== Documentation
https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/annotation/Autowired.html[Autowired javadoc]
//=== Articles & blog posts
//=== Conference presentations
//=== Standards
//=== External coding guidelines
//=== Benchmarks
