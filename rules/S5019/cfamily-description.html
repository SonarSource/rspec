<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A lambda can only capture local variables. When a lambda is defined within a member function, you may believe that you are capturing a member variable of the current class, but in fact, what you are capturing is <code>this</code>. This may be very surprising, and lead to bugs if the lambda is then used after the current object has been destroyed.</p>
</div>
<div class="paragraph">
<p>Therefore, it&#8217;s better to be explicit about exactly what is captured as soon as <code>this</code> is captured.</p>
</div>
<div class="paragraph">
<p>If the lambda is used immediately (for instance, called or passed as an argument to <code>std::sort</code>), there is no such risk and no issue is raised.</p>
</div>
<div class="paragraph">
<p>In C&#43;&#43;20, capturing <code>this</code> via [=] has been deprecated. An issue is raised in that case, even if the lambda is used immediately.</p>
</div>
<div class="paragraph">
<p>Note: This rule does not apply if the capture list of the lambda contains <code>*this</code> (possible since C&#43;&#43;17). In that situation, what is captured is not the pointer <code>this</code>, but a local copy of the object pointed-to by <code>this</code> and any reference to <code>this</code> (explicit or implicit) in the lambda body then refers to this local copy (see <a data-rspec-id="S6016" class="rspec-auto-link">S6016</a>).</p>
</div>
<div class="sect2">
<h3 id="_noncompliant_code_example">Noncompliant code example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">void useLambda(std::function&lt;int,int&gt; lambda);

class A {
  int i;
  void f(int j) {
    auto l = [=](int k) { return i+j+k;}; // Noncompliant, someone reading the code might believe that i is captured by copy
    useLambda(l);
  }
};</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_compliant_solution">Compliant solution</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">void useLambda(std::function&lt;int,int&gt; lambda);

class A {
  int i;
  void f(int j) {
    auto l = [this, j](int k) { return i+j+k;}; // It is now clearer that i is not directly captured
    useLambda(l);
    // auto l = [i, j](int k) { return i+j+k;}; // Would not compile

    auto l2 = [=, *this](int k) { return i+j+k;}; // Compliant, i refers to the member i of the captured copy
    useLambda(l2);

    auto l3 = [=](int k) { return i+j+k;}; // Compliant because l3 is only used immediately
    int ijk = l3(i,j,k);
  }
};</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>C&#43;&#43; Core Guidelines - <a href="https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f54-when-writing-a-lambda-that-captures-this-or-any-class-data-member-dont-use--default-capture">F.54: When writing a lambda that captures <code>this</code> or any class data member, don&#8217;t use <code>[=]</code> default capture</a></p>
</li>
</ul>
</div>
<hr>
</div>
</div>
<div class="sect1">
<h2 id="_implementation_specification">Implementation Specification</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_message">Message</h3>
<div class="paragraph">
<p>Explicitly capture all local variables required in this lambda.</p>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_comments_and_links">Comments And Links</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_on_8_nov_2018_192955_ann_campbell_wrote">on 8 Nov 2018, 19:29:55 Ann Campbell wrote:</h3>
<div class="paragraph">
<p>\[~loic.joly] please double-check "this" RSpec against <a data-rspec-id="S3608" class="rspec-auto-link">RSPEC-3608</a>. Without closely reading both I think there may be overlap if not duplication.</p>
</div>
</div>
<div class="sect2">
<h3 id="_on_8_nov_2018_193841_loïc_joly_wrote">on 8 Nov 2018, 19:38:41 Loïc Joly wrote:</h3>
<div class="paragraph">
<p>\[~ann.campbell.2] There is overlap, but I believe that <a data-rspec-id="S3608" class="rspec-auto-link">RSPEC-3608</a> is much too strict (even if something similar could appear in the next Misra standard), and I would clearly not enable it in one of my codebases, while I would enable this one.</p>
</div>
<div class="paragraph">
<p>I&#8217;m also thinking one another related rule, which would be something like "Lambdas that outlive their definition scope should not implicitely capture by reference". If I can have this one, I will probably remove <a data-rspec-id="S3608" class="rspec-auto-link">RSPEC-3608</a> from SonarWay.</p>
</div>
</div>
</div>
</div>