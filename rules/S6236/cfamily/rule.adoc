{cpp}11 introduced the concept of _forwarding-reference_, as a way to transfer types effectively. 
In combination with `std::forward`, their usage allows passing values without unnecessary copies.

The expression ``std::forward<T>(obj).mem``, can be used to forward the value of the member, according to the type of `obj`:
move the member if the obj is an rvalue reference, and copy otherwise. 
However, in the corner case, when member mem is of rvalue reference type, member `mem` will be copied even if `obj` is an rvalue.
Detecting the program is affected by this nuance is not trivial and best left to the tools.

This rule raises issues for templates, that are instantiated with types that lead to an accidental copy of forwarded members.

== Noncompliant Code Example

----
template<typename... Ts>
void consume(Ts&&... ts)


template<typename T, typename U>
void consumePair(std::pair<T, U>&& p) {
  cosume(std::move(p).first, std::move(p.second)); // Noncomplaint
}
void use1() {
  std::string  x = 0, y = 1;
  std::pair<std:string&&, std::string&&> rRefPair(std::ref(x), std::ref(y));
  consumePair(std::move(rRefPair)); // Triggers non-complaint instantation of consumePair
                                    // with T = std:::string&& and U = std::string&&
}

template<typename Pair>
void forwardPair(Pair&& p) {
  cosume(std::forward<T>(p).first, std::forward<T>(p).second); // Noncomplaint
}
void use2() {
  std::string  x = 0, y = 1;
  std::pair<std:string&&, std::string&&> rRefPair(std::ref(x), std::ref(y));
  forwardPair(rRefPair); // OK, lvalue is passed
  forwardPair(std::move(rRefPair)); // Triggers non-complaint instantation of forwardPair
                                    // with Pair = std::pair<std:string&&, std::string&&>
}

template<typename Pair>
void forwardStruct(T&& p) {
    cosume(std::forward<T>(p).mem); // Noncomplaint
}

struct Proxy {
    std::vector<int>& mem;
};
void use3() {
  std::vector<int> v;
  Proxy proxy{v};
  forwardStruct(proxy); // OK, lvalue is passed
  forwardStruct(std::move(proxy)); // Triggers non-complaint instantation of forwardStruct
                                   // with T = Proxy&&

}
----


== Compliant Solution

----
template<typename T, typename U>
void consumePair(std::pair<T, U>&& p) {
    cosume(std::get<0>(std::move(p)), std::get<0>(std::move(p)));
}

template<typename Pair>
void forwardPair(Pair&& p) {
    cosume(std::get<0>(std::forward<T>(p)), std::get<0>(std::forward<T>(p)));
}

template<typename Pair>
void forwardStruct(T&& t) {
  constexpr bool isMoveOfRvalueReferenceMember 
      = std::is_rvalue_reference_v<decltype(t.mem)> && std::is_rvalue_reference_v<T&&>;
  if constexpr (isMoveOfRvalueReferenceMember) {
    cosume(std::move(t.mem));
  } else {
    cosume(std::forward<T>(t).mem);
  }
}
----


