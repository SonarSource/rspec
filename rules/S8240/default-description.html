<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This is an issue when checking if a process is still running using immediate status checks like <code>Process.Signal(syscall.Signal(0))</code> instead of proper synchronization mechanisms.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Immediate process status checks create race conditions with the operating system&#8217;s process cleanup mechanisms. When a process terminates, there&#8217;s a window where the process struct might still exist in memory even though the process has actually died. During this time, status checks can incorrectly report the process as still running.</p>
</div>
<div class="paragraph">
<p>Additionally, if you wait and perform the check later, the process ID (PID) might have been reused by the operating system for a completely different process. This means your status check could be testing an entirely different process than intended.</p>
</div>
<div class="paragraph">
<p>These race conditions are particularly problematic on Windows systems, where process cleanup timing can be less predictable. The result is unreliable process management that can lead to incorrect program behavior, resource leaks, or failed cleanup operations.</p>
</div>
<div class="sect2">
<h3 id="_what_is_the_potential_impact">What is the potential impact?</h3>
<div class="paragraph">
<p>Race conditions in process status checking can lead to unreliable process management, causing applications to make incorrect decisions about process lifecycle. This can result in resource leaks, failed cleanup operations, or attempts to interact with the wrong process due to PID reuse.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_fix_it">How to fix it</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Use a goroutine with <code>Process.Wait()</code> and channels to properly synchronize process status checking. This approach waits for the actual process termination signal from the OS rather than racing with cleanup operations.</p>
</div>
<div class="sect2">
<h3 id="_code_examples">Code examples</h3>
<div class="sect3">
<h4 id="_noncompliant_code_example">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-go" data-lang="go">// Immediate check races with OS cleanup
err := targetCmd.Process.Signal(syscall.Signal(0))
if err != nil {
    // Process might still be terminating // Noncompliant
    fmt.Println("Process terminated")
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-go" data-lang="go">// Use goroutine and channel for proper synchronization
done := make(chan bool)
go func() {
    targetCmd.Process.Wait()
    close(done)
}()

select {
case &lt;-done:
    // Process has actually terminated
    fmt.Println("Process terminated")
case &lt;-time.After(500 * time.Millisecond):
    // Process still running after timeout
    fmt.Println("Process still running")
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_documentation">Documentation</h3>
<div class="ulist">
<ul>
<li>
<p>Go os.Process documentation - <a href="https://pkg.go.dev/os#Process">Official documentation for Go&#8217;s Process type and its methods</a></p>
</li>
<li>
<p>Go Concurrency Patterns - <a href="https://go.dev/blog/pipelines">Guide to Go concurrency patterns including channels and goroutines</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>