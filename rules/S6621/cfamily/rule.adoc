== Why is this an issue?

{cpp}20 version of the standard introduces the ``++consteval++`` keyword, allowing for enforcing compile time evaluation.


Specifically, a function that is specified as ``++constexpr++`` will be evaluated at compile-time, where possible. This may lead to undesired runtime calls (i.e. throwing an exception inside a constexpr function).


In the case of user-defined literal operators, the parameters of said functions is always constant and known at compile time. Therefore, if these are intended to be evaluated at compile time with ``++constexpr++``, ``++consteval++`` should be used instead to enforce compile time evaluation. By doing this, unnecessary calls can be avoided, and errors can be detected at compilation.


==== Noncompliant code example

[source,cpp]
----
#include <stdexcept>

constexpr unsigned char operator ""_u8(unsigned long long value) {
  if (value >= 256u) { throw std::overflow_error("Overflow on literal"); }
  return static_cast<unsigned char>(value);
}

void f() {
  unsigned char const a = 128_u8; // evaluated at compile time
  unsigned char const b = 512_u8; // evaluated at runtime
}
----

==== Compliant solution

[source,cpp]
----
#include <stdexcept>

consteval unsigned char operator ""_u8(unsigned long long value) {
  if (value >= 256u) { throw std::overflow_error("Overflow on literal"); }
  return static_cast<unsigned char>(value);
}

void f() {
  unsigned char const a = 128_u8; // evaluated at compile time
  unsigned char const b = 512_u8; // compilation error
}
----
