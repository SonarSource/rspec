== Why is this an issue?

{cpp}20  introduces the `consteval` keyword which enforces that a function is always evaluated at compile time.


`constexpr` functions can produce a compile-time constant in some contexts and when they are called with appropriate arguments, but they can also be invoked at run-time. `consteval` functions always be evaluated at compile-time and, if that cannot happen, a compilation error will occur.


User-defined literal operators are designed to be called with constant operands known at compile time. Therefore, if these are intended to be evaluated at compile time with `constexpr`, `consteval` should be used instead to enforce compile time evaluation. By doing this, unnecessary calls can be avoided, and errors can be detected at compilation.


=== Noncompliant code example

[source,cpp]
----
#include <stdexcept>

constexpr unsigned char operator ""_u8(unsigned long long value) {
  if (value >= 256u) { throw std::overflow_error("Overflow on literal"); }
  return static_cast<unsigned char>(value);
}

void f() {
  unsigned char const a = 128_u8; // evaluated at compile time
  unsigned char const b = 512_u8; // evaluated at runtime, throws when evaluated
}
----

=== Compliant solution

[source,cpp]
----
#include <stdexcept>

consteval unsigned char operator ""_u8(unsigned long long value) {
  if (value >= 256u) { throw std::overflow_error("Overflow on literal"); }
  return static_cast<unsigned char>(value);
}

void f() {
  unsigned char const a = 128_u8; // evaluated at compile time
  unsigned char const b = 512_u8; // compilation error
}
----
