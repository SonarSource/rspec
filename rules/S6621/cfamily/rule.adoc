== Why is this an issue?

{cpp}20  introduces the `consteval` keyword which enforces that a function is always evaluated at compile time.


Unlike calls to ``++constexpr++`` functions, that are treated as ``++inline++`` when they cannot produce a compile time constant expression, calls to ``++consteval++`` functions must always produce a constant expression.


If a call is made to a ``++consteval++`` function that cannot produce a compile time constant expression, a compilation error will occur.


In the case of user-defined literal operators, the parameters of said functions is always constant and known at compile time. Therefore, if these are intended to be evaluated at compile time with ``++constexpr++``, ``++consteval++`` should be used instead to enforce compile time evaluation. By doing this, unnecessary calls can be avoided, and errors can be detected at compilation.


=== Noncompliant code example

[source,cpp]
----
#include <stdexcept>

constexpr unsigned char operator ""_u8(unsigned long long value) {
  if (value >= 256u) { throw std::overflow_error("Overflow on literal"); }
  return static_cast<unsigned char>(value);
}

void f() {
  unsigned char const a = 128_u8; // evaluated at compile time
  unsigned char const b = 512_u8; // evaluated at runtime
}
----

=== Compliant solution

[source,cpp]
----
#include <stdexcept>

consteval unsigned char operator ""_u8(unsigned long long value) {
  if (value >= 256u) { throw std::overflow_error("Overflow on literal"); }
  return static_cast<unsigned char>(value);
}

void f() {
  unsigned char const a = 128_u8; // evaluated at compile time
  unsigned char const b = 512_u8; // compilation error
}
----
