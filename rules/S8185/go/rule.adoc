This rule raises an issue when multiple test functions test the same function with different input/output combinations, following a similar testing pattern.

== Why is this an issue?

Table-driven tests are a Go testing best practice that improves code maintainability and readability. When you have multiple test functions that follow the same pattern - calling the same function with different inputs and checking different expected outputs - you end up with duplicated test logic.

This duplication makes your tests harder to maintain. If you need to change the test logic (for example, to add better error messages or modify the assertion style), you have to update multiple functions. This increases the chance of inconsistencies and makes the codebase more verbose.

Table-driven tests solve this by consolidating all test cases into a single function with a slice of test data. Each test case is defined as a struct containing the inputs and expected outputs. The test function then iterates over this data, running the same test logic for each case.

This approach offers several benefits:

* *Reduced duplication*: The test logic is written once and reused for all cases
* *Easier maintenance*: Changes to test logic only need to be made in one place
* *Better readability*: Test cases are clearly organized in a structured format
* *Easier to add cases*: New test scenarios can be added by simply adding entries to the test data
* *Consistent error reporting*: All test cases use the same error message format

=== What is the potential impact?

This issue affects code maintainability and testing efficiency. While not a security concern, it leads to more verbose test suites that are harder to maintain and extend. Developers spend more time updating multiple similar test functions instead of focusing on comprehensive test coverage.

== How to fix it

Consolidate multiple similar test functions into a single table-driven test. Create a slice of test cases with input parameters and expected outputs, then iterate over them in a single test function.

=== Code examples

==== Noncompliant code example

[source,go,diff-id=1,diff-type=noncompliant]
----
func TestAdd(t *testing.T) {
    if Add(2, 3) != 5 {
        t.Error("Expected 5")
    }
}

func TestAddNegative(t *testing.T) { // Noncompliant
    if Add(-1, 1) != 0 {
        t.Error("Expected 0")
    }
}

func TestAddZero(t *testing.T) { // Noncompliant
    if Add(0, 5) != 5 {
        t.Error("Expected 5")
    }
}
----

==== Compliant solution

[source,go,diff-id=1,diff-type=compliant]
----
func TestAdd(t *testing.T) {
    tests := []struct {
        name     string
        a, b     int
        expected int
    }{
        {"positive numbers", 2, 3, 5},
        {"negative and positive", -1, 1, 0},
        {"zero and positive", 0, 5, 5},
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            if got := Add(tt.a, tt.b); got != tt.expected {
                t.Errorf("Add(%d, %d) = %d, want %d", tt.a, tt.b, got, tt.expected)
            }
        })
    }
}
----

== Resources

=== Documentation

 * Go Wiki: TableDrivenTests - https://go.dev/wiki/TableDrivenTests[Official Go documentation on table-driven testing patterns and best practices]

 * Go Testing Package - https://pkg.go.dev/testing[Official documentation for Go's testing package, including subtests with t.Run]

=== Related rules

 * RSPEC-5976 - https://rules.sonarsource.com/java/RSPEC-5976[Similar rule for Java test consolidation]
