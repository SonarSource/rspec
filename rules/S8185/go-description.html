<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This rule raises an issue when multiple test functions test the same function with different input/output combinations, following a similar testing pattern.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Table-driven tests are a Go testing best practice that improves code maintainability and readability. When you have multiple test functions that follow the same pattern - calling the same function with different inputs and checking different expected outputs - you end up with duplicated test logic.</p>
</div>
<div class="paragraph">
<p>This duplication makes your tests harder to maintain. If you need to change the test logic (for example, to add better error messages or modify the assertion style), you have to update multiple functions. This increases the chance of inconsistencies and makes the codebase more verbose.</p>
</div>
<div class="paragraph">
<p>Table-driven tests solve this by consolidating all test cases into a single function with a slice of test data. Each test case is defined as a struct containing the inputs and expected outputs. The test function then iterates over this data, running the same test logic for each case.</p>
</div>
<div class="paragraph">
<p>This approach offers several benefits:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Reduced duplication</strong>: The test logic is written once and reused for all cases</p>
</li>
<li>
<p><strong>Easier maintenance</strong>: Changes to test logic only need to be made in one place</p>
</li>
<li>
<p><strong>Better readability</strong>: Test cases are clearly organized in a structured format</p>
</li>
<li>
<p><strong>Easier to add cases</strong>: New test scenarios can be added by simply adding entries to the test data</p>
</li>
<li>
<p><strong>Consistent error reporting</strong>: All test cases use the same error message format</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_what_is_the_potential_impact">What is the potential impact?</h3>
<div class="paragraph">
<p>This issue affects code maintainability and testing efficiency. While not a security concern, it leads to more verbose test suites that are harder to maintain and extend. Developers spend more time updating multiple similar test functions instead of focusing on comprehensive test coverage.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_fix_it">How to fix it</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Consolidate multiple similar test functions into a single table-driven test. Create a slice of test cases with input parameters and expected outputs, then iterate over them in a single test function.</p>
</div>
<div class="sect2">
<h3 id="_code_examples">Code examples</h3>
<div class="sect3">
<h4 id="_noncompliant_code_example">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-go" data-lang="go">func TestAdd(t *testing.T) {
    if Add(2, 3) != 5 {
        t.Error("Expected 5")
    }
}

func TestAddNegative(t *testing.T) { // Noncompliant
    if Add(-1, 1) != 0 {
        t.Error("Expected 0")
    }
}

func TestAddZero(t *testing.T) { // Noncompliant
    if Add(0, 5) != 5 {
        t.Error("Expected 5")
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-go" data-lang="go">func TestAdd(t *testing.T) {
    tests := []struct {
        name     string
        a, b     int
        expected int
    }{
        {"positive numbers", 2, 3, 5},
        {"negative and positive", -1, 1, 0},
        {"zero and positive", 0, 5, 5},
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            if got := Add(tt.a, tt.b); got != tt.expected {
                t.Errorf("Add(%d, %d) = %d, want %d", tt.a, tt.b, got, tt.expected)
            }
        })
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_documentation">Documentation</h3>
<div class="ulist">
<ul>
<li>
<p>Go Wiki: TableDrivenTests - <a href="https://go.dev/wiki/TableDrivenTests">Official Go documentation on table-driven testing patterns and best practices</a></p>
</li>
<li>
<p>Go Testing Package - <a href="https://pkg.go.dev/testing">Official documentation for Go&#8217;s testing package, including subtests with t.Run</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_related_rules">Related rules</h3>
<div class="ulist">
<ul>
<li>
<p><a data-rspec-id="S5976" class="rspec-auto-link">RSPEC-5976</a> - <a href="https://rules.sonarsource.com/java/RSPEC-5976">Similar rule for Java test consolidation</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>