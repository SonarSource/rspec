<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Possessive quantifiers in Regex patterns like below improve performance by eliminating needless backtracking:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>?+ , *+ , ++ , {n}+ , {n,}+ , {n,m}+</pre>
</div>
</div>
<div class="paragraph">
<p>But because possessive quantifiers do not keep backtracking positions and never give back, the following sub-patterns should not match only similar characters. Otherwise, possessive quantifiers consume all characters that could have matched the following sub-patterns and nothing remains for the following sub-patterns.</p>
</div>
<div class="sect2">
<h3 id="_noncompliant_code_example">Noncompliant code example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">import re
pattern1 = re.compile(r"a++abc", re.DOTALL) # Noncompliant, the second 'a' never matches
pattern2 = re.compile(r"\d*+[02468]", re.DOTALL) # Noncompliant, the sub-pattern "[02468]" never matches</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_compliant_solution">Compliant solution</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">import re
pattern1 = re.compile(r"aa++bc", re.DOTALL) # Compliant, for example it can match "aaaabc"
pattern2 = re.compile(r"\d*+(?&lt;=[02468])", re.DOTALL) # Compliant, for example, it can match an even number like "1234"</code></pre>
</div>
</div>
</div>
</div>
</div>