This rule raises an issue when Go tests are executed without the `-race` flag, which means potential race conditions in concurrent code may go undetected.

== Why is this an issue?

Race conditions are among the most challenging bugs to detect and debug in concurrent programs. They occur when multiple goroutines access shared data simultaneously without proper synchronization, leading to unpredictable behavior that may only manifest under specific timing conditions.

Go's built-in race detector is a powerful tool that instruments memory accesses to identify when shared variables are accessed concurrently without synchronization. However, it only works when explicitly enabled with the `-race` flag during compilation and execution.

Without race detection enabled during testing:

* Race conditions may remain hidden during development and testing phases
* Bugs can surface unpredictably in production environments under different load conditions
* Data corruption or incorrect calculations may occur silently
* Debugging becomes significantly more difficult once issues reach production

The race detector adds runtime overhead (typically 5-10x slower execution and higher memory usage), making it impractical for production use. However, this overhead is acceptable during testing phases where catching concurrency bugs early provides immense value.

Running tests with race detection is particularly important for:

* Code that uses goroutines and shared state
* Libraries and frameworks that will be used in concurrent contexts
* Integration tests that exercise concurrent code paths
* Load tests that simulate realistic concurrent usage patterns

=== What is the potential impact?

Race conditions can lead to:

* **Data corruption**: Concurrent writes to shared variables can result in partially written or inconsistent data
* **Incorrect results**: Race conditions in calculations or business logic can produce wrong outcomes
* **Unpredictable failures**: Applications may work correctly most of the time but fail intermittently under load
* **Security vulnerabilities**: Race conditions can sometimes be exploited to bypass security checks or cause privilege escalation
* **Difficult debugging**: Race-related bugs are notoriously hard to reproduce and debug in production environments

== How to fix it

Add the `-race` flag to your `go test` commands to enable race detection during testing.

=== Code examples

==== Noncompliant code example

[source,bash,diff-id=1,diff-type=noncompliant]
----
go test ./...
----

==== Compliant solution

[source,bash,diff-id=1,diff-type=compliant]
----
go test -race ./...
----

== Resources

=== Documentation

 * Go Race Detector - https://go.dev/doc/articles/race_detector[Official Go documentation on the race detector tool]

 * Introducing the Go Race Detector - https://go.dev/blog/race-detector[Go blog post introducing the race detector with examples]

 * Go Testing Package - https://pkg.go.dev/testing[Official documentation for Go's testing package]

=== Standards

 * CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization - https://cwe.mitre.org/data/definitions/362.html[Common weakness enumeration for race condition vulnerabilities]
