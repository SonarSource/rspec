Do not deallocate the same object twice to avoid "double-free" undefined behavior.

== Why is this an issue?

Using `delete` or `free(...)` releases the reservation on a memory location, making it immediately available for another purpose.
Releasing the same pointer twice is undefined behavior and will usually crash the program.

=== What is the potential impact

The effects of a "double-free" heavily depend on how the program's memory management data structures are implemented.
In the case of such a scenario, one of the following can be observed:

- The program's memory management data structures can become corrupted.
This will usually cause a crash.
- In specific circumstances, corruption of mentioned data structures can cause two later calls to malloc to return the same pointer.
This can lead to a buffer overflow vulnerability.
- The {cpp} standard defines the first `delete` call as the end of the lifetime for dynamically allocated memory.
Any access to that memory past its lifetime end, including another `delete`, is undefined behavior.
As a result, a second call can be optimized out, leading to hard-to-identify bugs.

== How to fix it

Besides just ensuring that every release happens once, the following best practices can also be used:

- After a `delete` or `free`, set the pointer's value to `nullptr` or `NULL`.
`delete` of `nullptr` and `free` of `NULL` are defined as having no effect.
- Attempt to release any allocated memory in the function it was allocated in.
- If lifetime of memory is tied to an object, use smart pointers.
These will manage the lifetime of the required memory without any "double-free" risk.

=== Code examples

==== C Noncompliant code

[source,cpp]
----
void doSomething(int size) {
  char* cp = (char*) malloc(sizeof(char) * size);

  // ...
  if (condition) {
    free(cp);
  }

  free(cp);  // Noncompliant
}
----


=== C Compliant solution

[source,cpp]
----
void doSomething(int size) {
  char* cp = (char*) malloc(sizeof(char) * size);

  // ...
  if (condition) {
    free(cp);
    cp = NULL; // This will prewent freeing the same memory again
  }

  free(cp); // This is OK: if the memory was freed in the if-block above, free(NULL) is a no-op
  cp = NULL; // This will prevent freeing the same memory again
}
----

==== {cpp} Noncompliant code

[source,cpp]
----
void doSomething(int size) {
  std::string* p = new std::string;

  // ...
  if (condition) {
    delete p;
  }

  delete p;  // Noncompliant
}
----

==== {cpp} Compliant solutions

Set to null:

[source,cpp]
----
void doSomething(int size) {
  std::string* p = new std::string;

  // ...
  if (condition) {
    delete p;
    p = nullptr; // This will prevent freeing the same memory again
  }

  delete p; // This is OK: if the memory was freed in the if-block above, operator delete of nullptr is a no-op
  p = nullptr; // This will prevent freeing the same memory again
}
----

Smart pointers:

[source,cpp]
----
void doSomething(int size) {
  auto p = std::make_unique<std::string>();

  // ...
  if (condition) {
    p.reset(); // Delete happens here.
  }

  // delete not called by std::unique_ptr destructor.
}
----


== Resources

* https://cwe.mitre.org/data/definitions/415[MITRE, CWE-415] - Double Free
* https://owasp.org/www-community/vulnerabilities/Doubly_freeing_memory[OWASP, Doubly freeing memory]

=== Related rules

* S5025 recommends avoiding manual memory management


ifdef::env-github,rspecator-view[]

'''
== Implementation Specification
(visible only on this page)

=== Message

Remove this redundant "free" call.


=== Highlighting

* Primary: ``++free(xxx)++``| ``++delete xxx++``
* Secondary: previous ``++free++``|``++delete++`` call(s)


'''
== Comments And Links
(visible only on this page)

=== on 3 Feb 2016, 19:58:36 Ann Campbell wrote:
\[~freddy.mallet], what you've edited the description to say was my initial understanding of this problem, but every reference I could find said that a double free would https://cwe.mitre.org/data/definitions/415.html[corrupt the program's memory management data structures]. None of them said that it "only" made the memory available for reallocation.

=== on 3 Feb 2016, 22:03:06 Freddy Mallet wrote:
\[~ann.campbell.2] the program's memory management data structures becomes corrupted because just after the first call to the free() statement this part of the heap memory can immediately be reused/reorganised for any other purpose. So by releasing twice the same memory location, you end up with a memory location used concurrently for two fully different purposes -> crash.

=== on 30 Mar 2016, 14:52:05 Ann Campbell wrote:
Eventually this rule should cover both double ``++free++`` _and_ double ``++delete++`` but the initial implementation will just be for C.

=== on 27 Jul 2016, 13:32:23 Freddy Mallet wrote:
Euh for me [~ann.campbell.2], there is no doubt about the fact that this is a blocker BUG and not a blocker Code Smell.

=== on 27 Jul 2016, 14:24:51 Ann Campbell wrote:
You're right, of course [~freddy.mallet]. I struggle a little with the UI.

endif::env-github,rspecator-view[]
