Deallocating a memory location more than once leads to undefined behavior.

== Why is this an issue?

Using `delete` or `free` releases the reservation on a memory location, making it immediately available for another purpose.
Releasing the exact memory location twice leads to undefined behavior and can often crash the program.

The C standard defines a call to `free` with a pointer to a memory area that has already been released as undefined behavior.

The {cpp} standard defines the first `delete` call as the end of the lifetime for dynamically allocated memory.
Access to memory past its lifetime end, including another `delete`, is undefined behavior.

=== What is the potential impact

The danger of a "double-free" comes directly from the fact that it is undefined behavior.
Both C and {cpp} standards describe it as such.
Due to this, there is no guarantee that a crash will happen on a "double-free" when the resource is released, or at all until the end of the program's execution.

The effects of a "double-free" depend entirely on the program's memory management implementation.
In the case of such an event, one of the following can be observed:

- The program's memory-management data structures can become corrupted.
This will usually cause a crash.
- Demonstrative Example 2 on https://cwe.mitre.org/data/definitions/415[CWE-415] presents a set of circumstances where a crash does not occur.
In these circumstances, the corruption of the mentioned data structures causes two later calls to malloc to return the same pointer.
This can lead to a sensitive data exposure vulnerability or a buffer overflow vulnerability.

== How to fix it

Besides just ensuring that every release happens once, the following best practices can also be used:

- Release any allocated memory in the function it was acquired in.
Ideally, the release should be independent of any additional conditions.
- After a `delete` or `free`, set the pointer's value to `nullptr` or `NULL`.
`delete` of `nullptr` and `free` of `NULL` are defined as having no effect.

=== Code examples

Example for C:

==== Noncompliant code example

[source,c,diff-id=1,diff-type=noncompliant]
----
void doSomething(int size) {
  char* cp = (char*) malloc(sizeof(char) * size);

  // ...
  if (condition) {
    // ...
    free(cp);
  }

  free(cp);  // Noncompliant: potential call to free in above branch
}
----

==== Compliant solution

Remove the unnecessary call to `free`:
[source,c,diff-id=1,diff-type=compliant]
----
void doSomething(int size) {
  char* cp = (char*) malloc(sizeof(char) * size);

  // ...
  if (condition) {
    // ...
  }

  free(cp); // Compliant: no previous call to free in above branch
}
----

Set the pointer to `NULL` after any call to `free`:
[source,c]
----
void doSomething(int size) {
  char* cp = (char*) malloc(sizeof(char) * size);

  // ...
  if (condition) {
    // ...
    free(cp);
    cp = NULL; // This will prevent freeing the same memory again
  }

  free(cp); // Compliant: if the memory was freed in the if-block above, free(NULL) is a no-op
}
----

Example for {cpp}:

==== Noncompliant code example

Remove the unnecessary invocation of `delete`:
[source,cpp,diff-id=2,diff-type=noncompliant]
----
void doSomething(int size) {
  std::string* p = new std::string;

  // ...
  if (condition) {
    // ...
    delete p;
  }

  delete p;  // Noncompliant: potential invocation of delete in above branch
}
----

==== Compliant solution

[source,cpp,diff-id=2,diff-type=compliant]
----
void doSomething(int size) {
  std::string* p = new std::string;

  // ...
  if (condition) {
    // ...
  }

  delete p; // Compliant: no previous call to free in above branch
}
----

Set the pointer to `nullptr` after any invocation of `delete`:
[source,cpp]
----
void doSomething(int size) {
  std::string* p = new std::string;

  // ...
  if (condition) {
    // ...
    delete p;
    p = nullptr; // This will prevent freeing the same memory again
  }

  delete p; // Compliant: if the memory was freed in the if-block above, operator delete of nullptr is a no-op
}
----

=== Going the extra mile

{cpp}11 introduced smart pointers.
Using these instead of manual memory management can mitigate most dynamic memory management issues
including "double-free".

[source,cpp]
----
void doSomething(int size) {
  auto p = std::make_unique<std::string>();

  // ...
  if (condition) {
    p.reset(); // Delete happens here.
  }

  // delete not called by std::unique_ptr destructor if the branch above was taken.
}
----


== Resources

* CWE - https://cwe.mitre.org/data/definitions/415[415 Double Free]
* OWASP - https://owasp.org/www-community/vulnerabilities/Doubly_freeing_memory[Doubly freeing memory]

=== Related rules

* S5025 recommends avoiding manual memory management
* S3529 refers to "use-after-free", an issue with similar causes.


ifdef::env-github,rspecator-view[]

'''
== Implementation Specification
(visible only on this page)

=== Message

Remove this redundant "free" call.


=== Highlighting

* Primary: ``++free(xxx)++``| ``++delete xxx++``
* Secondary: previous ``++free++``|``++delete++`` call(s)


'''
== Comments And Links
(visible only on this page)

=== on 3 Feb 2016, 19:58:36 Ann Campbell wrote:
\[~freddy.mallet], what you've edited the description to say was my initial understanding of this problem, but every reference I could find said that a double free would https://cwe.mitre.org/data/definitions/415.html[corrupt the program's memory management data structures]. None of them said that it "only" made the memory available for reallocation.

=== on 3 Feb 2016, 22:03:06 Freddy Mallet wrote:
\[~ann.campbell.2] the program's memory management data structures becomes corrupted because just after the first call to the free() statement this part of the heap memory can immediately be reused/reorganised for any other purpose. So by releasing twice the same memory location, you end up with a memory location used concurrently for two fully different purposes -> crash.

=== on 30 Mar 2016, 14:52:05 Ann Campbell wrote:
Eventually this rule should cover both double ``++free++`` _and_ double ``++delete++`` but the initial implementation will just be for C.

=== on 27 Jul 2016, 13:32:23 Freddy Mallet wrote:
Euh for me [~ann.campbell.2], there is no doubt about the fact that this is a blocker BUG and not a blocker Code Smell.

=== on 27 Jul 2016, 14:24:51 Ann Campbell wrote:
You're right, of course [~freddy.mallet]. I struggle a little with the UI.

endif::env-github,rspecator-view[]

