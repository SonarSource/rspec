This rule raises an issue when
a class implements the interface `java.lang.Cloneable`,
but does not override the `Object.clone()` method.



== Why is this an issue?

`java.lang.Cloneable` is a so-called _marker interface_
which does not provide any fields or methods
but whose purpose is to mark
that the class has a specific feature,
namely that the `Object.clone` can be used to create a [consistent] copy of the class instance.

The `Object.clone()` method is not part of the interface, but of `java.lang.Object`.

When a class implements
`Cloneable`, it just makes assertions about the class' behavior.

When the `clone` method is not overridden, that behavior is asserted, but not implemented.



**A note about marker interfaces:**

Marker interfaces are a bad practice, because they do not assign an actual interface,
[but a contract about the behavior of the class,]
[but a conceptual contract about the  class,]
which cannot be enforced by the compiler.

At the example of the `java.lang.Cloneable` interface, that contract is about the behavior of
the `Object.clone` method.

While the mechanism of `Object.clone` / `java.lang.Cloneable` can be regarded as flawed in itself - the `clone` method could
instead have been part of the interface -
it is a heritage of one of the very first Java versions [1.1?]
and hence regarded an exception.
Also, it is not type safe because it returns `Object`.

However, you might want to consider alternatives for that mechanism at all,
i.e., ignore the `Object.clone` / `java.lang.Cloneable` mechanism
and implement an explicit `copy()` method (with type parameters) instead.

== How to fix it




----------------------------



Simply implementing ``++Cloneable++``  without also overriding ``++Object.clone()++`` does not necessarily make the class cloneable. While the ``++Cloneable++`` interface does not include a ``++clone++`` method, it is required by convention, and ensures true cloneability. Otherwise the default JVM ``++clone++`` will be used, which copies primitive values and object references from the source to the target. I.e. without overriding ``++clone++``, any cloned instances will potentially share members with the source instance.


Removing the ``++Cloneable++`` implementation and providing a good copy constructor is another viable (some say preferable) way of allowing a class to be copied.


=== Noncompliant code example

[source,java]
----
class Team implements Cloneable {  // Noncompliant
  private Person coach;
  private List<Person> players;
  public void addPlayer(Person p) {...}
  public Person getCoach() {...}
}
----


=== Compliant solution

[source,java]
----
class Team implements Cloneable {
  private Person coach;
  private List<Person> players;
  public void addPlayer(Person p) { ... }
  public Person getCoach() { ... }

  @Override
  public Object clone() { 
    Team clone = (Team) super.clone();
    //...
  }
}
----


ifdef::env-github,rspecator-view[]

'''
== Implementation Specification
(visible only on this page)

=== Message

Add a "clone()" method to this class.


'''
== Comments And Links
(visible only on this page)

=== is related to: S2975

endif::env-github,rspecator-view[]
