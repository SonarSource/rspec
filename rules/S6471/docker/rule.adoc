Running containers with root as the default user weakens their runtimes,
allowing any user whose code runs on the container to perform administrative
actions. +
On Windows containers, the equivalent is `ContainerAdmin`.

A malicious user can run code on a system either thanks to actions that could
be deemed legitimate - depending on internal business logic or operational
management shells - or thanks to malicious actions. For example, with arbitrary
code execution after exploiting a service that the container hosts.

Suppose the container is not hardened to prevent using a shell, interpreter, or
https://man7.org/linux/man-pages/man7/capabilities.7.html[Linux capabilities].
In this case, the malicious user can read and download any file (including from
Docker volumes), open new network connections, install malicious software, or,
worse, break out of the container's isolation context by exploiting other
components.

Depending on the infrastructure's resilience, attackers can extend their attack
to other services, such as Kubernetes clusters or cloud providers.

== Ask Yourself Whether

This container:

* Serves internet-facing services.
* Does not require any root permission to run.

There is a risk if you answered yes to any of those questions.

== Recommended Secure Coding Practices

On the Dockerfile:

* Create a new default user and use it with the `USER` statement
** Some container maintainers create a specific user to be used without explicitly setting it as default, such as `postgresql` or `zookeeper`. It is recommended to use these users instead of your own.
** On Windows containers, the `ContainerUser` is available for this purpose.

Or, at launch time:

* Use the `user` argument when calling docker or in the docker-compose file.
* Add fine-grained Linux capabilities to perform specific actions that require root privileges.

If this image is already explicitly set to launch with a non-root user, you can
add it to the `safe_images` rule property of your SonarQube instance, without the tag.

== Sensitive Code Example

For any image that does not provide a user by default, regardless of their
underlying operating system:

[source,docker]
----
FROM alpine # Noncompliant

ENTRYPOINT ["id"]
----

For multi-stage builds, the last stage is non-compliant if it does not contain
the `USER` instruction with a non-root user:

[source,docker]
----
FROM alpine as builder

COPY Makefile ./src /

RUN make build

USER nonroot

FROM alpine as runtime # Noncompliant, previous user settings are dropped

COPY --from=builder bin/production /app

ENTRYPOINT ["/app/production"]
----

For `scratch` based images:

[source,docker]
----
FROM scratch # Noncompliant

ADD production_binary /app

ENTRYPOINT ["/app/production_binary"]
----

Setting a non-root user and then a root user as the last `USER` instruction:

[source,docker]
----
FROM node 

USER node
RUN npm install

USER root # Noncompliant

ENTRYPOINT ["/production.js"]
----


== Compliant Solution

For Linux-based images:

[source,docker]
----
FROM alpine

RUN useradd nonroot

USER nonroot

ENTRYPOINT ["id"]
----

For Windows-based images, you can use `ContainerUser` or create a new user:

[source,docker]
----
FROM microsoft/windowsservercore

RUN net user /add nonroot

USER nonroot
----

If the `scratch` Dockerfile untars a Linux distribution, the "Linux image"
solution should be applied. Else, you have a choice between using a pre-written
`/etc/passwd` file (regardless of the host operating system) or using a
multi-stage build.

[source,docker]
----
FROM scratch

COPY etc_passwd /etc/passwd
# contains "nonroot:x:1337:1337:nonroot:/nonroot:/usr/sbin/nologin"

USER nonroot

COPY production_binary /app

ENTRYPOINT ["/app/production_binary"]
----

or you can use a multi-stage build:

[source,docker]
----
FROM alpine:latest as security_provider

RUN addgroup -S nonroot \
    && adduser -S nonroot -G nonroot 

FROM scratch as production

COPY --from=security_provider /etc/passwd /etc/passwd
COPY production_binary /app

ENTRYPOINT ["/app/production_binary"]
----


For multi-layer images:
[source,docker]
----
FROM alpine as builder

COPY Makefile ./src /

RUN make build

FROM alpine as runtime

COPY --from=builder bin/production /app

USER nonroot

ENTRYPOINT ["/app/production"]
----

== See

* https://cwe.mitre.org/data/definitions/284.html[MITRE, CWE-284] - Improper Access Control
* https://hub.docker.com/r/nginxinc/nginx-unprivileged[nginxinc/nginx-unprivileged: Example of a non-root container by default]
* https://learn.microsoft.com/en-us/virtualization/windowscontainers/manage-containers/container-security#when-to-use-containeradmin-and-containeruser-user-accounts[Microsoft docs, When to use ContainerAdmin and ContainerUser user accounts]

ifdef::env-github,rspecator-view[]

'''
== Implementation Specification
(visible only on this page)

=== Message

Set in https://sonarsource.atlassian.net/browse/SONARIAC-478[SONARIAC-478].

=== Highlighting

Set in https://sonarsource.atlassian.net/browse/SONARIAC-478[SONARIAC-478].

endif::env-github,rspecator-view[]
