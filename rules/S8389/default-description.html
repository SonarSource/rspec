<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This is an issue when a FastAPI endpoint accepts file uploads (using <code>File()</code>) and also receives structured data through <code>Body()</code> parameters or query parameters (via <code>Depends()</code> without proper form handling). This pattern causes either validation errors at runtime or exposes sensitive information in URLs and logs.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When building web APIs with FastAPI, developers often need to create endpoints that accept both file uploads and structured data. However, the way this data is transmitted requires careful consideration due to HTTP protocol constraints and security implications.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_understanding_http_content_types">Understanding HTTP Content Types</h2>
<div class="sectionbody">
<div class="paragraph">
<p>HTTP requests can encode data in different ways, specified by the <code>Content-Type</code> header:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>application/json</code> - Used for JSON data in the request body</p>
</li>
<li>
<p><code>multipart/form-data</code> - Required for file uploads, encodes both files and form fields</p>
</li>
<li>
<p>Query parameters - Appended to the URL after a <code>?</code> character</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When a FastAPI endpoint includes <code>File()</code> parameters, the client must send the request using <code>multipart/form-data</code> encoding. This creates a fundamental incompatibility: you cannot mix <code>Body()</code> parameters (which expect <code>application/json</code>) with <code>File()</code> parameters in the same endpoint.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_the_technical_problem">The Technical Problem</h2>
<div class="sectionbody">
<div class="paragraph">
<p>If you declare both <code>Body()</code> and <code>File()</code> parameters in the same endpoint, FastAPI cannot properly parse the request. The framework expects JSON in the body when it sees <code>Body()</code> parameters, but receives form-encoded data instead when files are included. This results in validation errors like "value is not a valid dict" or similar type mismatches.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_the_security_problem">The Security Problem</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Some developers work around the technical constraint by passing structured data through query parameters using <code>Depends()</code> with a Pydantic model. While this avoids the encoding conflict, it creates a serious security vulnerability.</p>
</div>
<div class="paragraph">
<p>Query parameters appear in the URL itself, which means they are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Visible in browser address bars</p>
</li>
<li>
<p>Stored in browser history</p>
</li>
<li>
<p>Logged in web server access logs</p>
</li>
<li>
<p>Potentially cached by proxies and CDNs</p>
</li>
<li>
<p>Visible in network monitoring tools</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If the structured data contains sensitive information (user credentials, personal data, tokens, etc.), this exposure creates a significant security risk. An attacker with access to server logs, browser history, or network traffic can extract this sensitive information.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_why_form_data_is_the_solution">Why Form Data is the Solution</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Form data transmitted via <code>multipart/form-data</code> encoding:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Is compatible with file uploads</p>
</li>
<li>
<p>Is sent in the request body, not the URL</p>
</li>
<li>
<p>Does not appear in server logs (only the URL path is logged)</p>
</li>
<li>
<p>Can be properly validated and parsed by FastAPI</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The challenge is that form data is transmitted as strings, not as structured JSON objects. This is where Pydantic&#8217;s custom validators become essential - they allow you to parse JSON strings from form fields while maintaining type safety and validation.</p>
</div>
<div class="sect2">
<h3 id="_what_is_the_potential_impact">What is the potential impact?</h3>

</div>
<div class="sect2">
<h3 id="_exposure_of_sensitive_data">Exposure of Sensitive Data</h3>
<div class="paragraph">
<p>When structured data containing sensitive information is passed through query parameters, it becomes visible in multiple locations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Server access logs permanently record the full URL including all query parameters</p>
</li>
<li>
<p>Browser history stores the complete URL, accessible to anyone with access to the device</p>
</li>
<li>
<p>Network intermediaries (proxies, load balancers) may log or cache the URLs</p>
</li>
<li>
<p>Referrer headers may leak the URL to third-party sites</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This exposure can lead to unauthorized access to user accounts, personal information disclosure, or compliance violations (GDPR, HIPAA, PCI-DSS).</p>
</div>
</div>
<div class="sect2">
<h3 id="_application_failures">Application Failures</h3>
<div class="paragraph">
<p>When <code>Body()</code> and <code>File()</code> parameters are mixed incorrectly, the application will fail at runtime with validation errors. Users will be unable to complete file upload operations, resulting in:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Poor user experience</p>
</li>
<li>
<p>Failed business processes</p>
</li>
<li>
<p>Support burden from confused users</p>
</li>
<li>
<p>Potential data loss if users abandon the operation</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_fix_it_in_fastapi">How to fix it in FastAPI</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Replace <code>Body()</code> parameters with <code>Form()</code> parameters and add a Pydantic validator to parse JSON strings. This ensures compatibility with file uploads while maintaining type safety.</p>
</div>
<div class="sect2">
<h3 id="_code_examples">Code examples</h3>
<div class="sect3">
<h4 id="_noncompliant_code_example">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">@router.post("/upload")
async def create_policy(
    countryId: str = Body(...),  # Noncompliant
    policyDetails: List[dict] = Body(...),  # Noncompliant
    files: List[UploadFile] = File(...)
):
    return {"status": "ok"}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class PolicyData(BaseModel):
    countryId: str
    policyDetails: List[dict]

    @model_validator(mode='before')
    @classmethod
    def validate_to_json(cls, value):
        if isinstance(value, str):
            return cls(**json.loads(value))
        return value

@router.post("/upload")
async def create_policy(
    data: PolicyData = Form(...),
    files: List[UploadFile] = File(...)
):
    return {"status": "ok"}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Replace <code>Depends()</code> with <code>Form()</code> when passing structured data alongside file uploads. Use a custom validator to parse the JSON string from the form field.</p>
</div>
</div>
<div class="sect3">
<h4 id="_noncompliant_code_example_2">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">@app.post("/submit")
def submit(
    base: Base = Depends(),  # Noncompliant - data exposed in query parameters
    files: List[UploadFile] = File(...)
):
    return {"JSON Payload": base, "Filenames": [file.filename for file in files]}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution_2">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Base(BaseModel):
    countryId: str
    sensitiveData: str

    @model_validator(mode='before')
    @classmethod
    def validate_to_json(cls, value):
        if isinstance(value, str):
            return cls(**json.loads(value))
        return value

@app.post("/submit")
def submit(
    base: Base = Form(...),
    files: List[UploadFile] = File(...)
):
    return {"JSON Payload": base, "Filenames": [file.filename for file in files]}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you need to accept complex nested structures, create a dependency function that reads from <code>Form()</code> and performs validation with proper error handling.</p>
</div>
</div>
<div class="sect3">
<h4 id="_noncompliant_code_example_3">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">@app.post("/data")
async def upload_data(
    config: DataConfiguration = Depends(),  # Noncompliant
    csvFile: UploadFile = File(...)
):
    pass</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution_3">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">from fastapi import HTTPException, status
from fastapi.encoders import jsonable_encoder
from pydantic import ValidationError

def parse_config(data: str = Form(...)) -&gt; DataConfiguration:
    try:
        return DataConfiguration.model_validate_json(data)
    except ValidationError as e:
        raise HTTPException(
            detail=jsonable_encoder(e.errors()),
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
        )

@app.post("/data")
async def upload_data(
    config: DataConfiguration = Depends(parse_config),
    csvFile: UploadFile = File(...)
):
    pass</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_documentation">Documentation</h3>
<div class="ulist">
<ul>
<li>
<p>FastAPI - Request Forms and Files - <a href="https://fastapi.tiangolo.com/tutorial/request-forms-and-files/">Official FastAPI documentation on handling forms and files together</a></p>
</li>
<li>
<p>FastAPI - Request Body - <a href="https://fastapi.tiangolo.com/tutorial/body/">Official documentation explaining Body parameters and JSON encoding</a></p>
</li>
<li>
<p>Pydantic - Validators - <a href="https://docs.pydantic.dev/latest/concepts/validators/">Documentation on Pydantic validators for custom data parsing</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>