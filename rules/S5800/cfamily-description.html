<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The function <code>strerror</code> returns a buffer that is only valid until the next call to <code>strerror</code>. In a multithreaded environment, you don&#8217;t know when this next call will happen, which makes this function dangerous to call. You should use thread-safe alternatives, such as <a href="https://en.cppreference.com/w/c/string/byte/strerror"><code>strerror_s</code></a> or <code>strerror_r</code>.</p>
</div>
<div class="paragraph">
<p>Note that <code>strerror_s</code> is defined in annex K of C11, so to have access to it, you need a standard library that supports it (this can be tested with the macro <code>__STDC_LIB_EXT1__</code>), and you need to enable it by defining the macro <code>__STDC_WANT_LIB_EXT1__</code> before including <code>&lt;string.h&gt;</code>.</p>
</div>
<div class="sect2">
<h3 id="_noncompliant_code_example">Noncompliant code example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">char *msg = strerror(errno);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_compliant_solution">Compliant solution</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">size_t size = strerrorlen_s(errno);
char *msg = malloc(size);
strerror_s(msg, size);</code></pre>
</div>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_implementation_specification">Implementation Specification</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_message">Message</h3>
<div class="paragraph">
<p>Use "strerr_s" or a "strerr_r" to get a thread-safe error message</p>
</div>
</div>
</div>
</div>