<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In contrast to normal functions, coroutines can suspend and later resume their execution. Depending on the program, the coroutine may resume on a different thread of execution than the one it was started or run previously on.</p>
</div>
<div class="paragraph">
<p>Therefore, the access to the "same" variable with <code>thread_local</code> storage may produce different values, as illustrated below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">thread_local std::vector&lt;Decorator&gt; decorators;
lazy&lt;Thingy&gt; doSomething() {
  // evaluation started on thread t1
  /* .... */
  const std::size_t decoratorCount = decorators.size(); // value specific to thread t1
  auto result = co_await produceThingy();
  // after co_await, execution resumes on thread t2
  for (std::size_t i = 0; i &lt; decoratorCount; ++i) {
    decorators[i].modify(result); // access value specific to t2
    // miss some tasks if t1:decorators.size() &lt; t2:decorators.size()
    // undefined behavior if t1:decorators.size() &gt; t2:decorators.size()
  }
  co_return result;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This behavior is surprising and unintuitive compared to normal functions that are always evaluated on a single thread.
The same issue can happen for the use of different <code>thread_local</code> variables if their values are interconnected (e.g., one is the address of the buffer, and the other is the number of elements in the buffer).</p>
</div>
<div class="paragraph">
<p>Moreover, access to <code>thread_local</code> variables defined inside the coroutine may read uninitialized memory.
Each such variable is initialized when a specific thread enters the function for the first time,
and if the function was never called from a thread on which the coroutine is resumed, it is uninitialized.</p>
</div>
<div class="paragraph">
<p>This rule raises an issue on the declaration of <code>thread_local</code> variables and access to <code>thread_local</code> variables
in coroutines.</p>
</div>
<div class="sect2">
<h3 id="_noncompliant_code_example">Noncompliant code example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">thread_local std::vector&lt;Decorator&gt; decorators;
lazy&lt;Thingy&gt; doSomething() {
  thread_local Decorator localDecorator; // Noncompliant
  const std::size_t decoratorCount = decorators.size(); // Noncompliant
  /* ... */
  auto result = co_await produceThingy();
  for (std::size_t i = 0; i &lt; taskCount; ++i) {
    decorators[i].modify(result);
  }
  localDecorator.modify(result); // Noncompliant
  co_return result;
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>C&#43;&#43; reference - <a href="https://en.cppreference.com/w/cpp/language/storage_duration">Storage class specifiers: thread_local</a></p>
</li>
</ul>
</div>
</div>
</div>