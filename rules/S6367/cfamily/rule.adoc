In contrast to normal functions, coroutines can suspend and later resume their execution. Depending on the program, the coroutine may resume on a different thread of execution than the one it was started or run previously on.

Therefore, the access to the "same" variable with `thread_local` storage may produce different values as illustrated below:
----
thread_local std::vector<Task> tasks;
lazy<Thingy> doSomething() {
  // evalutation started on thread t1
  /* .... */
  const std::size_t taskCount = tasks.size(); // value specific to thread t1
  auto result = co_await produceThingy();
  // after co_await, execution resumes on thread t2
  for (std::size_t i = 0; i < taskCount; ++i) {
    tasks[i].evalute(); // access value specific to t2
    // miss some tasks if t1:taskCount.size() < t2:taskCount.size()
    // undefined behavior if t1:taskCount.size() > t2:taskCount.size()
  }  
  return result;
}
----
This behavior is surprising and unintuitive in comparison to normal functions that are always evaluated on a single thread.
The same issue can happen for the use of different thread-local variables if their values are interconnected
(e.g. one is the address of the buffer, and the other is the number of elements in the buffer).

Moreover, access to `thread-local` variables defined inside the coroutine may read uninitialized memory. 
Each such variable is initialized when a specific thread enters the function for the first time, 
and if the function was never called from a thread on which the coroutine is resumed, it is uninitialized.

This rule raises an issue on the declaration of `thread_local` variables and access to `thread_local` variables
in coroutines.

== Noncompliant Code Example

----
thread_local std::vector<Task> tasks;
lazy<Thingy> doSomething() {
  thread_local Tasks localTask; // Noncompliant
  const std::size_t taskCount = tasks.size(); // Noncompliant
  /* ... */
  auto result = co_await produceThingy();
  for (std::size_t i = 0; i < taskCount; ++i) {
     tasks[i].evalute(); // Noncompliant
  }  
  localTask.evaluate(); // Noncompliant
  return result;
}
----

