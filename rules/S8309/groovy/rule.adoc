This rule raises an issue when code uses `sort(false)` instead of `toSorted()`, or when the result of a mutating `sort()` call is assigned to a variable.

== Why is this an issue?

Groovy collections can be sorted either by mutating the original collection or by creating a new one. The `sort()` method sorts the collection in place and returns the same instance. When you assign this result to another variable, it is easy to assume you now have two independent collections, while in reality both variables point to the same, already modified collection.

Using `sort(false)` to get a new sorted collection is also confusing. The meaning of the `false` argument is not obvious, so readers must remember a Groovy special case instead of understanding the code directly. The `toSorted()` method was introduced to make this intent explicit: it returns a new sorted collection and keeps the original unchanged.


=== What is the potential impact?

Misusing these sorting methods can hide mutations, which makes defects harder to reproduce, increases maintenance cost, and can compromise reliability when collections are shared between components or threads.

== How to fix it

Use `toSorted()` instead of `sort(false)` when you need a new sorted collection.

=== Code examples

==== Noncompliant code example

[source,groovy,diff-id=1,diff-type=noncompliant]
----
def originalList = [3, 1, 2]
def sortedList = originalList.sort(false)  // Noncompliant
----

==== Compliant solution

[source,groovy,diff-id=1,diff-type=compliant]
----
def originalList = [3, 1, 2]
def sortedList = originalList.toSorted()  // Clear intention to create new sorted list
----

== Resources

=== Documentation

 * Groovy documentation - http://docs.groovy-lang.org/latest/html/groovy-jdk/java/lang/Iterable.html#sort()[Iterable sort]

 * Groovy documentation - http://docs.groovy-lang.org/latest/html/groovy-jdk/java/lang/Iterable.html#toSorted()[Iterable toSorted]
