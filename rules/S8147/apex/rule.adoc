This rule raises an issue when a constructor calls a method before initializing the instance variables that method depends on.

== Why is this an issue?

When a constructor calls methods before properly initializing instance variables, those methods may operate on uninitialized (null) values. This creates an incomplete object state that can lead to unexpected behavior or runtime failures.

In Apex, instance variables are null by default until explicitly initialized. If a constructor calls a method that accesses these uninitialized variables, the method will receive null values instead of the expected data. This is especially problematic with getter methods that return instance variables.

For example, if a constructor calls `getStatus()` before setting the `status` field, the getter will return null instead of the intended value. This can cause null pointer exceptions in subsequent operations or lead to incorrect program logic.

The problem occurs because the constructor hasn't finished setting up the object's state when the method is called. The method assumes the object is fully initialized, but this assumption is violated.

=== What is the potential impact?

This issue can cause null pointer exceptions at runtime when methods try to operate on uninitialized fields. It can also lead to incorrect program logic when methods return null values instead of expected data, potentially causing cascading failures in dependent code.

== How to fix it

Initialize all instance variables before calling any methods in the constructor. Move field assignments to the beginning of the constructor, then call methods afterward.

=== Code examples

==== Noncompliant code example

[source,apex,diff-id=1,diff-type=noncompliant]
----
public class Foo {
    private String status;
    
    public Foo(String status) {
        if (getStatus() == 'something') { // Noncompliant
            // Logic here
        }
        this.status = status;
    }
    
    public String getStatus() {
        return this.status;
    }
}
----

==== Compliant solution

[source,apex,diff-id=1,diff-type=compliant]
----
public class Foo {
    private String status;
    
    public Foo(String status) {
        this.status = status; // Initialize first
        if (getStatus() == 'something') {
            // Logic here
        }
    }
    
    public String getStatus() {
        return this.status;
    }
}
----

== Resources

=== Documentation

 * Apex Developer Guide - Classes and Objects - https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/apex_classes.htm[Official Salesforce documentation on Apex classes and object initialization]

=== Standards

 * CWE-665: Improper Initialization - https://cwe.mitre.org/data/definitions/665.html[The product does not initialize or incorrectly initializes a resource, which might leave the resource in an unexpected state when it is accessed or used]
