Ensure that integer division and remainder operations do not result in divide-by-zero errors.

== Why is this an issue?

The result of the ``++/++`` operator is the quotient from the division of the first arithmetic operand by the second arithmetic operand and the result of the ``++%++`` operator is the remainder from the division of the first arithmetic operand by the second arithmetic operand.
Division operations are susceptible to divide-by-zero (and signed integer overflow) errors.

If the denominator to a division or modulo operation is zero, the behavior of the application is undefined.

Furthermore, when using signed integer division and the dividend is the minimum value for the signed integer type and the divisor is equal to ``++-1++`` an overflow is provoked due to two's complement representation.
This frequently causes hard-to-track bugs.

[source,cpp]
----
#include <limits>
#include <optional>

std::optional<int> unsafe_division(int a, int b) {
  if ((a == std::numeric_limits<int>::min()) && (b == -1)) {
    return std::nullopt;
  }
  // Noncompliant: While the above check correctly prevents signed integer overflows,
  // it fails to prevent divide-by-zero errors. If `b` is equal to `0`, the application
  // emits undefined behavior.
  return a / b;
}
----


== What is the potential impact?

Integer division or remainder operations that result in divide-by-zero errors lead to *undefined behavior*.

For programs that exercise undefined behavior, the compiler is no longer bound by the language specification.
The application may crash or, even worse, the application may appear to execute correctly while losing data or producing incorrect results.


== How to fix it

Employ adequate checks that prevent divide-by-zero errors when using integer division or remainder operations.


=== Code examples

==== Noncompliant code example

[source,cpp,diff-id=1,diff-type=noncompliant]
----
#include <limits>
#include <optional>

std::optional<int> unsafe_division(int a, int b) {
  if ((a == std::numeric_limits<int>::min()) && (b == -1)) {
    return std::nullopt;
  }
  return a / b; // Noncompliant: causes undefined behavior if `b` is zero
}
----

==== Compliant solution

[source,cpp,diff-id=1,diff-type=compliant]
----
#include <limits>
#include <optional>

std::optional<int> unsafe_division(int a, int b) {
  if ((b == 0) || ((a == std::numeric_limits<int>::min()) && (b == -1))) {
    return std::nullopt;
  }
  return a / b; // Compliant: check correctly prevents divide-by-zero and signed integer overflows
}
----


== Resources

=== Standards

* CERT - https://wiki.sei.cmu.edu/confluence/x/CTZGBQ[NUM02-J. Ensure that division and remainder operations do not result in divide-by-zero errors]
* CERT - https://wiki.sei.cmu.edu/confluence/display/c/INT32-C.+Ensure+that+operations+on+signed+integers+do+not+result+in+overflow[INT32-C. Ensure that operations on signed integers do not result in overflow]
* CERT - https://wiki.sei.cmu.edu/confluence/x/ftYxBQ[INT33-C. Ensure that division and remainder operations do not result in divide-by-zero errors]
* CWE - https://cwe.mitre.org/data/definitions/369[369 - Divide by zero]


ifdef::env-github,rspecator-view[]

'''
== Implementation Specification
(visible only on this page)

=== Message

Consider reviewing data-flow - possible division by zero.


include::../highlighting.adoc[]

'''
== Comments And Links
(visible only on this page)

include::../comments-and-links.adoc[]

endif::env-github,rspecator-view[]
