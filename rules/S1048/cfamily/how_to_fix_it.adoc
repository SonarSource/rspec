== How to fix it

This rule raises an issue when an exception is thrown from within a destructor or from a function transitively called by a destructor.

Such an exception should be caught and handled before the destructor exits.

=== Code examples

==== Noncompliant code example

In the following example, an exception is thrown inside the `Builder` destructor when calling `std::optional::value` on an empty optional.
It follows that the program abruptly terminates when `b` gets destroyed during stack unwinding in `application()` if the user name lookup fails.

[source,cpp,diff-id=1,diff-type=noncompliant]
----
void logBuilderDestruction(int userId);

class Builder {
  std::optional<int> _id;

 public:
  void setId(int userId) { _id = userId; }

  ~Builder() {
    auto userId = _id.value(); // Noncompliant: may throw std::bad_optional_access
    logBuilderDestruction(userId);
  }
};

std::unordered_map<std::string, int>& getDatabase();

int lookupUserId(std::string const& name) {
  return getDatabase().at(name); // May throw std::out_of_range.
}

void application(std::string const& name) {
  Builder b;
  b.setId(lookupUserId(name)); // Throws an exception when the name is unknown.
  // ...
}
----

==== Compliant solution

The solution below uses `std::optional::value_or` to ensure no exceptions are thrown from the destructor.

[source,cpp,diff-id=1,diff-type=compliant]
----
void logBuilderDestruction(int userId);

class Builder {
  std::optional<int> _id;

 public:
  void setId(int userId) { _id = userId; }

  ~Builder() {
    auto userId = _id.value_or(-1); // Compliant: never throws.
    logBuilderDestruction(userId);
  }
};

std::unordered_map<std::string, int>& getDatabase();

int lookupUserId(std::string const& name) {
  return getDatabase().at(name); // May throw std::out_of_range.
}

void application(std::string const& name) {
  Builder b;
  b.setId(lookupUserId(name)); // Throws an exception when the name is unknown.
  // ...
}
----
