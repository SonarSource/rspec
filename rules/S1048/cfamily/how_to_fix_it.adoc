== How to fix it

This rule raises an issue when an exception is thrown from within a destructor or from a function transitively called by a destructor.

Such an exception should be caught and handled before the destructor exits.

=== Code examples

==== Noncompliant code example

In the following example, an exception is thrown when calling `std::map::at`.
The program abruptly terminates when `tmp` gets destroyed during stack unwinding if a filesystem error occurs.

[source,cpp,diff-id=1,diff-type=noncompliant]
----
class TemporaryDirectory {
  std::filesystem::path directory;

public:
  TemporaryDirectory();
  TemporaryDirectory(TemporaryDirectory const&) = delete;
  TemporaryDirectory(TemporaryDirectory&&) = delete;
  TemporaryDirectory& operator=(TemporaryDirectory const&) = delete;
  TemporaryDirectory& operator=(TemporaryDirectory&&) = delete;

  ~TemporaryDirectory() {
    // Noncompliant: std::filesystem::filesystem_error can be thrown.
    std::filesystem::remove_all(directory);
  }
};

void application() {
  TemporaryDirectory tmp;
  downloadDatabase(tmp);
  std::map<ClientId, ClientName> database = readDatabaseFromDisk(tmp);
  displayClientName(database.at(unknownClientID)); // Throws std::out_of_range.
}
----

==== Compliant solution

How to deal with the exception highly depends on the application.
The solution below uses another overload of `std::filesystem::remove_all` and ensures no exceptions are thrown from the destructor.

[source,cpp,diff-id=1,diff-type=compliant]
----
class TemporaryDirectory {
  std::filesystem::path directory;

public:
  TemporaryDirectory();
  TemporaryDirectory(TemporaryDirectory const&) = delete;
  TemporaryDirectory(TemporaryDirectory&&) = delete;
  TemporaryDirectory& operator=(TemporaryDirectory const&) = delete;
  TemporaryDirectory& operator=(TemporaryDirectory&&) = delete;

  ~TemporaryDirectory() {
    // Compliant: the destructor never exits with an exception.
    std::error_code ec;
    if (std::filesystem::remove_all(directory, ec) == -1) {
      std::cerr << "Failed to delete temporary directory." << std::endl;
    }
  }
};

void application() {
  TemporaryDirectory tmp;
  downloadDatabase(tmp);
  std::map<ClientId, ClientName> database = readDatabaseFromDisk(tmp);
  displayClientName(database.at(unknownClientID)); // Throws std::out_of_range.
}
----

Note that this solution simply logs the event.
This may not be appropriate for all kinds of applications.
