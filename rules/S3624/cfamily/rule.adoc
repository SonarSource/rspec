When a class cannot follow the Rule of Zero, its special members should follow one of a few logical patterns.

== Why is this an issue?

Most classes should not directly handle resources, but instead, use members that perform resource handling for them:

* For memory, it can be ``++std::unique_ptr++``, ``++std::shared_ptr++``, ``++std::vector++``...
* For files, it can be ``++std::ofstream++``, ``++std::ifstream++``...
* ...

Classes that avoid directly handling resources don't need to define any of the special member functions required to properly handle resources: destructor, copy constructor, move constructor, copy-assignment operator, move-assignment operator. That's because the versions of those functions provided by the compiler do the right thing automatically, which is especially useful because writing these functions correctly is typically tricky and error-prone.

Omitting all of these functions from a class is known as the Rule of Zero because no special function should be defined. This rule should apply to the vast majority of classes.

The remaining classes that cannot use the Rule of Zero should be dedicated to managing a specific kind of resource and should follow a few logical rules:
* The presence of a copy operation implies the presence of the corresponding move operation (the opposite is not true). That is because the move operations are specialized copy operations that try to optimize the specific case where the source is an r-value. At worst, move operations are identical to copy.

* The presence of a copy/move assignment implies the presence of the corresponding constructor (the opposite is not true).

* If you need to customize one of the special member functions, it means that you need to consider all the other member functions and that using `= default` will not do what you want.

From these rules, we can describe three categories among which all classes should fall into.

=== Copy-enabled classes

These classes can be copied and moved.

==== Special member functions for copy-enabled classes

* copy construction and move construction should both be available.

* Either copy-assignment and move-assignment are both available, or neither is.

==== Providing custom special member functions for copy-enabled classes

If at least one special function needs to be customized, then:

* You need to provide a custom destructor and a custom copy constructor.

* The copy-assignment needs to either be deleted or be customized.

* If you can optimize the move construction, compared to the copy, you need to provide a custom move constructor. If the move operation is the same as the copy, you should not declare it at all.

* If the copy-assignment is deleted, you need to delete the move-assignment.

* If the copy-assignment is customized, you need to provide a move-assignment if you can optimize the move operation, compared to the copy. Otherwise, you should just omit it.

=== Move-only classes

These are classes that cannot be copied but can be moved. They represent a unique object.

==== Special member functions for move-only classes

* move construction is available.

* copy construction and copy assignment are deleted.

* move-assignment may be available or not.

==== Providing custom special member functions for move-only classes

* You need to provide a custom destructor and a custom move constructor.

* The move-assignment needs to be either deleted or customized.

=== Unmovable classes

These are classes that cannot be copied, nor moved. They cannot escape their current scope.

==== Special member functions for unmovable classes

All copy and move operations are deleted.

== Resources

=== Documentation

* {cpp} reference - https://en.cppreference.com/w/cpp/language/raii[RAII]

=== Standards

* MISRA C++23 15.0.1 - "Special member functions" shall be provided appropriately

ifdef::env-github,rspecator-view[]

'''
== Implementation Specification
(visible only on this page)

=== Message

Explicitly define the missing "[copy constructor|copy-assignment operator|destructor|move constructor|move-assignment operator]" so that it will not be implicitly provided.


=== Highlighting

class name


'''
== Comments And Links
(visible only on this page)

=== is duplicated by: S1234

=== relates to: S4963

=== on 1 Jun 2016, 17:29:31 Ann Campbell wrote:
\[~alban.auzeill], you mentioned in our discussion something about not raising false positives when the move constructor and move-assignment operator are missing. I didn't really get the details of that, so it's not included here and we'll probably need to add it. Feel free to stub the details in or add them in a comment.


Also, I've changed the code samples from IntPointers to FooPointers & added a second compliant solution, which you'll probably want to take a look at.




=== on 8 Jun 2016, 17:40:06 Ann Campbell wrote:
I've made some edits [~alban.auzeill]. Take a look, please.

=== on 15 Aug 2016, 18:05:28 Ann Campbell wrote:
\[~alban.auzeill] this description is extremely long, and I'd like to shorten it by removing some or all of the {cpp} 98 and {cpp} 11 history. Given that you'll have final approval, do you mind if I go ahead?

=== on 6 Nov 2018, 17:57:54 Ann Campbell wrote:
\[~loic.joly] I find this contradictory


____ ... If you cannot find a way to implement them more efficiently than the copy operations, you can just leave them out.

Those operations work together, and letting the compiler automatically generate some of them, but not all, means that when one of those functions is called, the integrity of the resource will probably be compromised____

=== on 6 Nov 2018, 18:13:53 Loïc Joly wrote:
\[~ann.campbell.2] It's not really contradictory, because as soon as a copy constructor is written by the user, it disables the automatic generation of the move constructor, so we're not letting the compiler do anything. But I see your point, it's confusing...


With that additional information, do you have a counter proposal that is not adding too much text to this already long description?



=== on 22 Nov 2018, 15:14:57 Amélie Renard wrote:
Cases which could need an explanation :


* Destructor is defined in order to check that the object can really be destroyed (use of assert())
ex : \https://peach.sonarsource.com/project/issues?id=c-family%3Aclang&issues=AWczye3UUxytsEdVyqlH&open=AWczye3UUxytsEdVyqlH

(bad example because the class has a reference attribute - but the idea is there)


* Copy constructor and copy assignment operator are defined to keep a counter (or something like that)

* An attribute is a unique_ptr. So the user defines the copy constructor and the copy-assignment operator to copy what is inside the unique_ptr. But there is no need of a destructor as the unique_ptr takes care of it.
ex : \https://peach.sonarsource.com/project/issues?id=c-family%3Aclang&issues=AWczyhmIUxytsEdVyqnR&open=AWczyhmIUxytsEdVyqnR


* Class which defines the copy constructor and/or copy-assignment operator when it does not need to. This class should apply the "Rule-of-Zero".

endif::env-github,rspecator-view[]
