== Why is this an issue?

Using the same value on both sides of certain operators is a code defect. In the case of logical operators, it is either a copy/paste error and, therefore, a bug, or it is simply duplicated code and should be simplified. For comparison operators and arithmetic operations, having the same value on both sides of an operator yields predictable results and should be simplified as well to avoid further code defects.

This rule raises for the following operators and constructs in bash/shell:

* Equality operators (`==`, `!=`, `=`)
* Comparison operators (`-eq`, `-ne`, `-lt`, `-le`, `-gt`, `-ge`)
* String comparison operators (`<`, `>`)
* Logical operators (`&&`, `||`)
* Regex operator (`=~`)
* Arithmetic operations in `$((expression))`:
** Subtraction (`-`)
** Division (`/`)
** Modulo (`%`)
* Bitwise operations in `$((expression))`:
** Bitwise OR (`|`)
** Bitwise AND (`&`)
** Bitwise XOR (`^`)

=== Exceptions

This rule ignores the following operators:

* Multiplication (`*`)
* Exponentiation (``++**++``)
* Addition (`+`)
* Assignment (`=` when used for variable assignment)
* Bitwise shift operators (`<<`, `>>`)

== How to fix it

=== Code examples

==== Noncompliant code example

[source,bash,diff-id=1,diff-type=noncompliant]
----
#!/bin/bash

if [[ $a == $a ]]; then
  echo "This will always execute"
fi

if [[ $a != $a ]]; then
  echo "This will never execute"
fi

if [[ $a == $b && $a == $b ]]; then
  echo "Redundant check"
fi

if [[ $num1 -eq $num1 ]]; then
  echo "Always true"
fi

result=$((5 - 5))  # always 0
division=$((10 / 10))  # always 1
modulo=$((7 % 7))  # always 0

bitwise_or=$((5 | 5))  # always 5
bitwise_and=$((7 & 7))  # always 7
bitwise_xor=$((3 ^ 3))  # always 0

if [[ "$str2" > "$str2" ]]; then
  echo "Never executed"
fi
----

==== Compliant solution

[source,bash,diff-id=1,diff-type=compliant]
----
#!/bin/bash

if [[ $a == $b ]]; then
  echo "Variables are equal"
fi

if [[ -n $a ]]; then
  echo "Variable is not empty"
fi

if [[ $a == $b ]]; then
  echo "Single check is sufficient"
fi

if [[ $num1 -eq $num2 ]]; then
  echo "Number matches expected value"
fi

result=$((5 - 2))
division=$((10 / 2))
modulo=$((7 % 2))

bitwise_or=$((5 | 3))
bitwise_and=$((7 & 2))
bitwise_xor=$((3 ^ 1))

if [[ "$str1" > "$str2" ]]; then
  echo "String comparison makes sense"
fi
----

== Resources

=== Documentation

* https://www.gnu.org/software/bash/manual/bash.html#Conditional-Constructs[Bash Manual - Conditional Constructs]
* https://www.gnu.org/software/bash/manual/bash.html#Shell-Arithmetic[Bash Manual - Shell Arithmetic]
* https://tldp.org/LDP/abs/html/comparison-ops.html[Advanced Bash-Scripting Guide - Comparison Operators]
