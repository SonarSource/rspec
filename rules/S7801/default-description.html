<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This rule raises an issue when code uses conditional statements to check if ActiveRecord associations are loaded (via <code>loaded?</code> or <code>association().loaded?</code>) and then branches to different query strategies.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Checking whether associations are loaded to decide between different query strategies creates unnecessary complexity in your code. This pattern, while seemingly optimized for performance, introduces several problems.</p>
</div>
<div class="paragraph">
<p>First, it makes your code harder to read and understand. Other developers need to understand both the loaded and unloaded code paths, which increases cognitive load.</p>
</div>
<div class="paragraph">
<p>Second, it creates a maintenance burden. If the loading strategy changes elsewhere in your application, these conditional checks might break or become inefficient. Your method&#8217;s behavior becomes dependent on external loading decisions.</p>
</div>
<div class="paragraph">
<p>Third, it makes testing more complex. You need to test both scenarios - when associations are loaded and when they aren&#8217;t - which doubles your test cases for what should be a simple operation.</p>
</div>
<div class="paragraph">
<p>Finally, it can lead to inconsistent behavior. The same method call might return results in different ways depending on the loading state, which can be confusing and error-prone.</p>
</div>
<div class="sect2">
<h3 id="_what_is_the_potential_impact">What is the potential impact?</h3>
<div class="paragraph">
<p>This pattern increases code complexity and maintenance costs. It can lead to bugs when loading strategies change, makes testing more difficult, and creates inconsistent method behavior that can confuse other developers.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_fix_it_in_rails">How to fix it in Rails</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Use a consistent querying approach instead of branching on loading state. Choose either database queries or ensure associations are loaded upfront.</p>
</div>
<div class="sect2">
<h3 id="_code_examples">Code examples</h3>
<div class="sect3">
<h4 id="_noncompliant_code_example">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">def find_us_shipping_info
  if item.shipping_infos.loaded? # Noncompliant
    item.shipping_infos.detect { |si| si.region == "United States" }
  else
    item.shipping_infos.where(region: "United States").first
  end
end</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">def find_us_shipping_info
  # Always use database query for consistency
  item.shipping_infos.where(region: "United States").first
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively, use explicit eager loading strategies to ensure associations are loaded when needed, then use in-memory operations consistently.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_code_examples_2">Code examples</h3>
<div class="sect3">
<h4 id="_noncompliant_code_example_2">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">def get_related_data
  if item.association(:shipping_infos).loaded? # Noncompliant
    process_loaded_data(item.shipping_infos)
  else
    process_unloaded_data(item)
  end
end</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution_2">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">def find_us_shipping_info_with_preload
  # Ensure associations are loaded upfront
  items_with_shipping = Item.includes(:shipping_infos)
  item = items_with_shipping.find(item_id)
  item.shipping_infos.detect { |si| si.region == "United States" }
end</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_documentation">Documentation</h3>
<div class="ulist">
<ul>
<li>
<p>Rails Active Record Query Interface - <a href="https://guides.rubyonrails.org/active_record_querying.html">Official Rails guide on querying with Active Record</a></p>
</li>
<li>
<p>Rails Active Record Associations - <a href="https://guides.rubyonrails.org/association_basics.html">Official Rails guide on Active Record associations</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>