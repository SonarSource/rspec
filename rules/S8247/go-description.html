<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This rule raises an issue when shared data structures are accessed from multiple goroutines without proper synchronization mechanisms.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Go&#8217;s concurrency model allows multiple goroutines to run simultaneously, but this creates the risk of race conditions when multiple goroutines access shared data without coordination.</p>
</div>
<div class="paragraph">
<p>When goroutines access the same data structure concurrently, several problems can occur:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Data races</strong>: Multiple goroutines reading and writing the same memory location simultaneously can lead to corrupted data</p>
</li>
<li>
<p><strong>Inconsistent state</strong>: One goroutine might see partially updated data while another is still modifying it</p>
</li>
<li>
<p><strong>Unpredictable behavior</strong>: The program&#8217;s output becomes non-deterministic and depends on the timing of goroutine execution</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Many data structures in Go&#8217;s standard library are not designed for concurrent access. For example, <code>token.File.Lines()</code> returns a slice that can be modified internally, making concurrent access unsafe. Similarly, maps, slices, and most other built-in types are not thread-safe by default.</p>
</div>
<div class="paragraph">
<p>The Go memory model specifies that programs with data races have undefined behavior. This means that even seemingly simple operations like reading a variable can produce unexpected results when performed concurrently without synchronization.</p>
</div>
<div class="sect2">
<h3 id="_what_is_the_potential_impact">What is the potential impact?</h3>
<div class="paragraph">
<p>Race conditions can cause:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Data corruption</strong>: Shared data structures may become corrupted, leading to incorrect program behavior</p>
</li>
<li>
<p><strong>Program crashes</strong>: Concurrent access to maps or slices can cause runtime panics</p>
</li>
<li>
<p><strong>Security vulnerabilities</strong>: Race conditions in security-critical code can be exploited by attackers</p>
</li>
<li>
<p><strong>Difficult debugging</strong>: Race conditions are often intermittent and hard to reproduce, making them challenging to diagnose and fix</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_fix_it">How to fix it</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Use a mutex to synchronize access to shared data structures. Read-write mutexes allow multiple concurrent readers when no writer is active.</p>
</div>
<div class="sect2">
<h3 id="_code_examples">Code examples</h3>
<div class="sect3">
<h4 id="_noncompliant_code_example">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-go" data-lang="go">func processFile(file *token.File) {
    go func() {
        lines := file.Lines() // Noncompliant
        // process lines
    }()
    go func() {
        lines := file.Lines() // Noncompliant
        // process lines
    }()
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-go" data-lang="go">var mu sync.RWMutex

func processFile(file *token.File) {
    go func() {
        mu.RLock()
        lines := file.Lines()
        mu.RUnlock()
        // process lines
    }()
    go func() {
        mu.RLock()
        lines := file.Lines()
        mu.RUnlock()
        // process lines
    }()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_documentation">Documentation</h3>
<div class="ulist">
<ul>
<li>
<p>Go Memory Model - <a href="https://golang.org/ref/mem">Official documentation explaining Go&#8217;s memory model and synchronization requirements</a></p>
</li>
<li>
<p>Effective Go - Concurrency - <a href="https://golang.org/doc/effective_go#concurrency">Best practices for concurrent programming in Go</a></p>
</li>
<li>
<p>sync package - <a href="https://pkg.go.dev/sync">Documentation for Go&#8217;s synchronization primitives</a></p>
</li>
<li>
<p>sync/atomic package - <a href="https://pkg.go.dev/sync/atomic">Documentation for atomic operations in Go</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_standards">Standards</h3>
<div class="ulist">
<ul>
<li>
<p>CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization - <a href="https://cwe.mitre.org/data/definitions/362.html">Race condition vulnerability category</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_related_rules">Related rules</h3>
<div class="ulist">
<ul>
<li>
<p><a data-rspec-id="S2885" class="rspec-auto-link">RSPEC-2885</a> - <a href="https://rules.sonarsource.com/go/RSPEC-2885/">Loops should not be infinite</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>