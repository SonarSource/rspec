Using the value of a pointer to a ``++FILE++`` object after the associated file is closed is undefined behavior.

== Why is this an issue?

Once a file has been closed, its corresponding ``++FILE*++`` typed variable becomes invalid and the stream may no longer be accessed through this variable.
In particular, a pointer to a ``++FILE++`` object may not be passed to ``++fclose++`` more than once.

Using the value of a pointer to a ``++FILE++`` object after the associated file is closed results in undefined behavior.

[source,cpp]
----
#include <stdio.h>
#include <stdlib.h>

int process_file(int print) {
  FILE *f = fopen("example.txt", "r");
  if (!f) {
    perror("fopen() failed");
    return 1;
  }

  if (print) {
    char buffer[256];
    while (fgets(buffer, 256, f)) {
      printf("%s", buffer);
    }
    fclose(f);
  }

  // Further processing ...

  fclose(f); // Noncompliant: file associated with `f` might already be closed.
  return 0;
}
----

== What is the potential impact?

If a pointer to a ``++FILE++`` object is used after the associated file is closed, the behavior of the application is undefined.

When a program comprises undefined behavior, the compiler no longer needs to adhere to the language standard, and the program has no meaning assigned to it.
The application might just crash, but in the worst case, the application may appear to execute correctly, while losing data or producing incorrect results.


== How to fix it

Do not use the value of a pointer to a ``++FILE++`` object after the associated file has been closed.

=== Going the extra mile

Using {cpp}'s _RAII_ idiom can mitigate these "double-close" issues.

Following this idiom, one would create a class that manages the underlying file by opening it when the object is constructed and closing it when the object is destroyed, effectively using a constructor-destructor pair as a "do-undo"-mechanism.

An exemplary class that manages a pointer to a file is shown in what follows.

[source,cpp]
----
#include <cstdio>
#include <iostream>
#include <string>

// Although `std::fstream` should be preferred, if available, this `File` class
// does not and cannot suffer from "double-close" issues.
class File {
  FILE *f;

public:
  // Opens file stream on construction.
  File(std::string const &path, std::string const &modes) {
    f = fopen(path.c_str(), modes.c_str());
    if (!f) {
      perror("fopen() failed");
      exit(1);
    }
  }
  // Will close the file stream upon destruction.
  ~File() {
    int status = fclose(f);
    if (status == EOF) {
      perror("fclose() failed");
      exit(1);
    }
  }
  // We wish to use an object of this type only the the scope it has been
  // created in and hence disallow copying or moving it.
  File(const File &other) = delete;
  File(File &&other) = delete;
  size_t fread(void *ptr, size_t size, size_t nmemb); // Forward to C's `fread`.
  size_t fwrite(const void *ptr, size_t size,
                size_t nmemb); // Forward to C's `fwrite`.
  size_t size();               // Determine file size in bytes.
};

int main() {
  File f{"example.txt", "r"};
  size_t bytes = f.size();
  std::string buffer(bytes + 1, '\0');
  size_t items_read = f.fread(buffer.data(), bytes, 1);
  if (items_read < 1) {
    printf("Could not read items!\n");
    return 1;
  }
  std::cout << "file contents:\n" << buffer << '\n';
  // The file stream managed by `f` will be automatically closed when it goes
  // out of scope at the end of this function.
  return 0;
}
----

If falling back to low-level file operations is not necessary, one should prefer ``++std::fstream++``, for instance.


=== Code examples

==== Noncompliant code example

[source,cpp,diff-id=1,diff-type=noncompliant]
----
#include <stdio.h>
#include <stdlib.h>

int process_file(int print) {
  FILE *f = fopen("example.txt", "r");
  if (!f) {
    perror("fopen() failed");
    return 1;
  }

  if (print) {
    char buffer[256];
    while (fgets(buffer, 256, f)) {
      printf("%s", buffer);
    }
    fclose(f);
  }

  fclose(f); // Noncompliant: file associated with `f` might already be closed.
  return 0;
}
----

==== Compliant solution

[source,cpp,diff-id=1,diff-type=compliant]
----
#include <stdio.h>
#include <stdlib.h>

int process_file(int print) {
  FILE *f = fopen("example.txt", "r");
  if (!f) {
    perror("fopen() failed");
    return 1;
  }

  if (print) {
    char buffer[256];
    while (fgets(buffer, 256, f)) {
      printf("%s", buffer);
    }
  }

  if (fclose(f) == EOF) { // Compliant: file associated with `f` is closed only once.
    return 1;
  }
  return 0;
}
----


== Resources

=== Standards

* CERT - https://wiki.sei.cmu.edu/confluence/x/QdUxBQ[FIO46-C. Do not access a closed file]

=== Related rules

* S3520 addresses "double-free" memory issues


ifdef::env-github,rspecator-view[]

'''
== Implementation Specification
(visible only on this page)

=== Message

File "xxx" has already been closed.


=== Highlighting

primary: ``++FILE++`` access

secondary: where the ``++FILE++`` was closed


'''
== Comments And Links
(visible only on this page)

=== relates to: S5485

endif::env-github,rspecator-view[]
