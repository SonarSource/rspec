== Why is this an issue?

Because ``++reinterpret_cast++`` ignores the type system, it can perform dangerous conversions between unrelated types, leading to undefined behavior.

This rule reports an issue for these problematic uses of ``++reinterpret_cast++``:

* When it is used to make the compiler believe that an object in memory has a different type from its actual type because this has undefined behavior, such as casting a ``++long*++`` to ``++double*++``, even if their sizes in memory are the same (``++sizeof(long) == sizeof(double)++``).

* When it is used to cast between different levels of a complex inheritance hierarchy. A ``++static_cast++`` would apply pointer offsets to account for multiple inheritances, but ``++reinterpret_cast++`` does not.


=== Noncompliant code example

[source,cpp]
----
class X {};
class Y : virtual X {};

void example() {
  long l;
  auto a = reinterpret_cast<double&>(l); // Noncompliant: undefined behavior

  Y* y;
  auto x = reinterpret_cast<X*>(y); // Noncompliant
}
----

== Resources

=== Documentation

* {cpp} reference - https://en.cppreference.com/w/cpp/language/reinterpret_cast[``++reinterpret_cast++`` conversion]

=== Related rules

* S6181 - "std::bit_cast" should be used to reinterpret binary representation instead of "std::memcpy"
* S3630 - "reinterpret_cast" should not be used

ifdef::env-github,rspecator-view[]

'''
== Implementation Specification
(visible only on this page)

=== Message

reinterpret_cast from "XXX" to "YYY" has undefined behavior


endif::env-github,rspecator-view[]
