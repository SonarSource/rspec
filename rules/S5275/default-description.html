<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Because <code>reinterpret_cast</code> ignores the type system, it is capable of performing dangerous conversions between unrelated types which can lead to undefined behavior.</p>
</div>
<div class="paragraph">
<p>This rule reports an issue for two problematic uses of <code>reinterpret_cast</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>when it is used to make the compiler believe that an object in memory is from a different type from its real type (for instance, casting a <code>long*</code> to <code>double*</code>, because accessing a <code>long</code> as if it was a <code>double</code> is undefined behavior (even if <code>sizeof(long) == sizeof(double)</code>),</p>
</li>
<li>
<p>when it is used to cast between different levels of a complex inheritance hierarchy (a <code>static_cast</code> would apply pointer offsets to take into account multiple inheritance, for instance, but <code>reinterpret_cast</code> does not)</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_noncompliant_code_example">Noncompliant code example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">class X {};
class Y : virtual X {};

void test() {
  long l;
  auto a = reinterpret_cast&lt;double&amp;&gt;(l); // Noncompliant: undefined behavior

  Y* y;
  auto x = reinterpret_cast&lt;X*&gt;(y); // Noncompliant
}</code></pre>
</div>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_implementation_specification">Implementation Specification</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_message">Message</h3>
<div class="paragraph">
<p>reinterpret_cast from "XXX" to "YYY" has undefined behavior</p>
</div>
</div>
</div>
</div>