This rule raises an issue when code uses verbose or redundant conditional expressions to check for nil, empty strings, or falsy values instead of Ruby's idiomatic methods.

== Why is this an issue?

Ruby and Rails provide elegant, built-in methods for checking nil, empty, and falsy values, but developers often write verbose conditional expressions that are harder to read and maintain.

When checking for nil or empty values, expressions like `variable.nil? || (!variable.nil? && variable.empty?)` contain redundant logic. The `!variable.nil?` check is unnecessary because if `variable.nil?` is false, then `variable` is not nil, making the second part of the AND condition redundant due to short-circuit evaluation.

Similarly, manual checks like `@user.city != nil && @user.city != ""` are verbose and error-prone. Rails provides the `present?` method that handles nil, empty strings, whitespace-only strings, and empty collections in a single, clear method call.

Using non-idiomatic comparisons like `value == nil` instead of `value.nil?` goes against Ruby conventions and reduces code readability. The `nil?` method is more explicit about the intent and follows Ruby's predicate method naming convention.

Complex nested conditions for checking nil and false values can often be simplified using Ruby's safe navigation operator (`&.`) introduced in Ruby 2.3, which safely calls methods on potentially nil objects without explicit nil checks.

=== What is the potential impact?

Using verbose conditional expressions instead of idiomatic Ruby methods reduces code readability and maintainability. Complex conditions are more prone to logical errors and make the codebase harder to understand for other developers. This can slow down development and increase the likelihood of bugs in conditional logic.

== How to fix it

Replace redundant nil checks with simplified boolean logic. Remove unnecessary nil checks in expressions that already benefit from short-circuit evaluation.

=== Code examples

==== Noncompliant code example

[source,ruby,diff-id=1,diff-type=noncompliant]
----
# Redundant nil check due to short-circuit evaluation
variable = id if variable.nil? || (!variable.nil? && variable.empty?) // Noncompliant
----

==== Compliant solution

[source,ruby,diff-id=1,diff-type=compliant]
----
# Simplified boolean logic without redundant checks
variable = id if variable.nil? || variable.empty?
----

== How to fix it in Rails

Use Rails' `present?` method instead of manual nil and empty string checks. The `present?` method returns true if the value is not nil, not empty, and not whitespace-only.

=== Code examples

==== Noncompliant code example

[source,ruby,diff-id=2,diff-type=noncompliant]
----
# Verbose manual checks for nil and empty
@city = @user.city != nil && @user.city != "" // Noncompliant
----

==== Compliant solution

[source,ruby,diff-id=2,diff-type=compliant]
----
# Use .present? to check if value exists and has content
@city = @user.city.present?
----

== Resources

=== Documentation

 * Ruby Safe Navigation Operator - https://ruby-doc.org/core/doc/syntax/calling_methods_rdoc.html#label-Safe+navigation+operator[Official Ruby documentation on the safe navigation operator (&.)]

 * Rails Object#blank? and Object#present? - https://api.rubyonrails.org/classes/Object.html#method-i-blank-3F[Rails API documentation for blank? and present? methods]

 * Ruby Predicate Methods - https://ruby-doc.org/core/Object.html#method-i-nil-3F[Ruby documentation on predicate methods like nil?]

=== Related rules

 * S6582 - https://rules.sonarsource.com/javascript/RSPEC-6582/[JavaScript rule for using optional chaining instead of logical AND]

 * S1155 - https://rules.sonarsource.com/csharp/RSPEC-1155/[C# rule for using Any() to test for emptiness]
