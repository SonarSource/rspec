This rule raises an issue when code manually copies slice elements or manages slice growth instead of using Go's built-in `copy()` and `append()` functions.

== Why is this an issue?

Go provides optimized built-in functions `copy()` and `append()` specifically designed for slice management. These functions are not only more efficient than manual implementations but also more readable and less error-prone.

Manual slice operations often involve writing loops to copy elements one by one or complex logic to manage slice capacity. This approach has several drawbacks:

* **Performance**: Built-in functions are optimized at the runtime level and can use efficient memory copying techniques
* **Readability**: Manual loops obscure the intent of the operation, making code harder to understand
* **Error-prone**: Manual implementations can introduce bugs like off-by-one errors or incorrect capacity management
* **Maintenance**: Custom slice operations require more code that needs to be tested and maintained

The `copy()` function efficiently copies elements from a source slice to a destination slice, handling the copying process optimally. The `append()` function manages slice growth automatically, reallocating memory when needed and copying existing elements efficiently.

=== What is the potential impact?

Using manual slice operations instead of built-in functions can lead to:

* **Reduced performance** due to less efficient copying mechanisms
* **Increased code complexity** making the codebase harder to maintain
* **Higher risk of bugs** from manual index management and boundary checks
* **Slower development** as developers spend time implementing and testing basic slice operations

== How to fix it

Replace manual slice copying loops with the built-in `copy()` function. The `copy()` function efficiently copies elements from source to destination slice.

=== Code examples

==== Noncompliant code example

[source,go,diff-id=1,diff-type=noncompliant]
----
// Manual slice copying
func copySlice(src []int) []int {
    dst := make([]int, len(src))
    for i, v := range src { // Noncompliant
        dst[i] = v
    }
    return dst
}
----

==== Compliant solution

[source,go,diff-id=1,diff-type=compliant]
----
// Using built-in copy function
func copySlice(src []int) []int {
    dst := make([]int, len(src))
    copy(dst, src)
    return dst
}
----

== Resources

=== Documentation

 * Go Language Specification - Appending and copying slices - https://go.dev/ref/spec#Appending_and_copying_slices[Official specification for Go's built-in copy and append functions]

 * Go Blog - Go Slices: usage and internals - https://go.dev/blog/slices-intro[Comprehensive guide to understanding and using slices in Go]

 * Effective Go - Slices - https://go.dev/doc/effective_go#slices[Best practices for working with slices in Go]
