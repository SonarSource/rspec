This is an issue when goroutines are started in the main function without using synchronization mechanisms like `sync.WaitGroup` or channels to ensure they complete before the program exits.

== Why is this an issue?

In Go, when the main goroutine (the main function) exits, the entire program terminates immediately. Any other goroutines that are still running will be abruptly stopped, regardless of their completion status.

This behavior can lead to several problems:

* *Incomplete operations*: Background tasks may be terminated mid-execution, leaving work unfinished
* *Data loss*: Goroutines writing to files, databases, or network connections may not complete their operations
* *Resource leaks*: Connections, file handles, or other resources may not be properly closed
* *Inconsistent state*: Partially completed operations can leave the system in an undefined state

Unlike some other programming languages where background threads might continue running, Go's runtime design ensures that all goroutines are tied to the main program's lifecycle. This makes proper synchronization essential for reliable program behavior.

The issue is particularly common in simple programs or examples where developers start goroutines for background work but forget to wait for their completion.

=== What is the potential impact?

The program may terminate before important background operations complete, potentially leading to data loss, incomplete file writes, unclosed network connections, or other reliability issues. While not a security vulnerability, this can cause unpredictable behavior and make applications unreliable in production environments.

== How to fix it

Use `sync.WaitGroup` to wait for all goroutines to complete before the main function exits. Call `Add()` before starting each goroutine, `Done()` when each goroutine finishes, and `Wait()` in the main function.

=== Code examples

==== Noncompliant code example

[source,go,diff-id=1,diff-type=noncompliant]
----
func main() {
    go func() {
        fmt.Println("Background work")
        time.Sleep(2 * time.Second)
    }() // Noncompliant
    // Program exits immediately, goroutine may not complete
}
----

==== Compliant solution

[source,go,diff-id=1,diff-type=compliant]
----
func main() {
    var wg sync.WaitGroup
    wg.Add(1)
    go func() {
        defer wg.Done()
        fmt.Println("Background work")
        time.Sleep(2 * time.Second)
    }()
    wg.Wait() // Wait for goroutine to complete
}
----

== Resources

=== Documentation

 * Go Concurrency Patterns - https://go.dev/blog/pipelines[Official Go blog post about concurrency patterns and synchronization]

 * Effective Go - Goroutines - https://go.dev/doc/effective_go#goroutines[Official Go documentation on goroutines and concurrency]

 * Go sync package - https://pkg.go.dev/sync[Documentation for Go's sync package including WaitGroup]
