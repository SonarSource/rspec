In the scope of a class, you should make sure to consistently use nullability annotations on fields, setters, getters and constructors argument, in order to ensure the correct execution of your program.

More precisely, this rules report an issue when:

* a Nullable field is returned from a getter not annotated
* a Nullable field is set from a argument of constructor/setter not annotated
* a Nullable parameter from a constructor/setter is set to a field not annotated
* a Nullable getter returns a field not annotated

== Noncompliant Code Example

----
@CheckForNull
private String f;

NullabilityConsistency(String f) { // Noncompliant: annotate this argument with "@CheckForNull"
  this.f = f;
}
public String getF() { // Noncompliant: annotated this method with "@CheckForNull"
  return f;
}
----

----
private String f; // Noncompliant: annotated this field with "@CheckForNull"

@CheckForNull
public String getF() {
  return f;
}
----

----
private String f; // Noncompliant: annotated this field with "@Nullable"

NullabilityConsistency(@Nullable String f) {
  this.f = f;
}
----

== Compliant Solution

----
@CheckForNull
private String f;

NullabilityConsistency(@CheckForNull String f) { // Noncompliant: annotate this argument with "@CheckForNull"
  this.f = f;
}
@CheckForNull
public String getF() { // Noncompliant: annotated this method with "@CheckForNull"
  return f;
}
----

----
@CheckForNull
private String f;

@CheckForNull
public String getF() {
  return f;
}
----

----
@Nullable
private String f;

NullabilityConsistency(@Nullable String f) {
  this.f = f;
}
----


== See

FIXME: A list of links
