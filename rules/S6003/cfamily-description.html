<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Sometimes, <code>emplace_back</code> is more efficient and less verbose than <code>push_back</code>. It is expected to be faster when the object is constructed into the container instead of being constructed and assigned. This also happens when the pushed object has a different type from the one held by the container.</p>
</div>
<div class="paragraph">
<p>This rule supports standard sequence containers: <code>std::vector</code>, <code>std::list</code>, <code>std::deque</code>, <code>std::forward_list</code>, <code>std::stack</code>, <code>std::queue</code> and <code>std::priority_queue</code>.</p>
</div>
<div class="paragraph">
<p>The rule raises an issue when an insertion function on a supported container leads to constructing a large temporary object that can be avoided using the provided emplacement member function.</p>
</div>
<div class="sect2">
<h3 id="_noncompliant_code_example">Noncompliant code example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">class Circle { // Large object
std::string s;
int x;
int y;
int radius;
public:
  Circle(int x, int y, int radius);
}

void f() {
  std::vector&lt;std::pair&lt;int, std::string&gt;&gt; vec1;
  std::string s;
  vec1.push_back(std::make_pair(21, s)); // Noncompliant
  std::vector&lt;std::string&gt; vec2;
  vec2.push_back("randomStr"); // Noncompliant, conversion from char const * to string
  std::vector&lt;Circle&gt; circles;
  circles.push_back(Circle{2, 42, 10}); // Noncompliant
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_compliant_solution">Compliant solution</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">class Circle { // Large object
std::string s;
int x;
int y;
int radius;
public:
  Circle(int x, int y, int radius);
}

void f() {
  std::vector&lt;std::pair&lt;int, std::string&gt;&gt; vec1;
  std::string s;
  vec1.emplace_back(21, s); // Compliant
  std::vector&lt;std::string&gt; vec2;
  vec2.emplace_back("randomStr"); // Compliant
  std::vector&lt;Circle&gt; circles;
  circles.emplace_back(2, 42, 10); // Compliant
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_exceptions">Exceptions</h3>
<div class="paragraph">
<p>The rule does not raise an issue when <code>emplace_back</code> is not exception-safe. For example, when emplacing a raw new expression in a container of smart pointers, the memory will be leaked if <code>emplace_back</code> throws an exception.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>Effective modern C&#43;&#43; item 42: Consider emplacement instead of insertion.</p>
</li>
</ul>
</div>
</div>
</div>