This rule raises an issue when Angular output properties are given aliases that don't follow the conventional selector-prefixed naming pattern.

== Why is this an issue?

Aliasing output bindings can create confusion and reduce code maintainability in Angular applications. When an output property has a different name than what appears in the template, it becomes harder for developers to understand the relationship between the component's internal implementation and its public API.

For example, if a component has `@Output('change') valueChanged = new EventEmitter()`, developers using this component will see `(change)` in templates but `valueChanged` in the component code. This disconnect makes the codebase harder to navigate and understand.

The only exception to this rule is when the alias follows Angular's conventional pattern of prefixing the output name with the component's selector. This pattern is commonly used in Angular's own components and helps avoid naming conflicts while maintaining clarity about which component the output belongs to.

=== What is the potential impact?

Aliased output bindings can lead to:

* Reduced code readability and maintainability
* Confusion for team members who need to understand the relationship between template usage and component implementation
* Increased cognitive load when debugging or modifying components
* Inconsistent naming patterns across the codebase

=== How to fix in Angular?

Remove the alias from the @Output decorator and use the property name directly in templates.

==== Non-compliant code example

[source,javascript,diff-id=1,diff-type=noncompliant]
----
@Component()
class MyComponent {
  @Output('change') valueChanged = new EventEmitter(); // Noncompliant
}
----

==== Compliant code example

[source,javascript,diff-id=1,diff-type=compliant]
----
@Component()
class MyComponent {
  @Output() valueChanged = new EventEmitter();
}
----

Remove the alias from the output() function and use the property name directly in templates.

==== Non-compliant code example

[source,javascript,diff-id=2,diff-type=noncompliant]
----
@Component()
class MyComponent {
  valueChanged = output({ alias: 'change' }); // Noncompliant
}
----

==== Compliant code example

[source,javascript,diff-id=2,diff-type=compliant]
----
@Component()
class MyComponent {
  valueChanged = output();
}
----

Remove aliases from the outputs array in component metadata.

==== Non-compliant code example

[source,javascript,diff-id=3,diff-type=noncompliant]
----
@Component({
  outputs: ['valueChanged: change'] // Noncompliant
})
class MyComponent {}
----

==== Compliant code example

[source,javascript,diff-id=3,diff-type=compliant]
----
@Component({
  outputs: ['valueChanged']
})
class MyComponent {}
----

If you need to use an alias, follow the conventional pattern of prefixing with the component selector.

==== Non-compliant code example

[source,javascript,diff-id=4,diff-type=noncompliant]
----
@Component({
  selector: 'my-button'
})
class MyButtonComponent {
  @Output('click') buttonClick = new EventEmitter(); // Noncompliant
}
----

==== Compliant code example

[source,javascript,diff-id=4,diff-type=compliant]
----
@Component({
  selector: 'my-button'
})
class MyButtonComponent {
  @Output('myButtonClick') buttonClick = new EventEmitter();
}
----

=== Documentation

 * Angular Output Decorator - https://angular.io/api/core/Output[Official Angular documentation for the @Output decorator]
 * Angular Component Interaction - https://angular.io/guide/component-interaction#parent-listens-for-child-event[Guide on how components communicate through events]
 * Angular output() Function - https://angular.io/api/core/output[Official documentation for the output() function in Angular]

=== Related Rules

 * @angular-eslint/no-input-rename - https://github.com/angular-eslint/angular-eslint/blob/main/packages/eslint-plugin/docs/rules/no-input-rename.md[Similar rule that prevents aliasing input properties]

