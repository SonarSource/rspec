This rule raises an issue when a collection (list, tuple, set, or dict) is passed directly to a scalar type conversion function like `int()`, `float()`, `str()`, `bool()`, or `complex()`.

== Why is this an issue?

Scalar type conversion functions like `int()`, `float()`, and `str()` are designed to work with individual values, not collections. When you pass a collection to these functions, Python raises a `TypeError` because the function doesn't know how to convert multiple values into a single scalar.

This error commonly occurs in several scenarios:

* **Direct conversion attempts**: Trying to convert an entire list or tuple to a number
* **API response handling**: When functions return collections but the calling code expects scalar values
* **Data processing pipelines**: Where intermediate steps return collections that need element extraction

The root cause is usually a misunderstanding of what data type a function returns, or forgetting to extract the specific element needed from a collection. This can happen when working with APIs, database queries, or any function that returns structured data.

For example, if an API returns `['123']` (a list with one string element) and you try `int(['123'])`, Python cannot determine which element to convert or how to handle multiple elements.

=== What is the potential impact?

This issue causes immediate runtime failures with `TypeError` exceptions, leading to application crashes. In production environments, this can result in:

* **Service disruption**: Critical functionality becomes unavailable
* **Data processing failures**: Batch jobs or data pipelines stop working
* **User experience degradation**: Features that depend on the conversion become unusable
* **Debugging overhead**: Developers need time to identify and fix the type mismatch

The error is typically caught during testing, but if it occurs in edge cases or with specific data inputs, it might reach production and cause unexpected failures.

== How to fix it

Extract the specific element you need from the collection before converting it. Use indexing to access individual elements.

=== Code examples

==== Noncompliant code example

[source,python,diff-id=1,diff-type=noncompliant]
----
data = ['123', '456', '789']
value = int(data)  # Noncompliant
----

==== Compliant solution

[source,python,diff-id=1,diff-type=compliant]
----
data = ['123', '456', '789']
value = int(data[0])  # Convert first element
----

== Resources

=== Documentation

 * Python Built-in Functions - https://docs.python.org/3/library/functions.html[Official documentation for Python's built-in type conversion functions]

 * Python Data Structures - https://docs.python.org/3/tutorial/datastructures.html[Guide to working with lists, tuples, and other Python data structures]
