In asynchronous programming in Kotlin with coroutines there are 2 ways of defining an async function. The first one is using modifier `suspend` in the function declaration and the second one is to create an extension function on `CoroutineScope`.

`suspend` modifier is used for the functions that might take some time to compute the result. Which means that they can potentially suspend the caller coroutine.

For the functions that return result immediately but are starting the coroutine in the background it is suggested to write an extension function for `CoroutineScope`.

Functions returning `Flow` or `Channel` are supposed to return the result immediately and might want to start a new coroutine in the background. So we should not mark them as `suspend` and if there is a need to launch some coroutine in the background, it's recommended to make them extension functions on `CoroutineScope`. 

== Noncompliant Code Example

----
suspend fun f(): Flow<Int> {
    var flowCollector: FlowCollector<Int>? = null
    val flow = flow<Int> {
        flowCollector = this
    }
    flowCollector?.emit(1)
    return flow
}

suspend fun f(): Channel<Int> {
    val ch = Channel<Int>()
    ch.send(1)
    return ch
}
----

== Compliant Solution

----
fun f(): Flow<Int> = flow {
    emit(1)
}

fun CoroutineScope.f(): Channel<Int> {
    val ch = Channel<Int>()
    launch {
        ch.send(1)
    }
    return ch
}
----
