There are two ways to define asynchronous functions in Kotlin:

* using the modifier suspend in the function declaration
* creating an extension function on CoroutineScope

The `suspend` modifier is generally used for functions that might take some time to complete. The caller coroutine might potentially be suspended.

For the functions that return results immediately but starts the coroutine in the background, it is suggested to write an extension function on `CoroutineScope`. This means that extension functions on `CoroutineScopes` are not supposed to be suspending.

Functions returning `Flow` or `Channel` are supposed to return the result immediately and might want to start a new coroutine in the background. As a consequence, such functions should not be suspending. If there is a need to launch some coroutine in the background, it's recommended to declare them as extension functions on `CoroutineScope`.

== Noncompliant Code Example

----
suspend fun f(): Flow<Int> {
    val flow = flow {
        emit(1)
    }
    delay(500L)
    return flow
}
----

----
suspend fun f(): Channel<Int> {
    val ch = Channel<Int>()
    ch.send(1)
    return ch
}
----

== Compliant Solution

----
fun f(): Flow<Int> = flow {
    emit(1)
}
----

----
fun CoroutineScope.f(): Channel<Int> {
    val ch = Channel<Int>()
    launch {
        ch.send(1)
    }
    return ch
}
----

== See
* https://elizarov.medium.com/coroutine-context-and-scope-c8b255d59055[Coroutine Context and Scope]
