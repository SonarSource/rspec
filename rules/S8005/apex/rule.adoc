This rule raises an issue when code processes responses from external systems without proper validation of status codes, response content, or expected data fields.

== Why is this an issue?

When integrating with external systems, responses can be unpredictable. Network issues, server errors, or changes in external APIs can result in unexpected response formats, missing data, or error conditions.

Processing unvalidated responses can lead to several problems:

* *Runtime exceptions*: Attempting to deserialize malformed JSON or access missing fields throws exceptions that can crash your application
* *Data corruption*: Null or unexpected values might be stored in your system, leading to inconsistent data states
* *Security vulnerabilities*: Malicious or malformed responses could potentially exploit deserialization vulnerabilities
* *Poor user experience*: Unhandled errors result in cryptic error messages instead of meaningful feedback

Proper validation acts as a defensive barrier, ensuring your code gracefully handles unexpected scenarios and maintains system stability.

=== What is the potential impact?

Without proper validation, applications become vulnerable to runtime exceptions, data corruption, and potential security exploits. Failed integrations can disrupt business processes and create poor user experiences with unclear error messages.

== How to fix it

Always validate HTTP response status codes, check for response body content, and verify expected fields exist before accessing them. Use defensive programming techniques to handle edge cases gracefully.

=== Code examples

==== Noncompliant code example

[source,apex,diff-id=1,diff-type=noncompliant]
----
HttpResponse response = http.send(request);
Map<String, Object> responseMap = (Map<String, Object>) JSON.deserializeUntyped(response.getBody()); // Noncompliant
String customerId = (String) responseMap.get('customerId'); // Noncompliant
----

==== Compliant solution

[source,apex,diff-id=1,diff-type=compliant]
----
HttpResponse response = http.send(request);
if (response.getStatusCode() == 200 && String.isNotBlank(response.getBody())) {
    Map<String, Object> responseMap = (Map<String, Object>) JSON.deserializeUntyped(response.getBody());
    if (responseMap.containsKey('customerId') && responseMap.get('customerId') != null) {
        String customerId = (String) responseMap.get('customerId');
        // Process the validated data
    } else {
        // Handle missing customerId
    }
} else {
    // Handle error response
}
----

== Resources

=== Documentation

 * Salesforce HTTP Classes - https://developer.salesforce.com/docs/atlas.en-us.apexref.meta/apexref/apex_classes_restful_http.htm[Official documentation for HTTP request and response handling in Apex]

 * JSON Class Methods - https://developer.salesforce.com/docs/atlas.en-us.apexref.meta/apexref/apex_class_System_Json.htm[Documentation for JSON serialization and deserialization methods in Apex]

 * Integration Best Practices - https://developer.salesforce.com/docs/atlas.en-us.integration_patterns_and_practices.meta/integration_patterns_and_practices/[Salesforce integration patterns and best practices guide]

=== Standards

 * CWE-20: Improper Input Validation - https://cwe.mitre.org/data/definitions/20.html[Weakness related to insufficient validation of input data]

 * CWE-754: Improper Check for Unusual or Exceptional Conditions - https://cwe.mitre.org/data/definitions/754.html[Weakness related to insufficient handling of exceptional conditions]
