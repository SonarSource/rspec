This rule raises an issue when a function uses a boolean flag variable in a loop that continues iterating after the flag is set to true, instead of returning immediately.

== Why is this an issue?

When a function searches through a data structure using a loop, continuing to process elements after finding the desired result wastes computational resources and reduces performance.

Consider a function that checks if a specific type exists in a slice. If it uses a boolean flag and continues looping after finding a match, it will unnecessarily examine all remaining elements. This becomes particularly problematic with large data structures where the target might be found early in the iteration.

The pattern typically involves:

* A boolean variable initialized to `false`
* A loop that sets the variable to `true` when a condition is met
* The loop continues executing even after the condition is satisfied
* The boolean variable is returned at the end

This approach has several drawbacks. First, it performs unnecessary work by continuing to iterate after the result is known. Second, it makes the code less readable because the intent (finding the first match) is not immediately clear. Third, it can impact performance significantly when dealing with large datasets or expensive operations within the loop.

=== What is the potential impact?

The unnecessary processing can degrade application performance, especially when dealing with large data structures or when the function is called frequently. In performance-critical applications, this inefficiency can lead to increased response times and higher resource consumption.

== How to fix it

Replace the boolean flag pattern with an early return. When the condition is met, return immediately instead of setting a flag and continuing the loop.

=== Code examples

==== Noncompliant code example

[source,go,diff-id=1,diff-type=noncompliant]
----
func hasTargetType(entries []Entry) bool {
    found := false
    for _, entry := range entries {
        if entry.Type == TargetType {
            found = true // Noncompliant
        }
        // continues processing remaining entries
    }
    return found
}
----

==== Compliant solution

[source,go,diff-id=1,diff-type=compliant]
----
func hasTargetType(entries []Entry) bool {
    for _, entry := range entries {
        if entry.Type == TargetType {
            return true // early return when condition is met
        }
    }
    return false
}
----

== Resources

=== Documentation

 * Go Performance Tips - https://github.com/golang/go/wiki/Performance[Official Go wiki page covering performance optimization techniques]

 * Effective Go - Control Structures - https://golang.org/doc/effective_go#control-structures[Official Go documentation on control structures and best practices]

=== Standards

 * Go Code Review Comments - Early Returns - https://github.com/golang/go/wiki/CodeReviewComments#early-returns[Go community guidelines recommending early returns for cleaner code]
