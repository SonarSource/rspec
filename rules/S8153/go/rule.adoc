This rule raises an issue when `nil` is passed as a `context.Context` parameter to a function call.

== Why is this an issue?

In Go, the `context` package is designed to carry deadlines, cancellation signals, and request-scoped values across API boundaries. When you pass `nil` as a Context parameter, you break this chain and create several problems.

First, passing `nil` context can cause runtime panics. Many functions that accept a Context parameter will call methods on it (like `ctx.Done()` or `ctx.Err()`). When the context is `nil`, these method calls will panic and crash your program.

Second, `nil` contexts prevent proper cancellation and timeout handling. Context is Go's standard way to signal when operations should be cancelled or when they've exceeded their allowed time. By passing `nil`, you lose this capability, which can lead to operations running longer than intended.

Third, `nil` contexts can cause resource leaks. Without proper context propagation, goroutines and other resources may not be cleaned up when they should be, leading to memory leaks and degraded performance over time.

The Go documentation explicitly states: "Do not pass a nil Context, even if a function permits it." This guidance exists because even if a function can technically handle `nil` context, it's almost never the right choice.

=== What is the potential impact?

Passing `nil` context can cause runtime panics that crash the application. It also prevents proper cancellation and timeout handling, potentially leading to resource leaks, uncontrolled operations, and degraded performance. In server applications, this can result in goroutine leaks and memory exhaustion.

== How to fix it

Replace `nil` with `context.TODO()` when you're unsure which context to use, or with `context.Background()` for top-level operations.

=== Code examples

==== Noncompliant code example

[source,go,diff-id=1,diff-type=noncompliant]
----
func callService() {
    result := serviceCall(nil, "data") // Noncompliant
    // process result
}
----

==== Compliant solution

[source,go,diff-id=1,diff-type=compliant]
----
func callService() {
    result := serviceCall(context.TODO(), "data")
    // process result
}
----

== Resources

=== Documentation

 * Go Context Package Documentation - https://pkg.go.dev/context[Official Go documentation for the context package, including best practices and usage guidelines]

 * Go Blog: Context and Structs - https://go.dev/blog/context-and-structs[Detailed explanation of how to properly use Context in Go applications]

 * Go Blog: Context - https://go.dev/blog/context[Introduction to Go's context package with examples]
