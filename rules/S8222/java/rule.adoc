This rule raises an issue when code uses the `Duration.withNanos()` or `Duration.withSeconds()` methods.

== Why is this an issue?

The `Duration.withNanos()` and `Duration.withSeconds()` methods have confusing behavior that can lead to bugs. These methods only modify one field while keeping the other field unchanged.

`duration.withNanos(newNanos)` sets the nanoseconds but keeps the original seconds. `duration.withSeconds(newSeconds)` sets the seconds but keeps the original nanoseconds.

This partial mutation is unexpected and can cause timing bugs when developers assume both fields are set explicitly.

=== What is the potential impact?

Using these methods can introduce timing bugs where durations have unexpected nanosecond or second components, leading to incorrect calculations and comparisons in time-sensitive applications.

== How to fix it

Use `Duration.ofSeconds()` to explicitly set both seconds and nanoseconds.

=== Code examples

==== Noncompliant code example

[source,java,diff-id=1,diff-type=noncompliant]
----
Duration duration = Duration.ofSeconds(5, 123456789);
Duration modified = duration.withNanos(987654321); // Noncompliant
----

==== Compliant solution

[source,java,diff-id=1,diff-type=compliant]
----
Duration duration = Duration.ofSeconds(5, 123456789);
Duration modified = Duration.ofSeconds(duration.getSeconds(), 987654321);
----

== Resources

=== Documentation

 * Duration (Java SE 17 & JDK 17) - https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/time/Duration.html[Official Java documentation for the Duration class]
