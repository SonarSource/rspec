The first element of the array should be accessed using the subscript operator (`array[0]`),
instead of dereference (``++*array++``) or arrow (``++array->mem++``).

== Why is this an issue?

When an expression refers to a variable or another object of array type,
it usually produces a pointer to the first element of the array. 
This behavior is known as array-to-pointer decay or simply array decay.

Because of array-to-pointer decay, it is possible to use the dereference operator (`*`) or
the pointer member access operator (``++->++``) on an array object to access the first element.
However, it remains unclear if access to such elements was done intentionally.
In contrast, using array subscript (`[0]`) removes any such ambiguity.

This rule raises an issue when deference or member access operator is used
on array object.

[source,c]
----
struct Struct { int x; };
Struct elems[10];
int integers[5]; 

void init() {
  for (int i = 0; i < 5; ++i) {
    *integers = i; // Noncomliant: `*` used to access `integers[0]`
  }
}

void prcess() {
  for (int i = 0; i < 10; ++i) {
    Struct* elem = elems + i;
    elems->x += elems[i].x; // Noncomplaint: `->` used to access `elems[0]`
  }
}
----

== How to fix it

The fix depends on the intended effect of the code, but either

* access of the first element was intentional, and uses of ``++->++`` or `*` should be replaced with subscripts with index `0`;
* other element was meant to be accessed, and subscript appropriate index value may be used;
* pointer values were meant to be dereferenced; in that case, the array should be replaced with the given pointer.

=== Code examples

==== Noncompliant code example

[source,c,diff-id=1,diff-type=noncompliant]
----
struct Struct { int x; };
Struct elems[10];

void prcess() {
  for (int i = 0; i < 10; ++i) {
    Struct* elem = elems + i;
    elems->x += elems[i].x; // Noncomplaint: -> used to access elems[0]
  }
}
----

==== Compliant solution

If the access to the first element was intentional, you can use subscript explicitly:
[source,cpp,diff-id=1,diff-type=compliant]
----
struct Struct { int x; };
Struct elems[10];

void prcess() {
  for (int i = 0; i < 10; ++i) {
    Struct* elem = elems + i;
    elems[0].x += elems[i].x; // Complaint: subscript is used to access array
  }
}
----

Otherwise, if ``++i++``th element was to be updated:
[source,cpp]
----
struct Struct { int x; };
Struct elems[10];

void prcess() {
  for (int i = 0; i < 10; ++i) {
    Struct* elem = elems + i;
    elems[i].x += elems[i].x; // Complaint: subscript is used to access array
  }
}
----

Finally, the ``++i++``th element can be accessed using ``++->++`` and `elem` pointer:
[source,cpp]
----
struct Struct { int x; };
Struct elems[10];

void prcess() {
  for (int i = 0; i < 10; ++i) {
    Struct* elem = elems + i;
    elem->x += elem->x; // Complaint: dereferencing an pointer
  }
}
----



=== Code examples

==== Noncompliant code example

[source,cpp,diff-id=2,diff-type=noncompliant]
----
int integers[5]; 

void init() {
  for (int i = 0; i < 5; ++i) {
    *integers = i; // Noncomliant: `*` used to access `integers[0]`
  }
}
----

==== Compliant solution

Access ``++i++``th element of `integers` as intended:

[source,cpp,diff-id=2,diff-type=compliant]
----
int integers[5]; 

void init() {
  for (int i = 0; i < 5; ++i) {
    integers[i] = i; // Complaint: subscript is used to access array
  }
}
----

Or, to preserve current behavior, use subscript to access the first element:

[source,cpp]
----
int integers[5]; 

void init() {
  for (int i = 0; i < 5; ++i) {
    integers[0] = i; // Complaint: subscript is used to access array
  }
}
----


== Resources

=== Documentation

* {cpp} reference - https://en.cppreference.com/w/cpp/language/array#Array-to-pointer_decay[Array-to-pointer decay]

