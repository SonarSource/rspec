This is an issue when a Go module's path contains a major version suffix that doesn't match the actual major version number used in version tags or requirements.

== Why is this an issue?

Go's module system relies on major version suffixes to implement the import compatibility rule, which states that if an old package and a new package have the same import path, the new package must be backwards compatible with the old package.

Starting with major version 2, Go modules must include a major version suffix in their module path (like `/v2`, `/v3`, etc.) that corresponds to the actual major version number. This suffix becomes part of the import path, allowing multiple major versions of the same module to coexist in a single build.

When there's a mismatch between the module path's major version suffix and the actual semantic version number, several problems occur:

* **Dependency resolution failures**: The Go toolchain cannot correctly resolve which version of a module to use, leading to build errors or unexpected behavior.
* **Import path confusion**: Developers and tools cannot reliably determine which major version they're working with, making dependency management unpredictable.
* **Violation of semantic versioning**: The mismatch breaks the semantic versioning contract that Go modules depend on for compatibility guarantees.
* **Module proxy issues**: Module proxies and the Go module system expect consistent versioning, and mismatches can cause modules to be incorrectly cached or served.

The consistency requirement ensures that when you import `example.com/mod/v3`, you're guaranteed to get a v3.x.x version of that module, maintaining the predictability and reliability that Go's module system provides.

=== What is the potential impact?

This inconsistency can cause build failures, dependency resolution errors, and unpredictable behavior in Go applications. It violates Go's module versioning contract and can lead to incorrect module selection by the Go toolchain, potentially breaking builds or causing runtime issues when the wrong version is loaded.

== How to fix it

Update the module path to match the semantic version. If you're releasing version v2.1.0, the module path should have a /v2 suffix.

=== Code examples

==== Noncompliant code example

[source,go,diff-id=1,diff-type=noncompliant]
----
module example.com/mod/v3
require example.com/mod/v3 v2.1.0 // Noncompliant
----

==== Compliant solution

[source,go,diff-id=1,diff-type=compliant]
----
module example.com/mod/v2
require example.com/mod/v2 v2.1.0
----

== Resources

=== Documentation

 * Go Modules Reference - Major version suffixes - https://go.dev/ref/mod#major-version-suffixes[Official documentation explaining major version suffixes in Go modules]

 * Go Modules: v2 and Beyond - https://go.dev/blog/v2-go-modules[Blog post explaining how to handle major version changes in Go modules]

 * Go Modules Reference - Versions - https://go.dev/ref/mod#versions[Official documentation on semantic versioning in Go modules]

=== Standards

 * Semantic Versioning 2.0.0 - https://semver.org/[The semantic versioning specification that Go modules follow]
