<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>C&#43;&#43;20 introduces full template support for lambda functions on par with the regular template functions. The full template syntax for a lambda adds a template-arguments clause after the capture clause completing the panoply of brackets: []&lt;&gt;(){}. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>[]&lt;typename T&gt;(T arg) { return arg; }</pre>
</div>
</div>
<div class="paragraph">
<p>Although more verbose than using <code>auto</code> for the types of the arguments, this syntax enables you to name the types for the parameters, constrain these types (see Concepts), and reuse these types for multiple arguments.</p>
</div>
<div class="paragraph">
<p>One common use case for the named template argument is a lambda with multiple arguments of the same type. Pre-C&#43;&#43;20 code had to resort to the use of <code>decltype</code>: <code>[](auto arg1, decltype(arg1) arg2) ... </code>. Not only is it obscure it also only approximates our goal: it requires the second-argument type to be convertible to the first-argument type.</p>
</div>
<div class="paragraph">
<p>Moreover, similar issues may appear for normal functions, that declare parameters with <code>auto</code> in place of type using C&#43;&#43;20 abbreviated template syntax.</p>
</div>
<div class="paragraph">
<p>This rule reports the use of <code>decltype(arg)</code> for parameters introduced with <code>auto</code>.</p>
</div>
<div class="sect2">
<h3 id="_noncompliant_code_example">Noncompliant code example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">void f1() {
  auto sum = [](auto fir, decltype(fir) sec) { return fir + sec; }; // Noncompliant
  std::cout &lt;&lt; sum(true, 1); // Prints 2
}

void f2(auto param) {  // Noncompliant
   decltype(param) copy = param;
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_compliant_solution">Compliant solution</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">void f1() {
  auto sum = []&lt;class T&gt;(T fir, T sec) { return fir + sec; }; // Compliant
  // std::cout &lt;&lt; sum(true, 1); - compilation error
}

template&lt;class T&gt;
void f2(T param) { // Compliant
    T copy = param;
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a href="https://www.modernescpp.com/index.php/more-powerful-lambdas-with-c-20">Modern C&#43;&#43;: More powerful lambdas with C&#43;&#43;20</a></p>
</li>
</ul>
</div>
</div>
</div>