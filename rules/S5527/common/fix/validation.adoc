To fix the vulnerability of disabled hostname validation, it is strongly
recommended to first re-enable the default validation.

To avoid running into problems with invalid hostnames, consider the following
sections.

==== If the connection to the remote server is not possible, otherwise

**One system's code should not work around another system's problems**, as this
creates unnecessary dependencies and can lead to reliability issues. Therefore,
the first solution is to change the remote host's certificate to match its
identity. If the remote host is uncontrolled, replicate its service to a
controlled server whose certificate you can change yourself.

==== If the remote host name is dynamic or private

In this case, the cleanest solution is to add a reverse proxy that presents a
fixed host name, embeds a TLS proxy, and sends the underlying requests back to
the underlying host(s). +
It should act as an intermediary between the clients and the internal servers.
The proxy can be configured to use a valid certificate that matches the
stable/public hostname.

==== In test environments

It is important to remember that test environments are an ideal target for
attackers who are already on an internal network: Test systems are typically
unprotected and expose a lot of information about production systems.

For this reason, it is important to take the same security precautions in this
type of environment as in a production environment. If a test server's
certificate is not properly associated with that host, trust is broken.

To avoid trust issues, the main alternative is to build an environment that
should be very similar to the production environment. In this way,
comprehensive testing can be performed without compromising the security of the
tests while maintaining the reliability of the production environment.

This environment should include an internal certificate authority (CA) and
internal DNS resolvers that mimic the behavior of the system in production. +
Note that the CA root certificate should be included in the system's trust
store.

==== On a development machine

In case the "remote host" is located on a development machine and you cannot
afford a full-fledged test environment, a smaller alternative to the previous
section is recommended:

* Create a self-signed certificate for that machine.
* Add this self-signed certificate to the system's trust store.
* Set the correct host name in the `/etc/hosts` file.
