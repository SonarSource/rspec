<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Uses of <code>std::strstream</code> and <code>std::ostrstream</code> should be replaced with:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>std::stringstream</code> and <code>std::ostringstream</code> to use dynamically allocated buffer</p>
</li>
<li>
<p><code>std::spanstream</code> and <code>std::ospanstream</code> to use preallocated buffer.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Uses of <code>std::istrstream</code> should be replaced with <code>std::ispanstream</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The input <code>std::istrstream</code>, output <code>std::ostrstream</code>, and combined <code>std::iostream</code> stream classes
are deprecated since their introduction in the C&#43;&#43;98 standard.</p>
</div>
<div class="paragraph">
<p>Those stream classes support two use cases, and their behavior differs vastly depending
on how the object is constructed:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When constructed without argument, the stream object manages a dynamically allocated buffer;</p>
</li>
<li>
<p>When constructed from <code>char*</code> buffer and size, the stream object uses only the provided buffer.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The above behaviors make the <code>strstream</code> classes hard to use correctly.
As illustration the <code>str()</code> member function:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>returns a buffer that has unclear ownership;</p>
</li>
<li>
<p>does not return the size of readable characters nor guarantees null-termination of the buffer;</p>
</li>
<li>
<p>may leak unless <code>freeze(false)</code> is called afterwards.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>With the introduction of the <code>std::spanstream</code>, <code>std::ispanstream</code> and <code>std::ospanstream</code> C&#43;&#43;23,
all uses of the <code>std::strstream</code>, <code>std::ostrstream</code> and <code>std::ispanstream</code> classes may be replaced,
with one of the following classes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>std::stringstream</code> and <code>std::ostringstream</code> to use managed and growing buffer,</p>
</li>
<li>
<p><code>std::spanstream</code>, <code>std::ospanstream</code> and <code>std::ispanstream</code> to use preallocated buffer with fixed size.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This rule will raise an issue when the new object of <code>strstream</code> is created:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">std::string printData(std::string_view entry, int count) {
  std::ostrstream os; // Noncompliant
  os &lt;&lt; "The entry '" &lt;&lt; entry &lt;&lt; "' was repeated " &lt;&lt; count &lt;&lt; " times." &lt;&lt; std::ends;
  char const* content = os.str();
  os.freeze(false);
  return std::string(content);
}

int readInt(std::istrstream);

void process() {
  readInt(std::istrstream("10")); // Noncompliant
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Furthermore, the issue will be raised if a data member of the class is declared with one of <code>strstream</code> types:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">class Printer {
  /* .... */
private:
  std::ostrstream os; // Noncompliant
};</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_fix_it">How to fix it</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To fix the code you should change the type of the highlighted data member, field, or object as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>std::strstream</code> to <code>std::stringstream</code> or <code>std::spanstream</code></p>
</li>
<li>
<p><code>std::ostrstream</code> to <code>std::ostringstream</code> or <code>std::ospanstream</code>,</p>
</li>
<li>
<p><code>std::isstrstream</code> to <code>std::ispanstream</code>.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_replacing_output_streams_with_dynamic_buffers">Replacing output streams with dynamic buffers</h3>
<div class="paragraph">
<p>When a <code>std::strstream</code> or <code>std::ostrstream</code> is using a dynamically allocated growing buffer (i.e., it was constructed without arguments),
it should be replaced with <code>std::stringstream</code> and <code>std::ostringstream</code>, respectively.</p>
</div>
<div class="paragraph">
<p>With this change, the type of the <code>str()</code> member function will change from the C-string <code>char const*</code> of unclear size and ownership to a well-managed <code>std::string</code>.
Furthermore, when extracting the content is the last operation of the stream,
you may call <code>std::move</code> on the stream before calling <code>str()</code> to avoid copying and allocating a new buffer.</p>
</div>
<div class="sect3">
<h4 id="_noncompliant_code_example">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">std::string printData(std::string_view entry, int count) {
  std::ostrstream os; // Noncompliant
  os &lt;&lt; "The entry '" &lt;&lt; entry &lt;&lt; "' was repeated " &lt;&lt; count &lt;&lt; " times." &lt;&lt; std::ends;
  char const* content = os.str();
  os.freeze(false);
  return std::string(content);
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">std::string printData(std::string_view entry, int count) {
  std::ostringstream os; // Compliant
  os &lt;&lt; "The entry '" &lt;&lt; entry &lt;&lt; "' was repeated " &lt;&lt; count &lt;&lt; " times." &lt;&lt; std::ends;
  return std::move(os).str();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_replacing_output_streams_with_preallocated_buffers">Replacing output streams with preallocated buffers</h3>
<div class="paragraph">
<p>When the <code>std::strstream</code> or <code>std::ostrstream</code> is used to put a string
into a preallocated buffer, the same behavior can be preserved by using <code>std::spanstream</code> and <code>std::ospanstream</code>, respectively.</p>
</div>
<div class="paragraph">
<p>Their constructors accept a <code>std::span&lt;char&gt;</code> instead of a pair of pointer and size.
Furthermore, the <code>str()</code> member function should be replaced with the <code>span()</code> member function, which returns the written range.</p>
</div>
<div class="sect3">
<h4 id="_noncompliant_code_example_2">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">std::string_view formatDateTo(int y, int m, int d, std::span&lt;char&gt; buffer) {
  std::ostrstream os(buffer.data(), buffer.size()); // Noncompliant
  os &lt;&lt; y &lt;&lt; "/"  &lt;&lt; m &lt;&lt; "/" &lt;&lt; d &lt;&lt; std::ends;

  char const* data = os.str();
  // Avoid buffer overflow, if the size of the buffer was not sufficient,
  // by using POSIX 'strnlen(p, n)' function that will return `n` if
  // null-terminator is not found in first `n` bytes of buffer pointed
  // by `p`.
  std::size_t n = strnlen(data, buffer.size());
  return std::string_view(data, n);
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution_2">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">std::string_view formatDateTo(int y, int m, int d, std::span&lt;char&gt; buffer) {
  std::ospanstream os(buffer); // Compliant
  os &lt;&lt; y &lt;&lt; "/"  &lt;&lt; m &lt;&lt; "/" &lt;&lt; d;
  return std::string_view(os.span());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can avoid null-terminating the buffer (using <code>std::ends</code>), as <code>span()</code> provides both the pointer and the number of written characters.</p>
</div>
</div>
<div class="sect3">
<h4 id="_avoiding_truncation_of_content">Avoiding truncation of content</h4>
<div class="paragraph">
<p>With both <code>std::ostrstream</code> and <code>std::ospanstream</code>, the output is trimmed when the size of the buffer is insufficient for the content.
If using a preallocated buffer is not strictly necessary for performance reasons, you should consider using a <code>stringstream</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">std::string formatDate(int y, int m, int d) {
  std::ostringstream os; // Compliant
  os &lt;&lt; y &lt;&lt; "/"  &lt;&lt; m &lt;&lt; "/" &lt;&lt; d &lt;&lt; std::ends;
  return std::move(os).str();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_replacing_input_streams">Replacing input streams</h3>
<div class="paragraph">
<p><code>std::ispanstream</code> should be used instead of <code>std::istrstream</code> to parse the content of a buffer.
This requires converting the input arguments to <code>std::span&lt;const char&gt;</code> which can be performed as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>std::span(ptr, size)</code> if <code>std::istrstream</code> was constructed from pointer <code>ptr</code> and <code>size</code>;</p>
</li>
<li>
<p><code>std::string_view(cstr)</code> if <code>std::istrstream</code> was constructed from null-terminated C-string <code>cstr</code>.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_noncompliant_code_example_3">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">int sum1(char const* buffer, int size) {
  int x, y;
  std::istrstream is(buffer, size); // Noncompliant
  is &gt;&gt; x &gt;&gt; y;
  return x + y;
}

int sum2(char const* cstr) {
  int x, y;
  std::istrstream is(cstr); // Noncompliant
  is &gt;&gt; x &gt;&gt; y;
  return x + y;
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution_3">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">int sum1(char const* buffer, int size) {
  int x, y;
  std::ispanstream is{std::span(buffer, size)}; // Compliant
  is &gt;&gt; x &gt;&gt; y;
  return x + y;
}

int sum2(char const* cstr) {
  int x, y;
  std::ispanstream is{std::string_view(cstr)}; // Compliant
  is &gt;&gt; x &gt;&gt; y;
  return x + y;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_fixing_issue_incrementally">Fixing issue incrementally</h3>
<div class="paragraph">
<p>When the modified object is passed to a function, you may also need to adjust its signature.
This, in turn, may require modifying other call sites of the given function and lead to large refactorings.
In this section, we discuss a few options to mitigate the scale of the changes.</p>
</div>
<div class="sect3">
<h4 id="_passing_reference_to_base_class">Passing reference to base class</h4>
<div class="paragraph">
<p>When the body of the function does not use any functionality specific to <code>strstream</code> type,
the best option may be to change the parameter to the reference to the corresponding base class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">void print(std::ostrstream&amp; os, int n) {
  os &lt;&lt; n;
  /* More streaming operations */
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">void print(std::ostream&amp; os, int n) {
  os &lt;&lt; n;
  /* More streaming operations */
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This change allows the above function to be invoked with <code>stream</code>, <code>spanstream</code>, and <code>stringstream</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_introducing_separate_overloads">Introducing separate overloads</h4>
<div class="paragraph">
<p>If the called function uses <code>strstream</code> specific functionality  (like calling <code>str()</code>),
adding additional overload for corresponding <code>stringstream</code> or <code>spanstream</code> allows incremental improvements of the code.</p>
</div>
<div class="paragraph">
<p>To reduce code duplication, extract parts of the function that are not dependent on the <code>strstream</code> specific
functionalities into a helper function that accepts a reference to the corresponding base class.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">void finalizeImpl(std::ostream&amp; os) {
  // Part that is not dependent on the type of stream
}

std::string finalize(std::ostrstream os) {
  finalizeImpl(os);

  os &lt;&lt; std::ends;
  char const* data = os.str();
  os.freeze(false);
  return data;
}

std::string finalize(std::stringstream os) {
  finalizeImpl(os);

  return std::move(os).str();
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_documentation">Documentation</h3>
<div class="ulist">
<ul>
<li>
<p>C&#43;&#43; reference - <a href="https://en.cppreference.com/w/cpp/io/strstream/str"><code>std::strstream::str</code></a></p>
</li>
<li>
<p>C&#43;&#43; reference - <a href="https://en.cppreference.com/w/cpp/header/spanstream">Standard library header &lt;spanstream&gt;</a></p>
</li>
<li>
<p>C&#43;&#43; reference - <a href="https://en.cppreference.com/w/cpp/header/sstream">Standard library header &lt;sstream&gt;</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>