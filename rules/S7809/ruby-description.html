<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This rule raises an issue when a module directly references a constant that is also defined in an including class, as the module&#8217;s constant will always take precedence due to lexical scoping.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Ruby uses lexical scoping for constants, which means that when a module references a constant directly (like <code>CONSTANT</code>), Ruby looks for that constant in the module&#8217;s own namespace first. This happens even if the same constant is defined in a class that includes the module.</p>
</div>
<div class="paragraph">
<p>This behavior can be surprising to developers who expect the including class&#8217;s constant to override or customize the module&#8217;s behavior. The module will always use its own constant, ignoring any constants with the same name defined in including classes.</p>
</div>
<div class="paragraph">
<p>This can lead to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Unexpected behavior where configuration constants don&#8217;t work as intended</p>
</li>
<li>
<p>Difficult-to-debug issues where changes to class constants have no effect</p>
</li>
<li>
<p>Code that appears to be customizable but actually isn&#8217;t</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The lexical scoping rule exists for good reasons in Ruby, but when you want a module to be customizable by including classes, you need to explicitly access the including class&#8217;s namespace.</p>
</div>
<div class="sect2">
<h3 id="_what_is_the_potential_impact">What is the potential impact?</h3>
<div class="paragraph">
<p>This issue can cause configuration problems and unexpected behavior in applications. When developers define constants in classes to customize module behavior, those constants will be silently ignored, leading to the module using default values instead of the intended customized ones. This can result in incorrect application behavior that may be difficult to debug.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_to_fix_it">How to fix it</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Use explicit class scoping with <code>self.class::CONSTANT</code> to access the constant from the including class instead of the module&#8217;s own constant.</p>
</div>
<div class="sect2">
<h3 id="_code_examples">Code examples</h3>
<div class="sect3">
<h4 id="_noncompliant_code_example">Noncompliant code example</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">module Auth
  USER_KEY = "default_user"

  def authorize
    user_id = session[USER_KEY]  # Noncompliant: always uses "default_user"
  end
end

class ApplicationController
  USER_KEY = "my_user"  # This constant is ignored
  include Auth
end</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_compliant_solution">Compliant solution</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">module Auth
  USER_KEY = "default_user"

  def authorize
    user_key = self.class::USER_KEY  # Uses the including class's constant
    user_id = session[user_key]
  end
end

class ApplicationController
  USER_KEY = "my_user"  # This constant will be used
  include Auth
end</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_documentation">Documentation</h3>
<div class="ulist">
<ul>
<li>
<p>Ruby Module Documentation - <a href="https://ruby-doc.org/core/Module.html">Official Ruby documentation on modules and mixins</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>