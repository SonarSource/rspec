This is an issue when GString expressions (strings containing `${}` interpolation or `$variable` syntax) are used as keys in map literals or when calling map methods like `put()`.

== Why is this an issue?

GString objects and String objects have different hash codes, even when they represent identical text. This causes maps to fail matching keys when mixing GStrings and Strings.

When a GString is used as a map key, lookups with an equivalent String will fail. For example, storing with `"${name}"` (where `name` is `"John"`) and retrieving with `"John"` returns `null`.

This violates expectations and leads to bugs, especially when keys are created dynamically in one part of the code and used as literals elsewhere.

== What is the potential impact?

Using GString expressions as map keys can cause data loss, logic errors, silent failures, and inconsistent behavior. These issues may result in data corruption, incorrect logic, or reliability problems in production.

== How to fix it

Use regular variables or String literals as map keys instead of GString expressions. This ensures consistent hash codes and reliable key lookups.

=== Code examples

==== Noncompliant code example

[source,groovy,diff-id=1,diff-type=noncompliant]
----
def key = "a"
def m = ["${key}": "letter ${key}"] // Noncompliant
assert m["a"] == null  // fails to find the value
----

==== Compliant solution

[source,groovy,diff-id=1,diff-type=compliant]
----
def key = "a"
def m = [(key): "letter ${key}"]
assert m["a"] == "letter a"  // works correctly
----

== Resources

=== Documentation

 * Groovy Documentation - GString and String hashCodes - https://groovy-lang.org/syntax.html#_gstring_and_string_hashcodes[Official Groovy documentation explaining the hash code differences between GStrings and Strings]

 * Groovy Development Kit - Maps - https://groovy-lang.org/groovy-dev-kit.html#Collections-Maps[Documentation on working with maps in Groovy, including key handling best practices]
