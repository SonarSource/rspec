== Why is this an issue?

When a regular function throws an exception, stack unwinding occurs.
This applies for throw statements inside the function, or for any exception thrown from an inner function call.

{cpp}20 introduced coroutines, a stackless method to invoke functions that can be suspended and resumed.
Because of this, exceptions
behave differently.
The _Promise object_ of any coroutine is required to have an `unhandled_exception` function.
If an exception escapes the coroutine function body, the `unhandled_exception` function is called, followed by `final_suspend`.
Resuming the coroutine after this point is undefined behaviour.


The `unhandled_exception` method is used to define such behaviour.
The exception can be obtained with `std::current_exception`, and can be logged, rethrown or stored, depending on the use case:

- If rethrown, the exception will be received in any calling thread.
- If stored, it can be propagated through the _Promise object_ to the awaiting thread.

In the case of noexcept specified coroutines, this rule does not apply.


=== Noncompliant code example
[source,cpp,diff-id=1,diff-type=noncompliant]
----
struct Task {
  struct promise_type {
    /* ... */
    void unhandled_exception() {}
  };
};
----

=== Compliant solution
[source,cpp,diff-id=1,diff-type=compliant]
----
struct Task {
  struct promise_type {
    void unhandled_exception() {
      except = std::current_exception(); // store exception
    }

    std::exception_ptr except; // awaiter can check and obtain it via promise()
  };
};
----
