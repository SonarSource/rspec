This rule raises an issue when `Thread.sleep()` or `sleep()` is called within a loop where the thread is waiting for a condition to change.

== Why is this an issue?

Busy waiting with `Thread.sleep()` in loops is an anti-pattern that wastes CPU resources and creates unpredictable timing behavior.

When a thread uses `Thread.sleep()` inside a loop to wait for a condition, it forces the thread to wake up at regular intervals just to check if the condition has changed. This approach has several problems:

* *Resource waste*: The thread consumes CPU cycles unnecessarily by repeatedly waking up and checking conditions
* *Unpredictable timing*: The actual sleep duration may vary depending on system load and thread scheduling
* *Poor responsiveness*: The thread may not respond immediately when the awaited condition becomes true
* *Scalability issues*: Multiple threads doing busy waiting can significantly impact system performance


=== What is the potential impact?

Busy waiting can lead to:

* Increased CPU usage and reduced system performance
* Poor application responsiveness
* Scalability problems when multiple threads are involved
* Unpredictable behavior due to timing variations

== How to fix it

Replace busy waiting with `CountDownLatch.await()` for one-time events.

=== Code examples

==== Noncompliant code example

[source,groovy,diff-id=1,diff-type=noncompliant]
----
while (!condition) {
    Thread.sleep(1000) // Noncompliant
}
----

==== Compliant solution

[source,groovy,diff-id=1,diff-type=compliant]
----
CountDownLatch latch = new CountDownLatch(1)
// Signal from another thread: latch.countDown()
latch.await() // Blocks until signaled
----

== Resources

=== Standards

 * CWE-400: Uncontrolled Resource Consumption - https://cwe.mitre.org/data/definitions/400.html[Busy waiting can lead to excessive CPU consumption]
