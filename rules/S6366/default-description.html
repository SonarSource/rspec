<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>One of the use cases for the coroutines is suspending execution until certain conditions are satisfied (e.g. value is produced, flag/event is triggered).
In some situations, the expected result may be already available at the point of the <code>co_await</code>/<code>co_yield</code> expression, and the execution can be resumed immediately.</p>
</div>
<div class="paragraph">
<p>The C&#43;&#43; standard provides an efficient method to suspend the coroutine conditionally.
The result of <code>await_ready</code> is used to determine whether a coroutine should be suspended.
Returning <code>true</code> from this function avoids the cost of the coroutine suspension if it is not needed (e.g., the result is already available).
Furthermore, the <code>bool</code>-returning version of <code>await_suspend</code> allows immediate resumption of the current coroutine in the case when <code>false</code> is returned
(returning <code>true</code> indicates that the coroutine should remain suspended).
Compared to symmetric transfer, this method provides better optimization opportunities, as the continuation code is known to the compiler - i.e.,
it is the code of the current coroutine, while in symmetric transfer the handle could point to an arbitrary coroutine.</p>
</div>
<div class="paragraph">
<p>This rule raises an issue on <code>await_suspend</code> that can benefit from using conditional suspension.</p>
</div>
<div class="sect2">
<h3 id="_noncompliant_code_example">Noncompliant code example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">struct WaitForAwaiter {
  Event&amp; event;
  /* .... */
  std::coroutine_handle&lt;&gt; await_suspend(std::coroutine_handle&lt;&gt; current) { // Noncompliant
    bool callback_registered = event.register_callback(current);
    if (!callback_registered) {
      return current;
    } else {
      return std::noop_coroutine();
    }
  }
};

struct ReadBytesAwaiter {
  Socket&amp; socket;
  std::size_t count;
  std::span&lt;std::byte&gt; buffer;
  std::error_code error;
  /* .... */
  void await_suspend(std::coroutine_handle&lt;&gt; current) { // Noncompliant
    auto callback = [&amp;error_store=error, current](std::error_code ec) {
      error_store = ec;
      current.resume();
    };

    auto ec = socket.async_read(buffer, count, callback);
    if (ec) {
      error = ec;
      current.resume();
    }
  }
};</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_compliant_solution">Compliant solution</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">struct WaitForAwaiter {
  Event&amp; event;
  /* .... */
  bool await_ready() const {
    return event.is_already_triggered();
  }
  bool await_suspend(std::coroutine_handle&lt;&gt; current) {
    bool callback_registered = event.register_callback(current);
    return callback_registered;
  }
};

struct ReadBytesAwaiter {
  Socket&amp; socket;
  std::size_t count;
  std::span&lt;std::byte&gt; buffer;
  std::error_code error;
  /* .... */

  bool await_ready() const {
    return false; // no way to query before suspension
  }
  bool await_suspend(std::coroutine_handle&lt;&gt; current) {
    auto callback = [&amp;error_store=error, current](std::error_code ec) {
      error_store = ec;
      current.resume();
    };

    auto ec = socket.async_read(buffer, count, callback);
    if (ec) {
      error = ec;
      return false;
    }

    return true;
  }
};</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a data-rspec-id="S6365" class="rspec-auto-link">S6365</a> - transferring execution to any suspended coroutine</p>
</div>
</div>
</div>