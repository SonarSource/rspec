One of the use cases for the coroutines is suspending execution until certain conditions are satisfied, e.g. the action is finished or an event was triggered.
In some situations, it is possible that the conditions are satisfied at the point of the await, and the execution can be resumed immediately.

Immediate resumption of the coroutine may be performed by returning its handle from the `await_suspend` method or (even worse) calling `resume` directly,
however the C++ provides a more efficient method to do so. 
Firstly, the suspension of the coroutine may be avoided entirely, by returning `true` from the `await_ready` method, or the resumption may be triggered
by returning `false` from the `await_suspend`.

This rule raises an issue on the `await_suspend` method that could be changed to use conditional suspension.

== Noncompliant Code Example

----
struct WaitForAwaiter {
  Event& event;
  /* .... */
  void await_suspend(std::coroutine_handle<> current) { // Noncomplaint
    if (bool ready = event.register_callback(current)) {
      h.resume();
    }
  }
}
----

== Compliant Solution

----
struct WaitForAwaiter {
  Event& event;
  /* .... */
  bool await_ready() const {
    return event.is_ready(); // false if method to check state is not available
  }
  bool await_suspend(std::coroutine_handle<> current) {
    return !event.register_callback(current));
  }
}
----

== See

S6365 - transfering execution to any suspended coroutine
