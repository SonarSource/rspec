One of the use cases for the coroutines is suspending execution until certain conditions are satisfied.
In some situations, it is possible that the conditions are already satisfied at the point of the await and the execution can be resumed immediately.

The {cpp} standard provides an efficient method to conditionally suspend the coroutine.
Firstly, the result of `await_ready` is used to determine whether a coroutine should be suspended. Returning `true` from this function, when conditions are satisfied,
avoids the cost of the coroutine suspension.
Furthermore, the `bool`-returning version of `await_suspend` allows immediate resumption of the current coroutine in the case when `false` is returned
(returning `true` indicates that the coroutine should remain suspended).
Compared to symmetric transfer, this method provides better optimization opportunities, as the continuation code is known to the compiler - i.e.
the code of the current coroutine is invoked, while the returned handle could point to an arbitral coroutine.

This rule raises an issue on `await_suspend` that can benefit from using conditional suspension.

== Noncompliant Code Example

----
struct WaitForAwaiter {
  Event& event;
  /* .... */
  void await_suspend(std::coroutine_handle<> current) { // Noncompliant
    if (bool ready = event.register_callback(current)) {
      return current;
    } else {
      return std::noop_coroutine();
    }
  }
}

struct ReadBytesAwaiter {
  Socket& socket;
  std::size_t count;
  std::span<std::byte> buffer;
  std::error_code error;
  /* .... */
  void await_suspend(std::coroutine_handle<> current) { // Noncompliant
    auto callback = [&error](std::error_code ec) { 
      error = ec;
      current.resume();
    };
     
    auto ec = socket.async_read(buffer, count, callback);
    if (!ec) {
      error = ec;
      current.resume();
    }
  }
}
----

== Compliant Solution

----
struct WaitForAwaiter {
  Event& event;
  /* .... */
  bool await_ready() const {
    return event.is_ready();
  }
  bool await_suspend(std::coroutine_handle<> current) {
    return !event.register_callback(current));
  }
}

struct ReadBytesAwaiter {
  Socket& socket;
  std::size_t count;
  std::span<std::byte> buffer;
  std::error_code error;
  /* .... */

  bool await_ready() const {
    return false; // no way to query before suspension
  }
  void await_suspend(std::coroutine_handle<> current) {
    auto callback = [&error](std::error_code ec) { 
      error = ec;
      current.resume();
    };
     
    auto ec = socket.async_read(buffer, count, callback);
    if (!ec) {
      error = ec;
      return false;
    }
   
    return true;
  }
}
----

== See

S6365 - transfering execution to any suspended coroutine
