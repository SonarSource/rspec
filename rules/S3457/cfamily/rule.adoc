== Why is this an issue?

Because `printf` format strings are interpreted at runtime rather than validated by the compiler, they can contain errors that result in the wrong string being created. This rule statically validates the correlation of `printf` format strings and their arguments.

[source,cpp]
----
printf("%d", 1, 2); // Noncompliant: the second argument "2" is unused
printf("%0-f", 1.2); // Noncompliant: flag "0" is ignored because of "-"
----

Starting with C++20, `std::format` should be preferred, as it is more readable and validated at compile-time, making it more secure. S6494 covers that.

This rule is about errors that produce an unexpected string. For errors that will create undefined behavior, see the related rule S2275.

This rule will only work if the format string is provided as a string literal.

== Resources

=== Documentation

* https://en.cppreference.com/w/cpp/utility/format/format[`std::format` starting from C++20]

=== Standards

* https://wiki.sei.cmu.edu/confluence/x/J9YxBQ[CERT, FIO47-C.] - Use valid format strings

=== Related rules

* S6494 - C++ formatting functions should be used instead of C printf-like functions

* S2275 - Printf-style format strings should not lead to unexpected behavior at runtime

ifdef::env-github,rspecator-view[]

'''
== Implementation Specification
(visible only on this page)

include::../message.adoc[]

'''
== Comments And Links
(visible only on this page)

include::../comments-and-links.adoc[]

endif::env-github,rspecator-view[]
