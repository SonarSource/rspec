When building a REST API, https://learn.microsoft.com/en-us/aspnet/core/mvc/controllers/routing?view=aspnetcore-8.0#attribute-routing-with-http-verb-attributes[it's recommended] to use the available https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.routing.httpmethodattribute[HTTP attributes] over the controller actions, so that you are precise about what your API supports.

== Why is this an issue?

- Ambiguity: Without HttpAttributes, it's not immediately clear which HTTP methods an action method should respond to. This can lead to confusion and make the code harder to understand and maintain.

- Unsupported HTTP Methods: If an action is not annotated at all or is annotated only with the Route attribute, it accepts all HTTP methods even if they are not supported by that action, which leads to further confusion.

- Problems with Swagger: Swagger, relies on HttpAttributes to generate parts of the API documentation. Without these attributes, the generated documentation is incomplete.

- Route path conflicts: Without HttpAttributes, it's possible to accidentally create action methods that respond to the same route and HTTP method. This can lead to unexpected behavior and hard-to-diagnose bugs.

- Lack of routing flexibility: The HTTP attributes allow you to define multiple action methods in the same controller that respond to the same route but different HTTP methods. If you don't use them you might have limited flexibility when designing your API.

== How to fix it

To avoid the issues mentioned earlier, it's generally recommended to use HttpAttributes (in conjunction with the Route attribute if needed). This allows you to clearly define the HTTP methods each action method should respond to, while still being able to customize your routes.

== Exceptions

This rule does not raise if the controller or the action is annotated with `[ApiExplorerSettings(IgnoreApi = true)]`.

=== Code examples

==== Noncompliant code example

[source,csharp,diff-id=1,diff-type=noncompliant]
----
[Route("Test")]                                       // This route conflicts with FooGet action route
public async Task<IResult> Foo([FromQuery] string id) // Noncompliant
{
    // Create here a new object with id and add it to a database
    return Results.Ok();
}

[Route("Test")]                                      // This route conflicts with FooGet action route
public async Task<string> FooGet()
{
    return "Hello";
}
----

==== Compliant solution

[source,csharp,diff-id=1,diff-type=compliant]
----
[Route("Test")] 
[HttpPost]
public async Task<IResult> Foo([FromQuery] string id) // Compliant
{
    // Create here a new object with id and add it to a database
    return Results.Ok();
}

[HttpGet("Test")]                                     // Compliant
public async Task<string> FooGet()
{
    return "Hello";
}
----

== Resources

=== Documentation

* Microsoft Learn - https://learn.microsoft.com/en-us/aspnet/core/mvc/controllers/routing[Routing to controller actions in ASP.NET Core]
* Microsoft Learn - https://learn.microsoft.com/en-us/aspnet/core/mvc/controllers/routing#attribute-routing-with-http-verb-attributes[Attribute routing with Http verb attributes]
* Microsoft Learn - https://learn.microsoft.com/en-us/aspnet/core/tutorials/getting-started-with-swashbuckle[Get started with Swashbuckle and ASP.NET Core]
* Microsoft Learn - https://learn.microsoft.com/en-us/aspnet/core/web-api/handle-errors#exception-handler[ASP.NET Core Exception handler]

ifdef::env-github,rspecator-view[]

'''
== Implementation Specification
(visible only on this page)

=== Message

You should annotate this action with the appropriate HTTP verb attribute.

=== Highlighting

* Primary location: Action signature

endif::env-github,rspecator-view[]